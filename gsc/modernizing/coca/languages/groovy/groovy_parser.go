// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package parser // GroovyParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type GroovyParser struct {
	*antlr.BaseParser
}

var groovyparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func groovyparserParserInit() {
	staticData := &groovyparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "", "", "", "", "'as'", "'def'", "'in'", "'trait'", "'threadsafe'",
		"'var'", "", "'abstract'", "'assert'", "'break'", "'case'", "'catch'",
		"'class'", "'const'", "'continue'", "'default'", "'do'", "'else'", "'enum'",
		"'extends'", "'final'", "'finally'", "'for'", "'if'", "'goto'", "'implements'",
		"'import'", "'instanceof'", "'interface'", "'native'", "'new'", "'package'",
		"'private'", "'protected'", "'public'", "'return'", "'static'", "'strictfp'",
		"'super'", "'switch'", "'synchronized'", "'this'", "'throw'", "'throws'",
		"'transient'", "'try'", "'void'", "'volatile'", "'while'", "", "", "",
		"'null'", "'..'", "'..<'", "'*.'", "'?.'", "'??.'", "'?:'", "'.&'",
		"'::'", "'=~'", "'==~'", "'**'", "'**='", "'<=>'", "'==='", "'!=='",
		"'->'", "'!instanceof'", "'!in'", "'('", "')'", "'{'", "'}'", "'['",
		"']'", "';'", "','", "", "'='", "'>'", "'<'", "'!'", "'~'", "'?'", "':'",
		"'=='", "'<='", "'>='", "'!='", "'&&'", "'||'", "'++'", "'--'", "'+'",
		"'-'", "'*'", "", "'&'", "'|'", "'^'", "'%'", "'+='", "'-='", "'*='",
		"'/='", "'&='", "'|='", "'^='", "'%='", "'<<='", "'>>='", "'>>>='",
		"'?='", "", "", "'@'", "'...'",
	}
	staticData.symbolicNames = []string{
		"", "StringLiteral", "GStringBegin", "GStringEnd", "GStringPart", "GStringPathPart",
		"RollBackOne", "AS", "DEF", "IN", "TRAIT", "THREADSAFE", "VAR", "BuiltInPrimitiveType",
		"ABSTRACT", "ASSERT", "BREAK", "CASE", "CATCH", "CLASS", "CONST", "CONTINUE",
		"DEFAULT", "DO", "ELSE", "ENUM", "EXTENDS", "FINAL", "FINALLY", "FOR",
		"IF", "GOTO", "IMPLEMENTS", "IMPORT", "INSTANCEOF", "INTERFACE", "NATIVE",
		"NEW", "PACKAGE", "PRIVATE", "PROTECTED", "PUBLIC", "RETURN", "STATIC",
		"STRICTFP", "SUPER", "SWITCH", "SYNCHRONIZED", "THIS", "THROW", "THROWS",
		"TRANSIENT", "TRY", "VOID", "VOLATILE", "WHILE", "IntegerLiteral", "FloatingPointLiteral",
		"BooleanLiteral", "NullLiteral", "RANGE_INCLUSIVE", "RANGE_EXCLUSIVE",
		"SPREAD_DOT", "SAFE_DOT", "SAFE_CHAIN_DOT", "ELVIS", "METHOD_POINTER",
		"METHOD_REFERENCE", "REGEX_FIND", "REGEX_MATCH", "POWER", "POWER_ASSIGN",
		"SPACESHIP", "IDENTICAL", "NOT_IDENTICAL", "ARROW", "NOT_INSTANCEOF",
		"NOT_IN", "LPAREN", "RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK",
		"SEMI", "COMMA", "DOT", "ASSIGN", "GT", "LT", "NOT", "BITNOT", "QUESTION",
		"COLON", "EQUAL", "LE", "GE", "NOTEQUAL", "AND", "OR", "INC", "DEC",
		"ADD", "SUB", "MUL", "DIV", "BITAND", "BITOR", "XOR", "MOD", "ADD_ASSIGN",
		"SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN", "OR_ASSIGN",
		"XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN", "RSHIFT_ASSIGN", "URSHIFT_ASSIGN",
		"ELVIS_ASSIGN", "CapitalizedIdentifier", "Identifier", "AT", "ELLIPSIS",
		"WS", "NL", "SH_COMMENT", "UNEXPECTED_CHAR",
	}
	staticData.ruleNames = []string{
		"compilationUnit", "scriptStatements", "scriptStatement", "packageDeclaration",
		"importDeclaration", "typeDeclaration", "modifier", "modifiersOpt",
		"modifiers", "classOrInterfaceModifiersOpt", "classOrInterfaceModifiers",
		"classOrInterfaceModifier", "variableModifier", "variableModifiersOpt",
		"variableModifiers", "typeParameters", "typeParameter", "typeBound",
		"typeList", "classDeclaration", "classBody", "enumConstants", "enumConstant",
		"classBodyDeclaration", "memberDeclaration", "methodDeclaration", "methodName",
		"returnType", "fieldDeclaration", "variableDeclarators", "variableDeclarator",
		"variableDeclaratorId", "variableInitializer", "variableInitializers",
		"dims", "dimsOpt", "standardType", "typeType", "classOrInterfaceType",
		"generalClassOrInterfaceType", "standardClassOrInterfaceType", "primitiveType",
		"typeArguments", "typeArgument", "annotatedQualifiedClassName", "qualifiedClassNameList",
		"formalParameters", "formalParameterList", "thisFormalParameter", "formalParameter",
		"methodBody", "qualifiedName", "qualifiedNameElement", "qualifiedNameElements",
		"qualifiedClassName", "qualifiedStandardClassName", "literal", "gstring",
		"gstringValue", "gstringPath", "lambdaExpression", "standardLambdaExpression",
		"lambdaParameters", "standardLambdaParameters", "lambdaBody", "closure",
		"closureOrLambdaExpression", "blockStatementsOpt", "blockStatements",
		"annotationsOpt", "annotation", "elementValues", "annotationName", "elementValuePairs",
		"elementValuePair", "elementValuePairName", "elementValue", "elementValueArrayInitializer",
		"block", "blockStatement", "localVariableDeclaration", "classifiedModifiers",
		"variableDeclaration", "typeNamePairs", "typeNamePair", "variableNames",
		"conditionalStatement", "ifElseStatement", "switchStatement", "loopStatement",
		"continueStatement", "breakStatement", "tryCatchStatement", "assertStatement",
		"statement", "catchClause", "catchType", "finallyBlock", "resources",
		"resourceList", "resource", "switchBlockStatementGroup", "switchLabel",
		"forControl", "enhancedForControl", "classicalForControl", "forInit",
		"forUpdate", "castParExpression", "parExpression", "expressionInPar",
		"expressionList", "expressionListElement", "enhancedStatementExpression",
		"statementExpression", "postfixExpression", "expression", "castOperandExpression",
		"commandExpression", "commandArgument", "pathExpression", "pathElement",
		"namePart", "dynamicMemberName", "indexPropertyArgs", "namedPropertyArgs",
		"primary", "list", "normalMap", "mapEntryList", "mapEntry", "mapEntryLabel",
		"creator", "arrayInitializer", "anonymousInnerClassDeclaration", "createdName",
		"nonWildcardTypeArguments", "typeArgumentsOrDiamond", "arguments", "argumentList",
		"enhancedArgumentList", "argumentListElement", "enhancedArgumentListElement",
		"stringLiteral", "className", "identifier", "builtInType", "keywords",
		"rparen", "nls", "sep",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 129, 1679, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 1, 0, 1, 0, 3, 0, 305, 8, 0, 1, 0, 3, 0, 308,
		8, 0, 1, 0, 3, 0, 311, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1,
		319, 8, 1, 10, 1, 12, 1, 322, 9, 1, 1, 1, 3, 1, 325, 8, 1, 1, 2, 1, 2,
		1, 2, 3, 2, 330, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 3, 4,
		339, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 346, 8, 4, 1, 5, 1, 5, 1,
		5, 1, 6, 1, 6, 3, 6, 353, 8, 6, 1, 7, 3, 7, 356, 8, 7, 1, 8, 1, 8, 1, 8,
		4, 8, 361, 8, 8, 11, 8, 12, 8, 362, 1, 9, 3, 9, 366, 8, 9, 1, 10, 1, 10,
		1, 10, 4, 10, 371, 8, 10, 11, 10, 12, 10, 372, 1, 11, 1, 11, 3, 11, 377,
		8, 11, 1, 12, 1, 12, 3, 12, 381, 8, 12, 1, 13, 3, 13, 384, 8, 13, 1, 14,
		1, 14, 1, 14, 4, 14, 389, 8, 14, 11, 14, 12, 14, 390, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 400, 8, 15, 10, 15, 12, 15, 403,
		9, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 413,
		8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 420, 8, 17, 10, 17, 12,
		17, 423, 9, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 430, 8, 18, 10,
		18, 12, 18, 433, 9, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 446, 8, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 3, 19, 452, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		3, 19, 461, 8, 19, 1, 19, 1, 19, 3, 19, 465, 8, 19, 1, 19, 3, 19, 468,
		8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 476, 8, 19, 1,
		19, 3, 19, 479, 8, 19, 1, 19, 3, 19, 482, 8, 19, 1, 19, 1, 19, 1, 20, 1,
		20, 1, 20, 1, 20, 3, 20, 490, 8, 20, 1, 20, 3, 20, 493, 8, 20, 1, 20, 3,
		20, 496, 8, 20, 1, 20, 3, 20, 499, 8, 20, 1, 20, 1, 20, 1, 20, 5, 20, 504,
		8, 20, 10, 20, 12, 20, 507, 9, 20, 1, 20, 3, 20, 510, 8, 20, 1, 20, 1,
		20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 520, 8, 21, 10, 21,
		12, 21, 523, 9, 21, 1, 21, 1, 21, 1, 21, 3, 21, 528, 8, 21, 1, 22, 1, 22,
		1, 22, 3, 22, 533, 8, 22, 1, 22, 3, 22, 536, 8, 22, 1, 23, 1, 23, 1, 23,
		3, 23, 541, 8, 23, 1, 23, 1, 23, 3, 23, 545, 8, 23, 1, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 3, 24, 552, 8, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1,
		25, 1, 25, 1, 25, 1, 25, 3, 25, 563, 8, 25, 1, 25, 1, 25, 3, 25, 567, 8,
		25, 1, 25, 3, 25, 570, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 3, 25, 579, 8, 25, 1, 25, 1, 25, 3, 25, 583, 8, 25, 3, 25, 585,
		8, 25, 1, 26, 1, 26, 3, 26, 589, 8, 26, 1, 27, 1, 27, 1, 27, 3, 27, 594,
		8, 27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 5, 29, 603, 8,
		29, 10, 29, 12, 29, 606, 9, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		3, 30, 614, 8, 30, 1, 31, 1, 31, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 5, 33, 627, 8, 33, 10, 33, 12, 33, 630, 9, 33,
		1, 33, 1, 33, 3, 33, 634, 8, 33, 1, 34, 1, 34, 1, 34, 1, 34, 4, 34, 640,
		8, 34, 11, 34, 12, 34, 641, 1, 35, 3, 35, 645, 8, 35, 1, 36, 1, 36, 1,
		36, 3, 36, 650, 8, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 3, 37, 657, 8,
		37, 1, 37, 3, 37, 660, 8, 37, 1, 37, 1, 37, 1, 38, 1, 38, 3, 38, 666, 8,
		38, 1, 38, 3, 38, 669, 8, 38, 1, 39, 1, 39, 3, 39, 673, 8, 39, 1, 40, 1,
		40, 3, 40, 677, 8, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 5, 42, 688, 8, 42, 10, 42, 12, 42, 691, 9, 42, 1, 42, 1,
		42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 703,
		8, 43, 3, 43, 705, 8, 43, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 5, 45, 715, 8, 45, 10, 45, 12, 45, 718, 9, 45, 1, 46, 1, 46,
		3, 46, 722, 8, 46, 1, 46, 1, 46, 1, 47, 1, 47, 3, 47, 728, 8, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 5, 47, 734, 8, 47, 10, 47, 12, 47, 737, 9, 47, 1,
		48, 1, 48, 1, 48, 1, 49, 1, 49, 3, 49, 744, 8, 49, 1, 49, 3, 49, 747, 8,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 755, 8, 49, 1, 50,
		1, 50, 1, 51, 1, 51, 1, 51, 5, 51, 762, 8, 51, 10, 51, 12, 51, 765, 9,
		51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 772, 8, 52, 1, 53, 1, 53,
		1, 53, 5, 53, 777, 8, 53, 10, 53, 12, 53, 780, 9, 53, 1, 54, 1, 54, 1,
		54, 1, 55, 1, 55, 1, 55, 1, 55, 5, 55, 789, 8, 55, 10, 55, 12, 55, 792,
		9, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 799, 8, 56, 1, 57, 1,
		57, 1, 57, 1, 57, 5, 57, 805, 8, 57, 10, 57, 12, 57, 808, 9, 57, 1, 57,
		1, 57, 1, 58, 1, 58, 1, 58, 3, 58, 815, 8, 58, 1, 58, 1, 58, 3, 58, 819,
		8, 58, 1, 59, 1, 59, 5, 59, 823, 8, 59, 10, 59, 12, 59, 826, 9, 59, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 62, 1, 62, 1, 63, 1, 63, 3, 63, 844, 8, 63, 1, 64, 1, 64, 3,
		64, 848, 8, 64, 1, 65, 1, 65, 1, 65, 3, 65, 853, 8, 65, 1, 65, 1, 65, 1,
		65, 1, 65, 3, 65, 859, 8, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 3, 66,
		866, 8, 66, 1, 67, 3, 67, 869, 8, 67, 1, 68, 1, 68, 1, 68, 1, 68, 5, 68,
		875, 8, 68, 10, 68, 12, 68, 878, 9, 68, 1, 68, 3, 68, 881, 8, 68, 1, 69,
		1, 69, 1, 69, 5, 69, 886, 8, 69, 10, 69, 12, 69, 889, 9, 69, 1, 70, 1,
		70, 1, 70, 1, 70, 3, 70, 895, 8, 70, 1, 70, 3, 70, 898, 8, 70, 1, 71, 1,
		71, 3, 71, 902, 8, 71, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 5, 73, 909, 8,
		73, 10, 73, 12, 73, 912, 9, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74,
		1, 75, 1, 75, 3, 75, 922, 8, 75, 1, 76, 1, 76, 1, 76, 3, 76, 927, 8, 76,
		1, 77, 1, 77, 1, 77, 1, 77, 5, 77, 933, 8, 77, 10, 77, 12, 77, 936, 9,
		77, 3, 77, 938, 8, 77, 1, 77, 3, 77, 941, 8, 77, 1, 77, 1, 77, 1, 78, 1,
		78, 1, 78, 5, 78, 948, 8, 78, 10, 78, 12, 78, 951, 9, 78, 3, 78, 953, 8,
		78, 1, 78, 1, 78, 1, 78, 1, 79, 1, 79, 3, 79, 960, 8, 79, 1, 80, 1, 80,
		1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 968, 8, 81, 1, 82, 1, 82, 3, 82, 972,
		8, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 981, 8,
		82, 1, 82, 3, 82, 984, 8, 82, 1, 82, 1, 82, 1, 82, 3, 82, 989, 8, 82, 1,
		83, 1, 83, 1, 83, 1, 83, 5, 83, 995, 8, 83, 10, 83, 12, 83, 998, 9, 83,
		1, 83, 1, 83, 1, 84, 3, 84, 1003, 8, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1,
		85, 1, 85, 4, 85, 1011, 8, 85, 11, 85, 12, 85, 1012, 1, 85, 1, 85, 1, 86,
		1, 86, 3, 86, 1019, 8, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 3,
		87, 1027, 8, 87, 1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 1033, 8, 87, 1, 88,
		1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 5, 88, 1041, 8, 88, 10, 88, 12, 88,
		1044, 9, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1,
		89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89,
		1, 89, 1, 89, 1, 89, 3, 89, 1068, 8, 89, 1, 90, 1, 90, 3, 90, 1072, 8,
		90, 1, 91, 1, 91, 3, 91, 1076, 8, 91, 1, 92, 1, 92, 3, 92, 1080, 8, 92,
		1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 5, 92, 1087, 8, 92, 10, 92, 12, 92,
		1090, 9, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1095, 8, 92, 1, 93, 1, 93, 1,
		93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 1104, 8, 93, 1, 94, 1, 94, 1, 94,
		1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1117, 8,
		94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94,
		1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1133, 8, 94, 1, 95, 1, 95, 1, 95, 1,
		95, 3, 95, 1139, 8, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96,
		1, 96, 5, 96, 1149, 8, 96, 10, 96, 12, 96, 1152, 9, 96, 1, 97, 1, 97, 1,
		97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 1162, 8, 98, 1, 98, 1, 98,
		1, 99, 1, 99, 1, 99, 1, 99, 5, 99, 1170, 8, 99, 10, 99, 12, 99, 1173, 9,
		99, 1, 100, 1, 100, 3, 100, 1177, 8, 100, 1, 101, 1, 101, 1, 101, 4, 101,
		1182, 8, 101, 11, 101, 12, 101, 1183, 1, 101, 1, 101, 1, 102, 1, 102, 1,
		102, 1, 102, 1, 102, 1, 102, 3, 102, 1194, 8, 102, 1, 103, 1, 103, 3, 103,
		1198, 8, 103, 1, 104, 1, 104, 3, 104, 1202, 8, 104, 1, 104, 1, 104, 1,
		104, 1, 104, 1, 105, 3, 105, 1209, 8, 105, 1, 105, 1, 105, 3, 105, 1213,
		8, 105, 1, 105, 1, 105, 3, 105, 1217, 8, 105, 1, 106, 1, 106, 3, 106, 1221,
		8, 106, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 109, 1, 109,
		1, 110, 1, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 5, 111, 1238, 8,
		111, 10, 111, 12, 111, 1241, 9, 111, 1, 112, 1, 112, 3, 112, 1245, 8, 112,
		1, 112, 1, 112, 1, 113, 1, 113, 3, 113, 1251, 8, 113, 1, 114, 1, 114, 1,
		115, 1, 115, 3, 115, 1257, 8, 115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 3, 116, 1276, 8, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 3, 116, 1303, 8, 116, 1, 116, 3, 116, 1306,
		8, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		3, 116, 1370, 8, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 5, 116, 1386,
		8, 116, 10, 116, 12, 116, 1389, 9, 116, 1, 117, 1, 117, 1, 117, 1, 117,
		1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 3, 117, 1401, 8, 117, 1,
		118, 1, 118, 1, 118, 3, 118, 1406, 8, 118, 1, 118, 5, 118, 1409, 8, 118,
		10, 118, 12, 118, 1412, 9, 118, 1, 119, 1, 119, 4, 119, 1416, 8, 119, 11,
		119, 12, 119, 1417, 1, 119, 3, 119, 1421, 8, 119, 1, 120, 1, 120, 1, 120,
		1, 120, 5, 120, 1427, 8, 120, 10, 120, 12, 120, 1430, 9, 120, 1, 121, 1,
		121, 1, 121, 1, 121, 1, 121, 3, 121, 1437, 8, 121, 1, 121, 1, 121, 1, 121,
		1, 121, 3, 121, 1443, 8, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1,
		121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1,
		121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 3,
		121, 1468, 8, 121, 1, 122, 1, 122, 1, 122, 1, 122, 3, 122, 1474, 8, 122,
		1, 123, 1, 123, 3, 123, 1478, 8, 123, 1, 124, 3, 124, 1481, 8, 124, 1,
		124, 1, 124, 3, 124, 1485, 8, 124, 1, 124, 1, 124, 1, 125, 3, 125, 1490,
		8, 125, 1, 125, 1, 125, 1, 125, 3, 125, 1495, 8, 125, 1, 125, 1, 125, 1,
		126, 1, 126, 3, 126, 1501, 8, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126,
		1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126,
		1516, 8, 126, 1, 127, 1, 127, 3, 127, 1520, 8, 127, 1, 127, 3, 127, 1523,
		8, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1, 128, 3, 128, 1530, 8, 128, 1,
		128, 3, 128, 1533, 8, 128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 5, 129,
		1540, 8, 129, 10, 129, 12, 129, 1543, 9, 129, 1, 130, 1, 130, 1, 130, 1,
		130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 1555, 8, 130,
		1, 131, 1, 131, 3, 131, 1559, 8, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1,
		132, 3, 132, 1566, 8, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132,
		4, 132, 1574, 8, 132, 11, 132, 12, 132, 1575, 1, 132, 1, 132, 1, 132, 1,
		132, 1, 132, 1, 132, 1, 132, 3, 132, 1585, 8, 132, 1, 133, 1, 133, 1, 133,
		3, 133, 1590, 8, 133, 1, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1, 135, 1,
		135, 1, 135, 1, 135, 3, 135, 1601, 8, 135, 3, 135, 1603, 8, 135, 1, 136,
		1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 3, 137,
		1614, 8, 137, 1, 138, 1, 138, 3, 138, 1618, 8, 138, 1, 138, 3, 138, 1621,
		8, 138, 1, 138, 1, 138, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 5, 139,
		1630, 8, 139, 10, 139, 12, 139, 1633, 9, 139, 1, 140, 1, 140, 1, 140, 1,
		140, 1, 140, 5, 140, 1640, 8, 140, 10, 140, 12, 140, 1643, 9, 140, 1, 141,
		1, 141, 3, 141, 1647, 8, 141, 1, 142, 1, 142, 1, 142, 3, 142, 1652, 8,
		142, 1, 143, 1, 143, 1, 144, 1, 144, 1, 145, 1, 145, 1, 146, 1, 146, 1,
		147, 1, 147, 1, 148, 1, 148, 3, 148, 1666, 8, 148, 1, 149, 5, 149, 1669,
		8, 149, 10, 149, 12, 149, 1672, 9, 149, 1, 150, 4, 150, 1675, 8, 150, 11,
		150, 12, 150, 1676, 1, 150, 0, 1, 232, 151, 0, 2, 4, 6, 8, 10, 12, 14,
		16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
		52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86,
		88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118,
		120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148,
		150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178,
		180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208,
		210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238,
		240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268,
		270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298,
		300, 0, 22, 6, 0, 8, 8, 12, 12, 36, 36, 47, 47, 51, 51, 54, 54, 5, 0, 14,
		14, 22, 22, 27, 27, 39, 41, 43, 44, 6, 0, 8, 8, 12, 12, 14, 14, 27, 27,
		39, 41, 43, 44, 2, 0, 26, 26, 45, 45, 2, 0, 85, 85, 93, 93, 2, 0, 9, 9,
		93, 93, 1, 0, 100, 101, 1, 0, 90, 91, 1, 0, 100, 103, 2, 0, 104, 105, 109,
		109, 1, 0, 102, 103, 1, 0, 60, 61, 4, 0, 9, 9, 77, 77, 88, 89, 95, 96,
		3, 0, 72, 74, 94, 94, 97, 97, 1, 0, 68, 69, 3, 0, 7, 7, 34, 34, 76, 76,
		3, 0, 71, 71, 87, 87, 110, 121, 2, 0, 62, 64, 86, 86, 5, 0, 7, 7, 9, 10,
		12, 12, 43, 43, 122, 123, 2, 0, 13, 13, 53, 53, 2, 0, 7, 55, 58, 59, 2,
		0, 84, 84, 127, 127, 1782, 0, 302, 1, 0, 0, 0, 2, 314, 1, 0, 0, 0, 4, 329,
		1, 0, 0, 0, 6, 331, 1, 0, 0, 0, 8, 335, 1, 0, 0, 0, 10, 347, 1, 0, 0, 0,
		12, 352, 1, 0, 0, 0, 14, 355, 1, 0, 0, 0, 16, 360, 1, 0, 0, 0, 18, 365,
		1, 0, 0, 0, 20, 370, 1, 0, 0, 0, 22, 376, 1, 0, 0, 0, 24, 380, 1, 0, 0,
		0, 26, 383, 1, 0, 0, 0, 28, 388, 1, 0, 0, 0, 30, 392, 1, 0, 0, 0, 32, 407,
		1, 0, 0, 0, 34, 414, 1, 0, 0, 0, 36, 424, 1, 0, 0, 0, 38, 445, 1, 0, 0,
		0, 40, 485, 1, 0, 0, 0, 42, 513, 1, 0, 0, 0, 44, 529, 1, 0, 0, 0, 46, 544,
		1, 0, 0, 0, 48, 551, 1, 0, 0, 0, 50, 584, 1, 0, 0, 0, 52, 588, 1, 0, 0,
		0, 54, 593, 1, 0, 0, 0, 56, 595, 1, 0, 0, 0, 58, 597, 1, 0, 0, 0, 60, 607,
		1, 0, 0, 0, 62, 615, 1, 0, 0, 0, 64, 617, 1, 0, 0, 0, 66, 619, 1, 0, 0,
		0, 68, 639, 1, 0, 0, 0, 70, 644, 1, 0, 0, 0, 72, 646, 1, 0, 0, 0, 74, 653,
		1, 0, 0, 0, 76, 665, 1, 0, 0, 0, 78, 670, 1, 0, 0, 0, 80, 674, 1, 0, 0,
		0, 82, 678, 1, 0, 0, 0, 84, 680, 1, 0, 0, 0, 86, 704, 1, 0, 0, 0, 88, 706,
		1, 0, 0, 0, 90, 709, 1, 0, 0, 0, 92, 719, 1, 0, 0, 0, 94, 727, 1, 0, 0,
		0, 96, 738, 1, 0, 0, 0, 98, 741, 1, 0, 0, 0, 100, 756, 1, 0, 0, 0, 102,
		758, 1, 0, 0, 0, 104, 771, 1, 0, 0, 0, 106, 778, 1, 0, 0, 0, 108, 781,
		1, 0, 0, 0, 110, 784, 1, 0, 0, 0, 112, 798, 1, 0, 0, 0, 114, 800, 1, 0,
		0, 0, 116, 818, 1, 0, 0, 0, 118, 820, 1, 0, 0, 0, 120, 827, 1, 0, 0, 0,
		122, 833, 1, 0, 0, 0, 124, 839, 1, 0, 0, 0, 126, 843, 1, 0, 0, 0, 128,
		847, 1, 0, 0, 0, 130, 849, 1, 0, 0, 0, 132, 865, 1, 0, 0, 0, 134, 868,
		1, 0, 0, 0, 136, 870, 1, 0, 0, 0, 138, 887, 1, 0, 0, 0, 140, 890, 1, 0,
		0, 0, 142, 901, 1, 0, 0, 0, 144, 903, 1, 0, 0, 0, 146, 905, 1, 0, 0, 0,
		148, 913, 1, 0, 0, 0, 150, 921, 1, 0, 0, 0, 152, 926, 1, 0, 0, 0, 154,
		928, 1, 0, 0, 0, 156, 944, 1, 0, 0, 0, 158, 959, 1, 0, 0, 0, 160, 961,
		1, 0, 0, 0, 162, 967, 1, 0, 0, 0, 164, 988, 1, 0, 0, 0, 166, 990, 1, 0,
		0, 0, 168, 1002, 1, 0, 0, 0, 170, 1006, 1, 0, 0, 0, 172, 1018, 1, 0, 0,
		0, 174, 1020, 1, 0, 0, 0, 176, 1034, 1, 0, 0, 0, 178, 1067, 1, 0, 0, 0,
		180, 1069, 1, 0, 0, 0, 182, 1073, 1, 0, 0, 0, 184, 1077, 1, 0, 0, 0, 186,
		1096, 1, 0, 0, 0, 188, 1132, 1, 0, 0, 0, 190, 1134, 1, 0, 0, 0, 192, 1145,
		1, 0, 0, 0, 194, 1153, 1, 0, 0, 0, 196, 1157, 1, 0, 0, 0, 198, 1165, 1,
		0, 0, 0, 200, 1176, 1, 0, 0, 0, 202, 1181, 1, 0, 0, 0, 204, 1193, 1, 0,
		0, 0, 206, 1197, 1, 0, 0, 0, 208, 1199, 1, 0, 0, 0, 210, 1208, 1, 0, 0,
		0, 212, 1220, 1, 0, 0, 0, 214, 1222, 1, 0, 0, 0, 216, 1224, 1, 0, 0, 0,
		218, 1228, 1, 0, 0, 0, 220, 1230, 1, 0, 0, 0, 222, 1234, 1, 0, 0, 0, 224,
		1244, 1, 0, 0, 0, 226, 1250, 1, 0, 0, 0, 228, 1252, 1, 0, 0, 0, 230, 1254,
		1, 0, 0, 0, 232, 1275, 1, 0, 0, 0, 234, 1400, 1, 0, 0, 0, 236, 1402, 1,
		0, 0, 0, 238, 1413, 1, 0, 0, 0, 240, 1422, 1, 0, 0, 0, 242, 1467, 1, 0,
		0, 0, 244, 1473, 1, 0, 0, 0, 246, 1477, 1, 0, 0, 0, 248, 1480, 1, 0, 0,
		0, 250, 1489, 1, 0, 0, 0, 252, 1515, 1, 0, 0, 0, 254, 1517, 1, 0, 0, 0,
		256, 1526, 1, 0, 0, 0, 258, 1536, 1, 0, 0, 0, 260, 1554, 1, 0, 0, 0, 262,
		1558, 1, 0, 0, 0, 264, 1560, 1, 0, 0, 0, 266, 1586, 1, 0, 0, 0, 268, 1594,
		1, 0, 0, 0, 270, 1596, 1, 0, 0, 0, 272, 1604, 1, 0, 0, 0, 274, 1613, 1,
		0, 0, 0, 276, 1615, 1, 0, 0, 0, 278, 1624, 1, 0, 0, 0, 280, 1634, 1, 0,
		0, 0, 282, 1646, 1, 0, 0, 0, 284, 1651, 1, 0, 0, 0, 286, 1653, 1, 0, 0,
		0, 288, 1655, 1, 0, 0, 0, 290, 1657, 1, 0, 0, 0, 292, 1659, 1, 0, 0, 0,
		294, 1661, 1, 0, 0, 0, 296, 1665, 1, 0, 0, 0, 298, 1670, 1, 0, 0, 0, 300,
		1674, 1, 0, 0, 0, 302, 304, 3, 298, 149, 0, 303, 305, 3, 6, 3, 0, 304,
		303, 1, 0, 0, 0, 304, 305, 1, 0, 0, 0, 305, 307, 1, 0, 0, 0, 306, 308,
		3, 300, 150, 0, 307, 306, 1, 0, 0, 0, 307, 308, 1, 0, 0, 0, 308, 310, 1,
		0, 0, 0, 309, 311, 3, 2, 1, 0, 310, 309, 1, 0, 0, 0, 310, 311, 1, 0, 0,
		0, 311, 312, 1, 0, 0, 0, 312, 313, 5, 0, 0, 1, 313, 1, 1, 0, 0, 0, 314,
		320, 3, 4, 2, 0, 315, 316, 3, 300, 150, 0, 316, 317, 3, 4, 2, 0, 317, 319,
		1, 0, 0, 0, 318, 315, 1, 0, 0, 0, 319, 322, 1, 0, 0, 0, 320, 318, 1, 0,
		0, 0, 320, 321, 1, 0, 0, 0, 321, 324, 1, 0, 0, 0, 322, 320, 1, 0, 0, 0,
		323, 325, 3, 300, 150, 0, 324, 323, 1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325,
		3, 1, 0, 0, 0, 326, 330, 3, 8, 4, 0, 327, 330, 3, 10, 5, 0, 328, 330, 3,
		188, 94, 0, 329, 326, 1, 0, 0, 0, 329, 327, 1, 0, 0, 0, 329, 328, 1, 0,
		0, 0, 330, 5, 1, 0, 0, 0, 331, 332, 3, 138, 69, 0, 332, 333, 5, 38, 0,
		0, 333, 334, 3, 102, 51, 0, 334, 7, 1, 0, 0, 0, 335, 336, 3, 138, 69, 0,
		336, 338, 5, 33, 0, 0, 337, 339, 5, 43, 0, 0, 338, 337, 1, 0, 0, 0, 338,
		339, 1, 0, 0, 0, 339, 340, 1, 0, 0, 0, 340, 345, 3, 102, 51, 0, 341, 342,
		5, 86, 0, 0, 342, 346, 5, 104, 0, 0, 343, 344, 5, 7, 0, 0, 344, 346, 3,
		290, 145, 0, 345, 341, 1, 0, 0, 0, 345, 343, 1, 0, 0, 0, 345, 346, 1, 0,
		0, 0, 346, 9, 1, 0, 0, 0, 347, 348, 3, 18, 9, 0, 348, 349, 3, 38, 19, 0,
		349, 11, 1, 0, 0, 0, 350, 353, 3, 22, 11, 0, 351, 353, 7, 0, 0, 0, 352,
		350, 1, 0, 0, 0, 352, 351, 1, 0, 0, 0, 353, 13, 1, 0, 0, 0, 354, 356, 3,
		16, 8, 0, 355, 354, 1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356, 15, 1, 0, 0,
		0, 357, 358, 3, 12, 6, 0, 358, 359, 3, 298, 149, 0, 359, 361, 1, 0, 0,
		0, 360, 357, 1, 0, 0, 0, 361, 362, 1, 0, 0, 0, 362, 360, 1, 0, 0, 0, 362,
		363, 1, 0, 0, 0, 363, 17, 1, 0, 0, 0, 364, 366, 3, 20, 10, 0, 365, 364,
		1, 0, 0, 0, 365, 366, 1, 0, 0, 0, 366, 19, 1, 0, 0, 0, 367, 368, 3, 22,
		11, 0, 368, 369, 3, 298, 149, 0, 369, 371, 1, 0, 0, 0, 370, 367, 1, 0,
		0, 0, 371, 372, 1, 0, 0, 0, 372, 370, 1, 0, 0, 0, 372, 373, 1, 0, 0, 0,
		373, 21, 1, 0, 0, 0, 374, 377, 3, 140, 70, 0, 375, 377, 7, 1, 0, 0, 376,
		374, 1, 0, 0, 0, 376, 375, 1, 0, 0, 0, 377, 23, 1, 0, 0, 0, 378, 381, 3,
		140, 70, 0, 379, 381, 7, 2, 0, 0, 380, 378, 1, 0, 0, 0, 380, 379, 1, 0,
		0, 0, 381, 25, 1, 0, 0, 0, 382, 384, 3, 28, 14, 0, 383, 382, 1, 0, 0, 0,
		383, 384, 1, 0, 0, 0, 384, 27, 1, 0, 0, 0, 385, 386, 3, 24, 12, 0, 386,
		387, 3, 298, 149, 0, 387, 389, 1, 0, 0, 0, 388, 385, 1, 0, 0, 0, 389, 390,
		1, 0, 0, 0, 390, 388, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 29, 1, 0,
		0, 0, 392, 393, 5, 89, 0, 0, 393, 394, 3, 298, 149, 0, 394, 401, 3, 32,
		16, 0, 395, 396, 5, 85, 0, 0, 396, 397, 3, 298, 149, 0, 397, 398, 3, 32,
		16, 0, 398, 400, 1, 0, 0, 0, 399, 395, 1, 0, 0, 0, 400, 403, 1, 0, 0, 0,
		401, 399, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402, 404, 1, 0, 0, 0, 403,
		401, 1, 0, 0, 0, 404, 405, 3, 298, 149, 0, 405, 406, 5, 88, 0, 0, 406,
		31, 1, 0, 0, 0, 407, 412, 3, 288, 144, 0, 408, 409, 5, 26, 0, 0, 409, 410,
		3, 298, 149, 0, 410, 411, 3, 34, 17, 0, 411, 413, 1, 0, 0, 0, 412, 408,
		1, 0, 0, 0, 412, 413, 1, 0, 0, 0, 413, 33, 1, 0, 0, 0, 414, 421, 3, 74,
		37, 0, 415, 416, 5, 106, 0, 0, 416, 417, 3, 298, 149, 0, 417, 418, 3, 74,
		37, 0, 418, 420, 1, 0, 0, 0, 419, 415, 1, 0, 0, 0, 420, 423, 1, 0, 0, 0,
		421, 419, 1, 0, 0, 0, 421, 422, 1, 0, 0, 0, 422, 35, 1, 0, 0, 0, 423, 421,
		1, 0, 0, 0, 424, 431, 3, 74, 37, 0, 425, 426, 5, 85, 0, 0, 426, 427, 3,
		298, 149, 0, 427, 428, 3, 74, 37, 0, 428, 430, 1, 0, 0, 0, 429, 425, 1,
		0, 0, 0, 430, 433, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 431, 432, 1, 0, 0,
		0, 432, 37, 1, 0, 0, 0, 433, 431, 1, 0, 0, 0, 434, 435, 5, 19, 0, 0, 435,
		446, 6, 19, -1, 0, 436, 437, 5, 35, 0, 0, 437, 446, 6, 19, -1, 0, 438,
		439, 5, 25, 0, 0, 439, 446, 6, 19, -1, 0, 440, 441, 5, 124, 0, 0, 441,
		442, 5, 35, 0, 0, 442, 446, 6, 19, -1, 0, 443, 444, 5, 10, 0, 0, 444, 446,
		6, 19, -1, 0, 445, 434, 1, 0, 0, 0, 445, 436, 1, 0, 0, 0, 445, 438, 1,
		0, 0, 0, 445, 440, 1, 0, 0, 0, 445, 443, 1, 0, 0, 0, 446, 447, 1, 0, 0,
		0, 447, 448, 3, 290, 145, 0, 448, 481, 3, 298, 149, 0, 449, 451, 4, 19,
		0, 1, 450, 452, 3, 30, 15, 0, 451, 450, 1, 0, 0, 0, 451, 452, 1, 0, 0,
		0, 452, 453, 1, 0, 0, 0, 453, 467, 3, 298, 149, 0, 454, 464, 4, 19, 1,
		1, 455, 456, 5, 26, 0, 0, 456, 460, 3, 298, 149, 0, 457, 458, 4, 19, 2,
		1, 458, 461, 3, 36, 18, 0, 459, 461, 3, 74, 37, 0, 460, 457, 1, 0, 0, 0,
		460, 459, 1, 0, 0, 0, 461, 462, 1, 0, 0, 0, 462, 463, 3, 298, 149, 0, 463,
		465, 1, 0, 0, 0, 464, 455, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 468,
		1, 0, 0, 0, 466, 468, 1, 0, 0, 0, 467, 454, 1, 0, 0, 0, 467, 466, 1, 0,
		0, 0, 468, 478, 1, 0, 0, 0, 469, 475, 4, 19, 3, 1, 470, 471, 5, 32, 0,
		0, 471, 472, 3, 298, 149, 0, 472, 473, 3, 36, 18, 0, 473, 474, 3, 298,
		149, 0, 474, 476, 1, 0, 0, 0, 475, 470, 1, 0, 0, 0, 475, 476, 1, 0, 0,
		0, 476, 479, 1, 0, 0, 0, 477, 479, 1, 0, 0, 0, 478, 469, 1, 0, 0, 0, 478,
		477, 1, 0, 0, 0, 479, 482, 1, 0, 0, 0, 480, 482, 1, 0, 0, 0, 481, 449,
		1, 0, 0, 0, 481, 480, 1, 0, 0, 0, 482, 483, 1, 0, 0, 0, 483, 484, 3, 40,
		20, 0, 484, 39, 1, 0, 0, 0, 485, 486, 5, 80, 0, 0, 486, 495, 3, 298, 149,
		0, 487, 489, 4, 20, 4, 1, 488, 490, 3, 42, 21, 0, 489, 488, 1, 0, 0, 0,
		489, 490, 1, 0, 0, 0, 490, 492, 1, 0, 0, 0, 491, 493, 3, 300, 150, 0, 492,
		491, 1, 0, 0, 0, 492, 493, 1, 0, 0, 0, 493, 496, 1, 0, 0, 0, 494, 496,
		1, 0, 0, 0, 495, 487, 1, 0, 0, 0, 495, 494, 1, 0, 0, 0, 496, 498, 1, 0,
		0, 0, 497, 499, 3, 46, 23, 0, 498, 497, 1, 0, 0, 0, 498, 499, 1, 0, 0,
		0, 499, 505, 1, 0, 0, 0, 500, 501, 3, 300, 150, 0, 501, 502, 3, 46, 23,
		0, 502, 504, 1, 0, 0, 0, 503, 500, 1, 0, 0, 0, 504, 507, 1, 0, 0, 0, 505,
		503, 1, 0, 0, 0, 505, 506, 1, 0, 0, 0, 506, 509, 1, 0, 0, 0, 507, 505,
		1, 0, 0, 0, 508, 510, 3, 300, 150, 0, 509, 508, 1, 0, 0, 0, 509, 510, 1,
		0, 0, 0, 510, 511, 1, 0, 0, 0, 511, 512, 5, 81, 0, 0, 512, 41, 1, 0, 0,
		0, 513, 521, 3, 44, 22, 0, 514, 515, 3, 298, 149, 0, 515, 516, 5, 85, 0,
		0, 516, 517, 3, 298, 149, 0, 517, 518, 3, 44, 22, 0, 518, 520, 1, 0, 0,
		0, 519, 514, 1, 0, 0, 0, 520, 523, 1, 0, 0, 0, 521, 519, 1, 0, 0, 0, 521,
		522, 1, 0, 0, 0, 522, 527, 1, 0, 0, 0, 523, 521, 1, 0, 0, 0, 524, 525,
		3, 298, 149, 0, 525, 526, 5, 85, 0, 0, 526, 528, 1, 0, 0, 0, 527, 524,
		1, 0, 0, 0, 527, 528, 1, 0, 0, 0, 528, 43, 1, 0, 0, 0, 529, 530, 3, 138,
		69, 0, 530, 532, 3, 290, 145, 0, 531, 533, 3, 276, 138, 0, 532, 531, 1,
		0, 0, 0, 532, 533, 1, 0, 0, 0, 533, 535, 1, 0, 0, 0, 534, 536, 3, 268,
		134, 0, 535, 534, 1, 0, 0, 0, 535, 536, 1, 0, 0, 0, 536, 45, 1, 0, 0, 0,
		537, 545, 5, 84, 0, 0, 538, 539, 5, 43, 0, 0, 539, 541, 3, 298, 149, 0,
		540, 538, 1, 0, 0, 0, 540, 541, 1, 0, 0, 0, 541, 542, 1, 0, 0, 0, 542,
		545, 3, 156, 78, 0, 543, 545, 3, 48, 24, 0, 544, 537, 1, 0, 0, 0, 544,
		540, 1, 0, 0, 0, 544, 543, 1, 0, 0, 0, 545, 47, 1, 0, 0, 0, 546, 552, 3,
		50, 25, 0, 547, 552, 3, 56, 28, 0, 548, 549, 3, 14, 7, 0, 549, 550, 3,
		38, 19, 0, 550, 552, 1, 0, 0, 0, 551, 546, 1, 0, 0, 0, 551, 547, 1, 0,
		0, 0, 551, 548, 1, 0, 0, 0, 552, 49, 1, 0, 0, 0, 553, 554, 4, 25, 5, 1,
		554, 555, 3, 54, 27, 0, 555, 556, 3, 52, 26, 0, 556, 557, 5, 78, 0, 0,
		557, 562, 3, 296, 148, 0, 558, 559, 5, 22, 0, 0, 559, 560, 3, 298, 149,
		0, 560, 561, 3, 152, 76, 0, 561, 563, 1, 0, 0, 0, 562, 558, 1, 0, 0, 0,
		562, 563, 1, 0, 0, 0, 563, 585, 1, 0, 0, 0, 564, 566, 3, 14, 7, 0, 565,
		567, 3, 30, 15, 0, 566, 565, 1, 0, 0, 0, 566, 567, 1, 0, 0, 0, 567, 569,
		1, 0, 0, 0, 568, 570, 3, 54, 27, 0, 569, 568, 1, 0, 0, 0, 569, 570, 1,
		0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 572, 3, 52, 26, 0, 572, 578, 3, 92,
		46, 0, 573, 574, 3, 298, 149, 0, 574, 575, 5, 50, 0, 0, 575, 576, 3, 298,
		149, 0, 576, 577, 3, 90, 45, 0, 577, 579, 1, 0, 0, 0, 578, 573, 1, 0, 0,
		0, 578, 579, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 582, 3, 298, 149, 0,
		581, 583, 3, 100, 50, 0, 582, 581, 1, 0, 0, 0, 582, 583, 1, 0, 0, 0, 583,
		585, 1, 0, 0, 0, 584, 553, 1, 0, 0, 0, 584, 564, 1, 0, 0, 0, 585, 51, 1,
		0, 0, 0, 586, 589, 3, 290, 145, 0, 587, 589, 3, 286, 143, 0, 588, 586,
		1, 0, 0, 0, 588, 587, 1, 0, 0, 0, 589, 53, 1, 0, 0, 0, 590, 594, 3, 72,
		36, 0, 591, 592, 4, 27, 6, 1, 592, 594, 5, 53, 0, 0, 593, 590, 1, 0, 0,
		0, 593, 591, 1, 0, 0, 0, 594, 55, 1, 0, 0, 0, 595, 596, 3, 164, 82, 0,
		596, 57, 1, 0, 0, 0, 597, 604, 3, 60, 30, 0, 598, 599, 5, 85, 0, 0, 599,
		600, 3, 298, 149, 0, 600, 601, 3, 60, 30, 0, 601, 603, 1, 0, 0, 0, 602,
		598, 1, 0, 0, 0, 603, 606, 1, 0, 0, 0, 604, 602, 1, 0, 0, 0, 604, 605,
		1, 0, 0, 0, 605, 59, 1, 0, 0, 0, 606, 604, 1, 0, 0, 0, 607, 613, 3, 62,
		31, 0, 608, 609, 3, 298, 149, 0, 609, 610, 5, 87, 0, 0, 610, 611, 3, 298,
		149, 0, 611, 612, 3, 64, 32, 0, 612, 614, 1, 0, 0, 0, 613, 608, 1, 0, 0,
		0, 613, 614, 1, 0, 0, 0, 614, 61, 1, 0, 0, 0, 615, 616, 3, 290, 145, 0,
		616, 63, 1, 0, 0, 0, 617, 618, 3, 226, 113, 0, 618, 65, 1, 0, 0, 0, 619,
		620, 3, 64, 32, 0, 620, 628, 3, 298, 149, 0, 621, 622, 5, 85, 0, 0, 622,
		623, 3, 298, 149, 0, 623, 624, 3, 64, 32, 0, 624, 625, 3, 298, 149, 0,
		625, 627, 1, 0, 0, 0, 626, 621, 1, 0, 0, 0, 627, 630, 1, 0, 0, 0, 628,
		626, 1, 0, 0, 0, 628, 629, 1, 0, 0, 0, 629, 631, 1, 0, 0, 0, 630, 628,
		1, 0, 0, 0, 631, 633, 3, 298, 149, 0, 632, 634, 5, 85, 0, 0, 633, 632,
		1, 0, 0, 0, 633, 634, 1, 0, 0, 0, 634, 67, 1, 0, 0, 0, 635, 636, 3, 138,
		69, 0, 636, 637, 5, 82, 0, 0, 637, 638, 5, 83, 0, 0, 638, 640, 1, 0, 0,
		0, 639, 635, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 639, 1, 0, 0, 0, 641,
		642, 1, 0, 0, 0, 642, 69, 1, 0, 0, 0, 643, 645, 3, 68, 34, 0, 644, 643,
		1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645, 71, 1, 0, 0, 0, 646, 649, 3, 138,
		69, 0, 647, 650, 3, 82, 41, 0, 648, 650, 3, 80, 40, 0, 649, 647, 1, 0,
		0, 0, 649, 648, 1, 0, 0, 0, 650, 651, 1, 0, 0, 0, 651, 652, 3, 70, 35,
		0, 652, 73, 1, 0, 0, 0, 653, 659, 3, 138, 69, 0, 654, 657, 3, 82, 41, 0,
		655, 657, 5, 53, 0, 0, 656, 654, 1, 0, 0, 0, 656, 655, 1, 0, 0, 0, 657,
		660, 1, 0, 0, 0, 658, 660, 3, 78, 39, 0, 659, 656, 1, 0, 0, 0, 659, 658,
		1, 0, 0, 0, 660, 661, 1, 0, 0, 0, 661, 662, 3, 70, 35, 0, 662, 75, 1, 0,
		0, 0, 663, 666, 3, 108, 54, 0, 664, 666, 3, 110, 55, 0, 665, 663, 1, 0,
		0, 0, 665, 664, 1, 0, 0, 0, 666, 668, 1, 0, 0, 0, 667, 669, 3, 84, 42,
		0, 668, 667, 1, 0, 0, 0, 668, 669, 1, 0, 0, 0, 669, 77, 1, 0, 0, 0, 670,
		672, 3, 108, 54, 0, 671, 673, 3, 84, 42, 0, 672, 671, 1, 0, 0, 0, 672,
		673, 1, 0, 0, 0, 673, 79, 1, 0, 0, 0, 674, 676, 3, 110, 55, 0, 675, 677,
		3, 84, 42, 0, 676, 675, 1, 0, 0, 0, 676, 677, 1, 0, 0, 0, 677, 81, 1, 0,
		0, 0, 678, 679, 5, 13, 0, 0, 679, 83, 1, 0, 0, 0, 680, 681, 5, 89, 0, 0,
		681, 682, 3, 298, 149, 0, 682, 689, 3, 86, 43, 0, 683, 684, 5, 85, 0, 0,
		684, 685, 3, 298, 149, 0, 685, 686, 3, 86, 43, 0, 686, 688, 1, 0, 0, 0,
		687, 683, 1, 0, 0, 0, 688, 691, 1, 0, 0, 0, 689, 687, 1, 0, 0, 0, 689,
		690, 1, 0, 0, 0, 690, 692, 1, 0, 0, 0, 691, 689, 1, 0, 0, 0, 692, 693,
		3, 298, 149, 0, 693, 694, 5, 88, 0, 0, 694, 85, 1, 0, 0, 0, 695, 705, 3,
		74, 37, 0, 696, 697, 3, 138, 69, 0, 697, 702, 5, 92, 0, 0, 698, 699, 7,
		3, 0, 0, 699, 700, 3, 298, 149, 0, 700, 701, 3, 74, 37, 0, 701, 703, 1,
		0, 0, 0, 702, 698, 1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 705, 1, 0, 0,
		0, 704, 695, 1, 0, 0, 0, 704, 696, 1, 0, 0, 0, 705, 87, 1, 0, 0, 0, 706,
		707, 3, 138, 69, 0, 707, 708, 3, 108, 54, 0, 708, 89, 1, 0, 0, 0, 709,
		716, 3, 88, 44, 0, 710, 711, 5, 85, 0, 0, 711, 712, 3, 298, 149, 0, 712,
		713, 3, 88, 44, 0, 713, 715, 1, 0, 0, 0, 714, 710, 1, 0, 0, 0, 715, 718,
		1, 0, 0, 0, 716, 714, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717, 91, 1, 0,
		0, 0, 718, 716, 1, 0, 0, 0, 719, 721, 5, 78, 0, 0, 720, 722, 3, 94, 47,
		0, 721, 720, 1, 0, 0, 0, 721, 722, 1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723,
		724, 3, 296, 148, 0, 724, 93, 1, 0, 0, 0, 725, 728, 3, 98, 49, 0, 726,
		728, 3, 96, 48, 0, 727, 725, 1, 0, 0, 0, 727, 726, 1, 0, 0, 0, 728, 735,
		1, 0, 0, 0, 729, 730, 5, 85, 0, 0, 730, 731, 3, 298, 149, 0, 731, 732,
		3, 98, 49, 0, 732, 734, 1, 0, 0, 0, 733, 729, 1, 0, 0, 0, 734, 737, 1,
		0, 0, 0, 735, 733, 1, 0, 0, 0, 735, 736, 1, 0, 0, 0, 736, 95, 1, 0, 0,
		0, 737, 735, 1, 0, 0, 0, 738, 739, 3, 74, 37, 0, 739, 740, 5, 48, 0, 0,
		740, 97, 1, 0, 0, 0, 741, 743, 3, 26, 13, 0, 742, 744, 3, 74, 37, 0, 743,
		742, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 746, 1, 0, 0, 0, 745, 747,
		5, 125, 0, 0, 746, 745, 1, 0, 0, 0, 746, 747, 1, 0, 0, 0, 747, 748, 1,
		0, 0, 0, 748, 754, 3, 62, 31, 0, 749, 750, 3, 298, 149, 0, 750, 751, 5,
		87, 0, 0, 751, 752, 3, 298, 149, 0, 752, 753, 3, 232, 116, 0, 753, 755,
		1, 0, 0, 0, 754, 749, 1, 0, 0, 0, 754, 755, 1, 0, 0, 0, 755, 99, 1, 0,
		0, 0, 756, 757, 3, 156, 78, 0, 757, 101, 1, 0, 0, 0, 758, 763, 3, 104,
		52, 0, 759, 760, 5, 86, 0, 0, 760, 762, 3, 104, 52, 0, 761, 759, 1, 0,
		0, 0, 762, 765, 1, 0, 0, 0, 763, 761, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0,
		764, 103, 1, 0, 0, 0, 765, 763, 1, 0, 0, 0, 766, 772, 3, 290, 145, 0, 767,
		772, 5, 8, 0, 0, 768, 772, 5, 9, 0, 0, 769, 772, 5, 7, 0, 0, 770, 772,
		5, 10, 0, 0, 771, 766, 1, 0, 0, 0, 771, 767, 1, 0, 0, 0, 771, 768, 1, 0,
		0, 0, 771, 769, 1, 0, 0, 0, 771, 770, 1, 0, 0, 0, 772, 105, 1, 0, 0, 0,
		773, 774, 3, 104, 52, 0, 774, 775, 5, 86, 0, 0, 775, 777, 1, 0, 0, 0, 776,
		773, 1, 0, 0, 0, 777, 780, 1, 0, 0, 0, 778, 776, 1, 0, 0, 0, 778, 779,
		1, 0, 0, 0, 779, 107, 1, 0, 0, 0, 780, 778, 1, 0, 0, 0, 781, 782, 3, 106,
		53, 0, 782, 783, 3, 290, 145, 0, 783, 109, 1, 0, 0, 0, 784, 785, 3, 106,
		53, 0, 785, 790, 3, 288, 144, 0, 786, 787, 5, 86, 0, 0, 787, 789, 3, 288,
		144, 0, 788, 786, 1, 0, 0, 0, 789, 792, 1, 0, 0, 0, 790, 788, 1, 0, 0,
		0, 790, 791, 1, 0, 0, 0, 791, 111, 1, 0, 0, 0, 792, 790, 1, 0, 0, 0, 793,
		799, 5, 56, 0, 0, 794, 799, 5, 57, 0, 0, 795, 799, 3, 286, 143, 0, 796,
		799, 5, 58, 0, 0, 797, 799, 5, 59, 0, 0, 798, 793, 1, 0, 0, 0, 798, 794,
		1, 0, 0, 0, 798, 795, 1, 0, 0, 0, 798, 796, 1, 0, 0, 0, 798, 797, 1, 0,
		0, 0, 799, 113, 1, 0, 0, 0, 800, 801, 5, 2, 0, 0, 801, 806, 3, 116, 58,
		0, 802, 803, 5, 4, 0, 0, 803, 805, 3, 116, 58, 0, 804, 802, 1, 0, 0, 0,
		805, 808, 1, 0, 0, 0, 806, 804, 1, 0, 0, 0, 806, 807, 1, 0, 0, 0, 807,
		809, 1, 0, 0, 0, 808, 806, 1, 0, 0, 0, 809, 810, 5, 3, 0, 0, 810, 115,
		1, 0, 0, 0, 811, 819, 3, 118, 59, 0, 812, 814, 5, 80, 0, 0, 813, 815, 3,
		228, 114, 0, 814, 813, 1, 0, 0, 0, 814, 815, 1, 0, 0, 0, 815, 816, 1, 0,
		0, 0, 816, 819, 5, 81, 0, 0, 817, 819, 3, 130, 65, 0, 818, 811, 1, 0, 0,
		0, 818, 812, 1, 0, 0, 0, 818, 817, 1, 0, 0, 0, 819, 117, 1, 0, 0, 0, 820,
		824, 3, 290, 145, 0, 821, 823, 5, 5, 0, 0, 822, 821, 1, 0, 0, 0, 823, 826,
		1, 0, 0, 0, 824, 822, 1, 0, 0, 0, 824, 825, 1, 0, 0, 0, 825, 119, 1, 0,
		0, 0, 826, 824, 1, 0, 0, 0, 827, 828, 3, 124, 62, 0, 828, 829, 3, 298,
		149, 0, 829, 830, 5, 75, 0, 0, 830, 831, 3, 298, 149, 0, 831, 832, 3, 128,
		64, 0, 832, 121, 1, 0, 0, 0, 833, 834, 3, 126, 63, 0, 834, 835, 3, 298,
		149, 0, 835, 836, 5, 75, 0, 0, 836, 837, 3, 298, 149, 0, 837, 838, 3, 128,
		64, 0, 838, 123, 1, 0, 0, 0, 839, 840, 3, 92, 46, 0, 840, 125, 1, 0, 0,
		0, 841, 844, 3, 92, 46, 0, 842, 844, 3, 62, 31, 0, 843, 841, 1, 0, 0, 0,
		843, 842, 1, 0, 0, 0, 844, 127, 1, 0, 0, 0, 845, 848, 3, 156, 78, 0, 846,
		848, 3, 228, 114, 0, 847, 845, 1, 0, 0, 0, 847, 846, 1, 0, 0, 0, 848, 129,
		1, 0, 0, 0, 849, 850, 5, 80, 0, 0, 850, 858, 3, 298, 149, 0, 851, 853,
		3, 94, 47, 0, 852, 851, 1, 0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 854, 1,
		0, 0, 0, 854, 855, 3, 298, 149, 0, 855, 856, 5, 75, 0, 0, 856, 857, 3,
		298, 149, 0, 857, 859, 1, 0, 0, 0, 858, 852, 1, 0, 0, 0, 858, 859, 1, 0,
		0, 0, 859, 860, 1, 0, 0, 0, 860, 861, 3, 134, 67, 0, 861, 862, 5, 81, 0,
		0, 862, 131, 1, 0, 0, 0, 863, 866, 3, 130, 65, 0, 864, 866, 3, 120, 60,
		0, 865, 863, 1, 0, 0, 0, 865, 864, 1, 0, 0, 0, 866, 133, 1, 0, 0, 0, 867,
		869, 3, 136, 68, 0, 868, 867, 1, 0, 0, 0, 868, 869, 1, 0, 0, 0, 869, 135,
		1, 0, 0, 0, 870, 876, 3, 158, 79, 0, 871, 872, 3, 300, 150, 0, 872, 873,
		3, 158, 79, 0, 873, 875, 1, 0, 0, 0, 874, 871, 1, 0, 0, 0, 875, 878, 1,
		0, 0, 0, 876, 874, 1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877, 880, 1, 0, 0,
		0, 878, 876, 1, 0, 0, 0, 879, 881, 3, 300, 150, 0, 880, 879, 1, 0, 0, 0,
		880, 881, 1, 0, 0, 0, 881, 137, 1, 0, 0, 0, 882, 883, 3, 140, 70, 0, 883,
		884, 3, 298, 149, 0, 884, 886, 1, 0, 0, 0, 885, 882, 1, 0, 0, 0, 886, 889,
		1, 0, 0, 0, 887, 885, 1, 0, 0, 0, 887, 888, 1, 0, 0, 0, 888, 139, 1, 0,
		0, 0, 889, 887, 1, 0, 0, 0, 890, 891, 5, 124, 0, 0, 891, 897, 3, 144, 72,
		0, 892, 894, 5, 78, 0, 0, 893, 895, 3, 142, 71, 0, 894, 893, 1, 0, 0, 0,
		894, 895, 1, 0, 0, 0, 895, 896, 1, 0, 0, 0, 896, 898, 3, 296, 148, 0, 897,
		892, 1, 0, 0, 0, 897, 898, 1, 0, 0, 0, 898, 141, 1, 0, 0, 0, 899, 902,
		3, 146, 73, 0, 900, 902, 3, 152, 76, 0, 901, 899, 1, 0, 0, 0, 901, 900,
		1, 0, 0, 0, 902, 143, 1, 0, 0, 0, 903, 904, 3, 108, 54, 0, 904, 145, 1,
		0, 0, 0, 905, 910, 3, 148, 74, 0, 906, 907, 5, 85, 0, 0, 907, 909, 3, 148,
		74, 0, 908, 906, 1, 0, 0, 0, 909, 912, 1, 0, 0, 0, 910, 908, 1, 0, 0, 0,
		910, 911, 1, 0, 0, 0, 911, 147, 1, 0, 0, 0, 912, 910, 1, 0, 0, 0, 913,
		914, 3, 150, 75, 0, 914, 915, 3, 298, 149, 0, 915, 916, 5, 87, 0, 0, 916,
		917, 3, 298, 149, 0, 917, 918, 3, 152, 76, 0, 918, 149, 1, 0, 0, 0, 919,
		922, 3, 290, 145, 0, 920, 922, 3, 294, 147, 0, 921, 919, 1, 0, 0, 0, 921,
		920, 1, 0, 0, 0, 922, 151, 1, 0, 0, 0, 923, 927, 3, 154, 77, 0, 924, 927,
		3, 140, 70, 0, 925, 927, 3, 232, 116, 0, 926, 923, 1, 0, 0, 0, 926, 924,
		1, 0, 0, 0, 926, 925, 1, 0, 0, 0, 927, 153, 1, 0, 0, 0, 928, 937, 5, 82,
		0, 0, 929, 934, 3, 152, 76, 0, 930, 931, 5, 85, 0, 0, 931, 933, 3, 152,
		76, 0, 932, 930, 1, 0, 0, 0, 933, 936, 1, 0, 0, 0, 934, 932, 1, 0, 0, 0,
		934, 935, 1, 0, 0, 0, 935, 938, 1, 0, 0, 0, 936, 934, 1, 0, 0, 0, 937,
		929, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 940, 1, 0, 0, 0, 939, 941,
		5, 85, 0, 0, 940, 939, 1, 0, 0, 0, 940, 941, 1, 0, 0, 0, 941, 942, 1, 0,
		0, 0, 942, 943, 5, 83, 0, 0, 943, 155, 1, 0, 0, 0, 944, 952, 5, 80, 0,
		0, 945, 953, 3, 298, 149, 0, 946, 948, 3, 300, 150, 0, 947, 946, 1, 0,
		0, 0, 948, 951, 1, 0, 0, 0, 949, 947, 1, 0, 0, 0, 949, 950, 1, 0, 0, 0,
		950, 953, 1, 0, 0, 0, 951, 949, 1, 0, 0, 0, 952, 945, 1, 0, 0, 0, 952,
		949, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954, 955, 3, 134, 67, 0, 955, 956,
		5, 81, 0, 0, 956, 157, 1, 0, 0, 0, 957, 960, 3, 160, 80, 0, 958, 960, 3,
		188, 94, 0, 959, 957, 1, 0, 0, 0, 959, 958, 1, 0, 0, 0, 960, 159, 1, 0,
		0, 0, 961, 962, 3, 164, 82, 0, 962, 161, 1, 0, 0, 0, 963, 964, 4, 81, 7,
		1, 964, 968, 3, 28, 14, 0, 965, 966, 4, 81, 8, 1, 966, 968, 3, 16, 8, 0,
		967, 963, 1, 0, 0, 0, 967, 965, 1, 0, 0, 0, 968, 163, 1, 0, 0, 0, 969,
		980, 3, 162, 81, 0, 970, 972, 3, 74, 37, 0, 971, 970, 1, 0, 0, 0, 971,
		972, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0, 973, 981, 3, 58, 29, 0, 974, 975,
		3, 166, 83, 0, 975, 976, 3, 298, 149, 0, 976, 977, 5, 87, 0, 0, 977, 978,
		3, 298, 149, 0, 978, 979, 3, 64, 32, 0, 979, 981, 1, 0, 0, 0, 980, 971,
		1, 0, 0, 0, 980, 974, 1, 0, 0, 0, 981, 989, 1, 0, 0, 0, 982, 984, 3, 162,
		81, 0, 983, 982, 1, 0, 0, 0, 983, 984, 1, 0, 0, 0, 984, 985, 1, 0, 0, 0,
		985, 986, 3, 74, 37, 0, 986, 987, 3, 58, 29, 0, 987, 989, 1, 0, 0, 0, 988,
		969, 1, 0, 0, 0, 988, 983, 1, 0, 0, 0, 989, 165, 1, 0, 0, 0, 990, 991,
		5, 78, 0, 0, 991, 996, 3, 168, 84, 0, 992, 993, 5, 85, 0, 0, 993, 995,
		3, 168, 84, 0, 994, 992, 1, 0, 0, 0, 995, 998, 1, 0, 0, 0, 996, 994, 1,
		0, 0, 0, 996, 997, 1, 0, 0, 0, 997, 999, 1, 0, 0, 0, 998, 996, 1, 0, 0,
		0, 999, 1000, 3, 296, 148, 0, 1000, 167, 1, 0, 0, 0, 1001, 1003, 3, 74,
		37, 0, 1002, 1001, 1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003, 1004, 1, 0,
		0, 0, 1004, 1005, 3, 62, 31, 0, 1005, 169, 1, 0, 0, 0, 1006, 1007, 5, 78,
		0, 0, 1007, 1010, 3, 62, 31, 0, 1008, 1009, 5, 85, 0, 0, 1009, 1011, 3,
		62, 31, 0, 1010, 1008, 1, 0, 0, 0, 1011, 1012, 1, 0, 0, 0, 1012, 1010,
		1, 0, 0, 0, 1012, 1013, 1, 0, 0, 0, 1013, 1014, 1, 0, 0, 0, 1014, 1015,
		3, 296, 148, 0, 1015, 171, 1, 0, 0, 0, 1016, 1019, 3, 174, 87, 0, 1017,
		1019, 3, 176, 88, 0, 1018, 1016, 1, 0, 0, 0, 1018, 1017, 1, 0, 0, 0, 1019,
		173, 1, 0, 0, 0, 1020, 1021, 5, 30, 0, 0, 1021, 1022, 3, 220, 110, 0, 1022,
		1023, 3, 298, 149, 0, 1023, 1032, 3, 188, 94, 0, 1024, 1027, 3, 298, 149,
		0, 1025, 1027, 3, 300, 150, 0, 1026, 1024, 1, 0, 0, 0, 1026, 1025, 1, 0,
		0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 1029, 5, 24, 0, 0, 1029, 1030, 3, 298,
		149, 0, 1030, 1031, 3, 188, 94, 0, 1031, 1033, 1, 0, 0, 0, 1032, 1026,
		1, 0, 0, 0, 1032, 1033, 1, 0, 0, 0, 1033, 175, 1, 0, 0, 0, 1034, 1035,
		5, 46, 0, 0, 1035, 1036, 3, 220, 110, 0, 1036, 1037, 3, 298, 149, 0, 1037,
		1038, 5, 80, 0, 0, 1038, 1042, 3, 298, 149, 0, 1039, 1041, 3, 202, 101,
		0, 1040, 1039, 1, 0, 0, 0, 1041, 1044, 1, 0, 0, 0, 1042, 1040, 1, 0, 0,
		0, 1042, 1043, 1, 0, 0, 0, 1043, 1045, 1, 0, 0, 0, 1044, 1042, 1, 0, 0,
		0, 1045, 1046, 3, 298, 149, 0, 1046, 1047, 5, 81, 0, 0, 1047, 177, 1, 0,
		0, 0, 1048, 1049, 5, 29, 0, 0, 1049, 1050, 5, 78, 0, 0, 1050, 1051, 3,
		206, 103, 0, 1051, 1052, 3, 296, 148, 0, 1052, 1053, 3, 298, 149, 0, 1053,
		1054, 3, 188, 94, 0, 1054, 1068, 1, 0, 0, 0, 1055, 1056, 5, 55, 0, 0, 1056,
		1057, 3, 220, 110, 0, 1057, 1058, 3, 298, 149, 0, 1058, 1059, 3, 188, 94,
		0, 1059, 1068, 1, 0, 0, 0, 1060, 1061, 5, 23, 0, 0, 1061, 1062, 3, 298,
		149, 0, 1062, 1063, 3, 188, 94, 0, 1063, 1064, 3, 298, 149, 0, 1064, 1065,
		5, 55, 0, 0, 1065, 1066, 3, 220, 110, 0, 1066, 1068, 1, 0, 0, 0, 1067,
		1048, 1, 0, 0, 0, 1067, 1055, 1, 0, 0, 0, 1067, 1060, 1, 0, 0, 0, 1068,
		179, 1, 0, 0, 0, 1069, 1071, 5, 21, 0, 0, 1070, 1072, 3, 290, 145, 0, 1071,
		1070, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 181, 1, 0, 0, 0, 1073,
		1075, 5, 16, 0, 0, 1074, 1076, 3, 290, 145, 0, 1075, 1074, 1, 0, 0, 0,
		1075, 1076, 1, 0, 0, 0, 1076, 183, 1, 0, 0, 0, 1077, 1079, 5, 52, 0, 0,
		1078, 1080, 3, 196, 98, 0, 1079, 1078, 1, 0, 0, 0, 1079, 1080, 1, 0, 0,
		0, 1080, 1081, 1, 0, 0, 0, 1081, 1082, 3, 298, 149, 0, 1082, 1088, 3, 156,
		78, 0, 1083, 1084, 3, 298, 149, 0, 1084, 1085, 3, 190, 95, 0, 1085, 1087,
		1, 0, 0, 0, 1086, 1083, 1, 0, 0, 0, 1087, 1090, 1, 0, 0, 0, 1088, 1086,
		1, 0, 0, 0, 1088, 1089, 1, 0, 0, 0, 1089, 1094, 1, 0, 0, 0, 1090, 1088,
		1, 0, 0, 0, 1091, 1092, 3, 298, 149, 0, 1092, 1093, 3, 194, 97, 0, 1093,
		1095, 1, 0, 0, 0, 1094, 1091, 1, 0, 0, 0, 1094, 1095, 1, 0, 0, 0, 1095,
		185, 1, 0, 0, 0, 1096, 1097, 5, 15, 0, 0, 1097, 1103, 3, 232, 116, 0, 1098,
		1099, 3, 298, 149, 0, 1099, 1100, 7, 4, 0, 0, 1100, 1101, 3, 298, 149,
		0, 1101, 1102, 3, 232, 116, 0, 1102, 1104, 1, 0, 0, 0, 1103, 1098, 1, 0,
		0, 0, 1103, 1104, 1, 0, 0, 0, 1104, 187, 1, 0, 0, 0, 1105, 1133, 3, 156,
		78, 0, 1106, 1133, 3, 172, 86, 0, 1107, 1133, 3, 178, 89, 0, 1108, 1133,
		3, 184, 92, 0, 1109, 1110, 5, 47, 0, 0, 1110, 1111, 3, 220, 110, 0, 1111,
		1112, 3, 298, 149, 0, 1112, 1113, 3, 156, 78, 0, 1113, 1133, 1, 0, 0, 0,
		1114, 1116, 5, 42, 0, 0, 1115, 1117, 3, 232, 116, 0, 1116, 1115, 1, 0,
		0, 0, 1116, 1117, 1, 0, 0, 0, 1117, 1133, 1, 0, 0, 0, 1118, 1119, 5, 49,
		0, 0, 1119, 1133, 3, 232, 116, 0, 1120, 1133, 3, 182, 91, 0, 1121, 1133,
		3, 180, 90, 0, 1122, 1123, 3, 290, 145, 0, 1123, 1124, 5, 93, 0, 0, 1124,
		1125, 3, 298, 149, 0, 1125, 1126, 3, 188, 94, 0, 1126, 1133, 1, 0, 0, 0,
		1127, 1133, 3, 186, 93, 0, 1128, 1133, 3, 160, 80, 0, 1129, 1133, 3, 50,
		25, 0, 1130, 1133, 3, 228, 114, 0, 1131, 1133, 5, 84, 0, 0, 1132, 1105,
		1, 0, 0, 0, 1132, 1106, 1, 0, 0, 0, 1132, 1107, 1, 0, 0, 0, 1132, 1108,
		1, 0, 0, 0, 1132, 1109, 1, 0, 0, 0, 1132, 1114, 1, 0, 0, 0, 1132, 1118,
		1, 0, 0, 0, 1132, 1120, 1, 0, 0, 0, 1132, 1121, 1, 0, 0, 0, 1132, 1122,
		1, 0, 0, 0, 1132, 1127, 1, 0, 0, 0, 1132, 1128, 1, 0, 0, 0, 1132, 1129,
		1, 0, 0, 0, 1132, 1130, 1, 0, 0, 0, 1132, 1131, 1, 0, 0, 0, 1133, 189,
		1, 0, 0, 0, 1134, 1135, 5, 18, 0, 0, 1135, 1136, 5, 78, 0, 0, 1136, 1138,
		3, 26, 13, 0, 1137, 1139, 3, 192, 96, 0, 1138, 1137, 1, 0, 0, 0, 1138,
		1139, 1, 0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140, 1141, 3, 290, 145, 0, 1141,
		1142, 3, 296, 148, 0, 1142, 1143, 3, 298, 149, 0, 1143, 1144, 3, 156, 78,
		0, 1144, 191, 1, 0, 0, 0, 1145, 1150, 3, 108, 54, 0, 1146, 1147, 5, 107,
		0, 0, 1147, 1149, 3, 108, 54, 0, 1148, 1146, 1, 0, 0, 0, 1149, 1152, 1,
		0, 0, 0, 1150, 1148, 1, 0, 0, 0, 1150, 1151, 1, 0, 0, 0, 1151, 193, 1,
		0, 0, 0, 1152, 1150, 1, 0, 0, 0, 1153, 1154, 5, 28, 0, 0, 1154, 1155, 3,
		298, 149, 0, 1155, 1156, 3, 156, 78, 0, 1156, 195, 1, 0, 0, 0, 1157, 1158,
		5, 78, 0, 0, 1158, 1159, 3, 298, 149, 0, 1159, 1161, 3, 198, 99, 0, 1160,
		1162, 3, 300, 150, 0, 1161, 1160, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162,
		1163, 1, 0, 0, 0, 1163, 1164, 3, 296, 148, 0, 1164, 197, 1, 0, 0, 0, 1165,
		1171, 3, 200, 100, 0, 1166, 1167, 3, 300, 150, 0, 1167, 1168, 3, 200, 100,
		0, 1168, 1170, 1, 0, 0, 0, 1169, 1166, 1, 0, 0, 0, 1170, 1173, 1, 0, 0,
		0, 1171, 1169, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 199, 1, 0, 0,
		0, 1173, 1171, 1, 0, 0, 0, 1174, 1177, 3, 160, 80, 0, 1175, 1177, 3, 232,
		116, 0, 1176, 1174, 1, 0, 0, 0, 1176, 1175, 1, 0, 0, 0, 1177, 201, 1, 0,
		0, 0, 1178, 1179, 3, 204, 102, 0, 1179, 1180, 3, 298, 149, 0, 1180, 1182,
		1, 0, 0, 0, 1181, 1178, 1, 0, 0, 0, 1182, 1183, 1, 0, 0, 0, 1183, 1181,
		1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184, 1185, 1, 0, 0, 0, 1185, 1186,
		3, 136, 68, 0, 1186, 203, 1, 0, 0, 0, 1187, 1188, 5, 17, 0, 0, 1188, 1189,
		3, 232, 116, 0, 1189, 1190, 5, 93, 0, 0, 1190, 1194, 1, 0, 0, 0, 1191,
		1192, 5, 22, 0, 0, 1192, 1194, 5, 93, 0, 0, 1193, 1187, 1, 0, 0, 0, 1193,
		1191, 1, 0, 0, 0, 1194, 205, 1, 0, 0, 0, 1195, 1198, 3, 208, 104, 0, 1196,
		1198, 3, 210, 105, 0, 1197, 1195, 1, 0, 0, 0, 1197, 1196, 1, 0, 0, 0, 1198,
		207, 1, 0, 0, 0, 1199, 1201, 3, 26, 13, 0, 1200, 1202, 3, 74, 37, 0, 1201,
		1200, 1, 0, 0, 0, 1201, 1202, 1, 0, 0, 0, 1202, 1203, 1, 0, 0, 0, 1203,
		1204, 3, 62, 31, 0, 1204, 1205, 7, 5, 0, 0, 1205, 1206, 3, 232, 116, 0,
		1206, 209, 1, 0, 0, 0, 1207, 1209, 3, 212, 106, 0, 1208, 1207, 1, 0, 0,
		0, 1208, 1209, 1, 0, 0, 0, 1209, 1210, 1, 0, 0, 0, 1210, 1212, 5, 84, 0,
		0, 1211, 1213, 3, 232, 116, 0, 1212, 1211, 1, 0, 0, 0, 1212, 1213, 1, 0,
		0, 0, 1213, 1214, 1, 0, 0, 0, 1214, 1216, 5, 84, 0, 0, 1215, 1217, 3, 214,
		107, 0, 1216, 1215, 1, 0, 0, 0, 1216, 1217, 1, 0, 0, 0, 1217, 211, 1, 0,
		0, 0, 1218, 1221, 3, 160, 80, 0, 1219, 1221, 3, 222, 111, 0, 1220, 1218,
		1, 0, 0, 0, 1220, 1219, 1, 0, 0, 0, 1221, 213, 1, 0, 0, 0, 1222, 1223,
		3, 222, 111, 0, 1223, 215, 1, 0, 0, 0, 1224, 1225, 5, 78, 0, 0, 1225, 1226,
		3, 74, 37, 0, 1226, 1227, 3, 296, 148, 0, 1227, 217, 1, 0, 0, 0, 1228,
		1229, 3, 220, 110, 0, 1229, 219, 1, 0, 0, 0, 1230, 1231, 5, 78, 0, 0, 1231,
		1232, 3, 226, 113, 0, 1232, 1233, 3, 296, 148, 0, 1233, 221, 1, 0, 0, 0,
		1234, 1239, 3, 224, 112, 0, 1235, 1236, 5, 85, 0, 0, 1236, 1238, 3, 224,
		112, 0, 1237, 1235, 1, 0, 0, 0, 1238, 1241, 1, 0, 0, 0, 1239, 1237, 1,
		0, 0, 0, 1239, 1240, 1, 0, 0, 0, 1240, 223, 1, 0, 0, 0, 1241, 1239, 1,
		0, 0, 0, 1242, 1245, 5, 104, 0, 0, 1243, 1245, 1, 0, 0, 0, 1244, 1242,
		1, 0, 0, 0, 1244, 1243, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 1247,
		3, 232, 116, 0, 1247, 225, 1, 0, 0, 0, 1248, 1251, 3, 228, 114, 0, 1249,
		1251, 3, 122, 61, 0, 1250, 1248, 1, 0, 0, 0, 1250, 1249, 1, 0, 0, 0, 1251,
		227, 1, 0, 0, 0, 1252, 1253, 3, 236, 118, 0, 1253, 229, 1, 0, 0, 0, 1254,
		1256, 3, 240, 120, 0, 1255, 1257, 7, 6, 0, 0, 1256, 1255, 1, 0, 0, 0, 1256,
		1257, 1, 0, 0, 0, 1257, 231, 1, 0, 0, 0, 1258, 1259, 6, 116, -1, 0, 1259,
		1260, 3, 216, 108, 0, 1260, 1261, 3, 234, 117, 0, 1261, 1276, 1, 0, 0,
		0, 1262, 1276, 3, 230, 115, 0, 1263, 1264, 7, 7, 0, 0, 1264, 1265, 3, 298,
		149, 0, 1265, 1266, 3, 232, 116, 18, 1266, 1276, 1, 0, 0, 0, 1267, 1268,
		7, 8, 0, 0, 1268, 1276, 3, 232, 116, 16, 1269, 1270, 3, 170, 85, 0, 1270,
		1271, 3, 298, 149, 0, 1271, 1272, 5, 87, 0, 0, 1272, 1273, 3, 298, 149,
		0, 1273, 1274, 3, 228, 114, 0, 1274, 1276, 1, 0, 0, 0, 1275, 1258, 1, 0,
		0, 0, 1275, 1262, 1, 0, 0, 0, 1275, 1263, 1, 0, 0, 0, 1275, 1267, 1, 0,
		0, 0, 1275, 1269, 1, 0, 0, 0, 1276, 1387, 1, 0, 0, 0, 1277, 1278, 10, 17,
		0, 0, 1278, 1279, 5, 70, 0, 0, 1279, 1280, 3, 298, 149, 0, 1280, 1281,
		3, 232, 116, 18, 1281, 1386, 1, 0, 0, 0, 1282, 1283, 10, 15, 0, 0, 1283,
		1284, 3, 298, 149, 0, 1284, 1285, 7, 9, 0, 0, 1285, 1286, 3, 298, 149,
		0, 1286, 1287, 3, 232, 116, 16, 1287, 1386, 1, 0, 0, 0, 1288, 1289, 10,
		14, 0, 0, 1289, 1290, 7, 10, 0, 0, 1290, 1291, 3, 298, 149, 0, 1291, 1292,
		3, 232, 116, 15, 1292, 1386, 1, 0, 0, 0, 1293, 1294, 10, 13, 0, 0, 1294,
		1305, 3, 298, 149, 0, 1295, 1296, 5, 89, 0, 0, 1296, 1303, 5, 89, 0, 0,
		1297, 1298, 5, 88, 0, 0, 1298, 1299, 5, 88, 0, 0, 1299, 1303, 5, 88, 0,
		0, 1300, 1301, 5, 88, 0, 0, 1301, 1303, 5, 88, 0, 0, 1302, 1295, 1, 0,
		0, 0, 1302, 1297, 1, 0, 0, 0, 1302, 1300, 1, 0, 0, 0, 1303, 1306, 1, 0,
		0, 0, 1304, 1306, 7, 11, 0, 0, 1305, 1302, 1, 0, 0, 0, 1305, 1304, 1, 0,
		0, 0, 1306, 1307, 1, 0, 0, 0, 1307, 1308, 3, 298, 149, 0, 1308, 1309, 3,
		232, 116, 14, 1309, 1386, 1, 0, 0, 0, 1310, 1311, 10, 11, 0, 0, 1311, 1312,
		3, 298, 149, 0, 1312, 1313, 7, 12, 0, 0, 1313, 1314, 3, 298, 149, 0, 1314,
		1315, 3, 232, 116, 12, 1315, 1386, 1, 0, 0, 0, 1316, 1317, 10, 10, 0, 0,
		1317, 1318, 3, 298, 149, 0, 1318, 1319, 7, 13, 0, 0, 1319, 1320, 3, 298,
		149, 0, 1320, 1321, 3, 232, 116, 11, 1321, 1386, 1, 0, 0, 0, 1322, 1323,
		10, 9, 0, 0, 1323, 1324, 3, 298, 149, 0, 1324, 1325, 7, 14, 0, 0, 1325,
		1326, 3, 298, 149, 0, 1326, 1327, 3, 232, 116, 10, 1327, 1386, 1, 0, 0,
		0, 1328, 1329, 10, 8, 0, 0, 1329, 1330, 3, 298, 149, 0, 1330, 1331, 5,
		106, 0, 0, 1331, 1332, 3, 298, 149, 0, 1332, 1333, 3, 232, 116, 9, 1333,
		1386, 1, 0, 0, 0, 1334, 1335, 10, 7, 0, 0, 1335, 1336, 3, 298, 149, 0,
		1336, 1337, 5, 108, 0, 0, 1337, 1338, 3, 298, 149, 0, 1338, 1339, 3, 232,
		116, 8, 1339, 1386, 1, 0, 0, 0, 1340, 1341, 10, 6, 0, 0, 1341, 1342, 3,
		298, 149, 0, 1342, 1343, 5, 107, 0, 0, 1343, 1344, 3, 298, 149, 0, 1344,
		1345, 3, 232, 116, 7, 1345, 1386, 1, 0, 0, 0, 1346, 1347, 10, 5, 0, 0,
		1347, 1348, 3, 298, 149, 0, 1348, 1349, 5, 98, 0, 0, 1349, 1350, 3, 298,
		149, 0, 1350, 1351, 3, 232, 116, 6, 1351, 1386, 1, 0, 0, 0, 1352, 1353,
		10, 4, 0, 0, 1353, 1354, 3, 298, 149, 0, 1354, 1355, 5, 99, 0, 0, 1355,
		1356, 3, 298, 149, 0, 1356, 1357, 3, 232, 116, 5, 1357, 1386, 1, 0, 0,
		0, 1358, 1359, 10, 3, 0, 0, 1359, 1369, 3, 298, 149, 0, 1360, 1361, 5,
		92, 0, 0, 1361, 1362, 3, 298, 149, 0, 1362, 1363, 3, 232, 116, 0, 1363,
		1364, 3, 298, 149, 0, 1364, 1365, 5, 93, 0, 0, 1365, 1366, 3, 298, 149,
		0, 1366, 1370, 1, 0, 0, 0, 1367, 1368, 5, 65, 0, 0, 1368, 1370, 3, 298,
		149, 0, 1369, 1360, 1, 0, 0, 0, 1369, 1367, 1, 0, 0, 0, 1370, 1371, 1,
		0, 0, 0, 1371, 1372, 3, 232, 116, 3, 1372, 1386, 1, 0, 0, 0, 1373, 1374,
		10, 12, 0, 0, 1374, 1375, 3, 298, 149, 0, 1375, 1376, 7, 15, 0, 0, 1376,
		1377, 3, 298, 149, 0, 1377, 1378, 3, 74, 37, 0, 1378, 1386, 1, 0, 0, 0,
		1379, 1380, 10, 1, 0, 0, 1380, 1381, 3, 298, 149, 0, 1381, 1382, 7, 16,
		0, 0, 1382, 1383, 3, 298, 149, 0, 1383, 1384, 3, 226, 113, 0, 1384, 1386,
		1, 0, 0, 0, 1385, 1277, 1, 0, 0, 0, 1385, 1282, 1, 0, 0, 0, 1385, 1288,
		1, 0, 0, 0, 1385, 1293, 1, 0, 0, 0, 1385, 1310, 1, 0, 0, 0, 1385, 1316,
		1, 0, 0, 0, 1385, 1322, 1, 0, 0, 0, 1385, 1328, 1, 0, 0, 0, 1385, 1334,
		1, 0, 0, 0, 1385, 1340, 1, 0, 0, 0, 1385, 1346, 1, 0, 0, 0, 1385, 1352,
		1, 0, 0, 0, 1385, 1358, 1, 0, 0, 0, 1385, 1373, 1, 0, 0, 0, 1385, 1379,
		1, 0, 0, 0, 1386, 1389, 1, 0, 0, 0, 1387, 1385, 1, 0, 0, 0, 1387, 1388,
		1, 0, 0, 0, 1388, 233, 1, 0, 0, 0, 1389, 1387, 1, 0, 0, 0, 1390, 1391,
		3, 216, 108, 0, 1391, 1392, 3, 234, 117, 0, 1392, 1401, 1, 0, 0, 0, 1393,
		1401, 3, 230, 115, 0, 1394, 1395, 7, 7, 0, 0, 1395, 1396, 3, 298, 149,
		0, 1396, 1397, 3, 234, 117, 0, 1397, 1401, 1, 0, 0, 0, 1398, 1399, 7, 8,
		0, 0, 1399, 1401, 3, 234, 117, 0, 1400, 1390, 1, 0, 0, 0, 1400, 1393, 1,
		0, 0, 0, 1400, 1394, 1, 0, 0, 0, 1400, 1398, 1, 0, 0, 0, 1401, 235, 1,
		0, 0, 0, 1402, 1405, 3, 232, 116, 0, 1403, 1406, 3, 278, 139, 0, 1404,
		1406, 1, 0, 0, 0, 1405, 1403, 1, 0, 0, 0, 1405, 1404, 1, 0, 0, 0, 1406,
		1410, 1, 0, 0, 0, 1407, 1409, 3, 238, 119, 0, 1408, 1407, 1, 0, 0, 0, 1409,
		1412, 1, 0, 0, 0, 1410, 1408, 1, 0, 0, 0, 1410, 1411, 1, 0, 0, 0, 1411,
		237, 1, 0, 0, 0, 1412, 1410, 1, 0, 0, 0, 1413, 1420, 3, 252, 126, 0, 1414,
		1416, 3, 242, 121, 0, 1415, 1414, 1, 0, 0, 0, 1416, 1417, 1, 0, 0, 0, 1417,
		1415, 1, 0, 0, 0, 1417, 1418, 1, 0, 0, 0, 1418, 1421, 1, 0, 0, 0, 1419,
		1421, 3, 278, 139, 0, 1420, 1415, 1, 0, 0, 0, 1420, 1419, 1, 0, 0, 0, 1420,
		1421, 1, 0, 0, 0, 1421, 239, 1, 0, 0, 0, 1422, 1428, 3, 252, 126, 0, 1423,
		1424, 3, 242, 121, 0, 1424, 1425, 6, 120, -1, 0, 1425, 1427, 1, 0, 0, 0,
		1426, 1423, 1, 0, 0, 0, 1427, 1430, 1, 0, 0, 0, 1428, 1426, 1, 0, 0, 0,
		1428, 1429, 1, 0, 0, 0, 1429, 241, 1, 0, 0, 0, 1430, 1428, 1, 0, 0, 0,
		1431, 1442, 3, 298, 149, 0, 1432, 1433, 7, 17, 0, 0, 1433, 1436, 3, 298,
		149, 0, 1434, 1437, 5, 124, 0, 0, 1435, 1437, 3, 272, 136, 0, 1436, 1434,
		1, 0, 0, 0, 1436, 1435, 1, 0, 0, 0, 1436, 1437, 1, 0, 0, 0, 1437, 1443,
		1, 0, 0, 0, 1438, 1439, 5, 66, 0, 0, 1439, 1443, 3, 298, 149, 0, 1440,
		1441, 5, 67, 0, 0, 1441, 1443, 3, 298, 149, 0, 1442, 1432, 1, 0, 0, 0,
		1442, 1438, 1, 0, 0, 0, 1442, 1440, 1, 0, 0, 0, 1443, 1444, 1, 0, 0, 0,
		1444, 1445, 3, 244, 122, 0, 1445, 1446, 6, 121, -1, 0, 1446, 1468, 1, 0,
		0, 0, 1447, 1448, 3, 298, 149, 0, 1448, 1449, 5, 86, 0, 0, 1449, 1450,
		3, 298, 149, 0, 1450, 1451, 5, 37, 0, 0, 1451, 1452, 3, 264, 132, 0, 1452,
		1453, 6, 121, -1, 0, 1453, 1468, 1, 0, 0, 0, 1454, 1455, 3, 276, 138, 0,
		1455, 1456, 6, 121, -1, 0, 1456, 1468, 1, 0, 0, 0, 1457, 1458, 3, 298,
		149, 0, 1458, 1459, 3, 132, 66, 0, 1459, 1460, 6, 121, -1, 0, 1460, 1468,
		1, 0, 0, 0, 1461, 1462, 3, 248, 124, 0, 1462, 1463, 6, 121, -1, 0, 1463,
		1468, 1, 0, 0, 0, 1464, 1465, 3, 250, 125, 0, 1465, 1466, 6, 121, -1, 0,
		1466, 1468, 1, 0, 0, 0, 1467, 1431, 1, 0, 0, 0, 1467, 1447, 1, 0, 0, 0,
		1467, 1454, 1, 0, 0, 0, 1467, 1457, 1, 0, 0, 0, 1467, 1461, 1, 0, 0, 0,
		1467, 1464, 1, 0, 0, 0, 1468, 243, 1, 0, 0, 0, 1469, 1474, 3, 290, 145,
		0, 1470, 1474, 3, 286, 143, 0, 1471, 1474, 3, 246, 123, 0, 1472, 1474,
		3, 294, 147, 0, 1473, 1469, 1, 0, 0, 0, 1473, 1470, 1, 0, 0, 0, 1473, 1471,
		1, 0, 0, 0, 1473, 1472, 1, 0, 0, 0, 1474, 245, 1, 0, 0, 0, 1475, 1478,
		3, 218, 109, 0, 1476, 1478, 3, 114, 57, 0, 1477, 1475, 1, 0, 0, 0, 1477,
		1476, 1, 0, 0, 0, 1478, 247, 1, 0, 0, 0, 1479, 1481, 5, 92, 0, 0, 1480,
		1479, 1, 0, 0, 0, 1480, 1481, 1, 0, 0, 0, 1481, 1482, 1, 0, 0, 0, 1482,
		1484, 5, 82, 0, 0, 1483, 1485, 3, 222, 111, 0, 1484, 1483, 1, 0, 0, 0,
		1484, 1485, 1, 0, 0, 0, 1485, 1486, 1, 0, 0, 0, 1486, 1487, 5, 83, 0, 0,
		1487, 249, 1, 0, 0, 0, 1488, 1490, 5, 92, 0, 0, 1489, 1488, 1, 0, 0, 0,
		1489, 1490, 1, 0, 0, 0, 1490, 1491, 1, 0, 0, 0, 1491, 1494, 5, 82, 0, 0,
		1492, 1495, 3, 258, 129, 0, 1493, 1495, 5, 93, 0, 0, 1494, 1492, 1, 0,
		0, 0, 1494, 1493, 1, 0, 0, 0, 1495, 1496, 1, 0, 0, 0, 1496, 1497, 5, 83,
		0, 0, 1497, 251, 1, 0, 0, 0, 1498, 1500, 3, 290, 145, 0, 1499, 1501, 3,
		84, 42, 0, 1500, 1499, 1, 0, 0, 0, 1500, 1501, 1, 0, 0, 0, 1501, 1516,
		1, 0, 0, 0, 1502, 1516, 3, 112, 56, 0, 1503, 1516, 3, 114, 57, 0, 1504,
		1505, 5, 37, 0, 0, 1505, 1506, 3, 298, 149, 0, 1506, 1507, 3, 264, 132,
		0, 1507, 1516, 1, 0, 0, 0, 1508, 1516, 5, 48, 0, 0, 1509, 1516, 5, 45,
		0, 0, 1510, 1516, 3, 218, 109, 0, 1511, 1516, 3, 132, 66, 0, 1512, 1516,
		3, 254, 127, 0, 1513, 1516, 3, 256, 128, 0, 1514, 1516, 3, 292, 146, 0,
		1515, 1498, 1, 0, 0, 0, 1515, 1502, 1, 0, 0, 0, 1515, 1503, 1, 0, 0, 0,
		1515, 1504, 1, 0, 0, 0, 1515, 1508, 1, 0, 0, 0, 1515, 1509, 1, 0, 0, 0,
		1515, 1510, 1, 0, 0, 0, 1515, 1511, 1, 0, 0, 0, 1515, 1512, 1, 0, 0, 0,
		1515, 1513, 1, 0, 0, 0, 1515, 1514, 1, 0, 0, 0, 1516, 253, 1, 0, 0, 0,
		1517, 1519, 5, 82, 0, 0, 1518, 1520, 3, 222, 111, 0, 1519, 1518, 1, 0,
		0, 0, 1519, 1520, 1, 0, 0, 0, 1520, 1522, 1, 0, 0, 0, 1521, 1523, 5, 85,
		0, 0, 1522, 1521, 1, 0, 0, 0, 1522, 1523, 1, 0, 0, 0, 1523, 1524, 1, 0,
		0, 0, 1524, 1525, 5, 83, 0, 0, 1525, 255, 1, 0, 0, 0, 1526, 1532, 5, 82,
		0, 0, 1527, 1529, 3, 258, 129, 0, 1528, 1530, 5, 85, 0, 0, 1529, 1528,
		1, 0, 0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 1533, 1, 0, 0, 0, 1531, 1533,
		5, 93, 0, 0, 1532, 1527, 1, 0, 0, 0, 1532, 1531, 1, 0, 0, 0, 1533, 1534,
		1, 0, 0, 0, 1534, 1535, 5, 83, 0, 0, 1535, 257, 1, 0, 0, 0, 1536, 1541,
		3, 260, 130, 0, 1537, 1538, 5, 85, 0, 0, 1538, 1540, 3, 260, 130, 0, 1539,
		1537, 1, 0, 0, 0, 1540, 1543, 1, 0, 0, 0, 1541, 1539, 1, 0, 0, 0, 1541,
		1542, 1, 0, 0, 0, 1542, 259, 1, 0, 0, 0, 1543, 1541, 1, 0, 0, 0, 1544,
		1545, 3, 262, 131, 0, 1545, 1546, 5, 93, 0, 0, 1546, 1547, 3, 298, 149,
		0, 1547, 1548, 3, 232, 116, 0, 1548, 1555, 1, 0, 0, 0, 1549, 1550, 5, 104,
		0, 0, 1550, 1551, 5, 93, 0, 0, 1551, 1552, 3, 298, 149, 0, 1552, 1553,
		3, 232, 116, 0, 1553, 1555, 1, 0, 0, 0, 1554, 1544, 1, 0, 0, 0, 1554, 1549,
		1, 0, 0, 0, 1555, 261, 1, 0, 0, 0, 1556, 1559, 3, 294, 147, 0, 1557, 1559,
		3, 252, 126, 0, 1558, 1556, 1, 0, 0, 0, 1558, 1557, 1, 0, 0, 0, 1559, 263,
		1, 0, 0, 0, 1560, 1584, 3, 270, 135, 0, 1561, 1562, 4, 132, 24, 1, 1562,
		1563, 3, 298, 149, 0, 1563, 1565, 3, 276, 138, 0, 1564, 1566, 3, 268, 134,
		0, 1565, 1564, 1, 0, 0, 0, 1565, 1566, 1, 0, 0, 0, 1566, 1585, 1, 0, 0,
		0, 1567, 1573, 4, 132, 25, 1, 1568, 1569, 3, 138, 69, 0, 1569, 1570, 5,
		82, 0, 0, 1570, 1571, 3, 232, 116, 0, 1571, 1572, 5, 83, 0, 0, 1572, 1574,
		1, 0, 0, 0, 1573, 1568, 1, 0, 0, 0, 1574, 1575, 1, 0, 0, 0, 1575, 1573,
		1, 0, 0, 0, 1575, 1576, 1, 0, 0, 0, 1576, 1577, 1, 0, 0, 0, 1577, 1578,
		3, 70, 35, 0, 1578, 1585, 1, 0, 0, 0, 1579, 1580, 4, 132, 26, 1, 1580,
		1581, 3, 68, 34, 0, 1581, 1582, 3, 298, 149, 0, 1582, 1583, 3, 266, 133,
		0, 1583, 1585, 1, 0, 0, 0, 1584, 1561, 1, 0, 0, 0, 1584, 1567, 1, 0, 0,
		0, 1584, 1579, 1, 0, 0, 0, 1585, 265, 1, 0, 0, 0, 1586, 1587, 5, 80, 0,
		0, 1587, 1589, 3, 298, 149, 0, 1588, 1590, 3, 66, 33, 0, 1589, 1588, 1,
		0, 0, 0, 1589, 1590, 1, 0, 0, 0, 1590, 1591, 1, 0, 0, 0, 1591, 1592, 3,
		298, 149, 0, 1592, 1593, 5, 81, 0, 0, 1593, 267, 1, 0, 0, 0, 1594, 1595,
		3, 40, 20, 0, 1595, 269, 1, 0, 0, 0, 1596, 1602, 3, 138, 69, 0, 1597, 1603,
		3, 82, 41, 0, 1598, 1600, 3, 108, 54, 0, 1599, 1601, 3, 274, 137, 0, 1600,
		1599, 1, 0, 0, 0, 1600, 1601, 1, 0, 0, 0, 1601, 1603, 1, 0, 0, 0, 1602,
		1597, 1, 0, 0, 0, 1602, 1598, 1, 0, 0, 0, 1603, 271, 1, 0, 0, 0, 1604,
		1605, 5, 89, 0, 0, 1605, 1606, 3, 298, 149, 0, 1606, 1607, 3, 36, 18, 0,
		1607, 1608, 3, 298, 149, 0, 1608, 1609, 5, 88, 0, 0, 1609, 273, 1, 0, 0,
		0, 1610, 1611, 5, 89, 0, 0, 1611, 1614, 5, 88, 0, 0, 1612, 1614, 3, 84,
		42, 0, 1613, 1610, 1, 0, 0, 0, 1613, 1612, 1, 0, 0, 0, 1614, 275, 1, 0,
		0, 0, 1615, 1617, 5, 78, 0, 0, 1616, 1618, 3, 280, 140, 0, 1617, 1616,
		1, 0, 0, 0, 1617, 1618, 1, 0, 0, 0, 1618, 1620, 1, 0, 0, 0, 1619, 1621,
		5, 85, 0, 0, 1620, 1619, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 1622,
		1, 0, 0, 0, 1622, 1623, 3, 296, 148, 0, 1623, 277, 1, 0, 0, 0, 1624, 1631,
		3, 282, 141, 0, 1625, 1626, 5, 85, 0, 0, 1626, 1627, 3, 298, 149, 0, 1627,
		1628, 3, 282, 141, 0, 1628, 1630, 1, 0, 0, 0, 1629, 1625, 1, 0, 0, 0, 1630,
		1633, 1, 0, 0, 0, 1631, 1629, 1, 0, 0, 0, 1631, 1632, 1, 0, 0, 0, 1632,
		279, 1, 0, 0, 0, 1633, 1631, 1, 0, 0, 0, 1634, 1641, 3, 284, 142, 0, 1635,
		1636, 5, 85, 0, 0, 1636, 1637, 3, 298, 149, 0, 1637, 1638, 3, 284, 142,
		0, 1638, 1640, 1, 0, 0, 0, 1639, 1635, 1, 0, 0, 0, 1640, 1643, 1, 0, 0,
		0, 1641, 1639, 1, 0, 0, 0, 1641, 1642, 1, 0, 0, 0, 1642, 281, 1, 0, 0,
		0, 1643, 1641, 1, 0, 0, 0, 1644, 1647, 3, 224, 112, 0, 1645, 1647, 3, 260,
		130, 0, 1646, 1644, 1, 0, 0, 0, 1646, 1645, 1, 0, 0, 0, 1647, 283, 1, 0,
		0, 0, 1648, 1652, 3, 224, 112, 0, 1649, 1652, 3, 122, 61, 0, 1650, 1652,
		3, 260, 130, 0, 1651, 1648, 1, 0, 0, 0, 1651, 1649, 1, 0, 0, 0, 1651, 1650,
		1, 0, 0, 0, 1652, 285, 1, 0, 0, 0, 1653, 1654, 5, 1, 0, 0, 1654, 287, 1,
		0, 0, 0, 1655, 1656, 5, 122, 0, 0, 1656, 289, 1, 0, 0, 0, 1657, 1658, 7,
		18, 0, 0, 1658, 291, 1, 0, 0, 0, 1659, 1660, 7, 19, 0, 0, 1660, 293, 1,
		0, 0, 0, 1661, 1662, 7, 20, 0, 0, 1662, 295, 1, 0, 0, 0, 1663, 1666, 5,
		79, 0, 0, 1664, 1666, 1, 0, 0, 0, 1665, 1663, 1, 0, 0, 0, 1665, 1664, 1,
		0, 0, 0, 1666, 297, 1, 0, 0, 0, 1667, 1669, 5, 127, 0, 0, 1668, 1667, 1,
		0, 0, 0, 1669, 1672, 1, 0, 0, 0, 1670, 1668, 1, 0, 0, 0, 1670, 1671, 1,
		0, 0, 0, 1671, 299, 1, 0, 0, 0, 1672, 1670, 1, 0, 0, 0, 1673, 1675, 7,
		21, 0, 0, 1674, 1673, 1, 0, 0, 0, 1675, 1676, 1, 0, 0, 0, 1676, 1674, 1,
		0, 0, 0, 1676, 1677, 1, 0, 0, 0, 1677, 301, 1, 0, 0, 0, 187, 304, 307,
		310, 320, 324, 329, 338, 345, 352, 355, 362, 365, 372, 376, 380, 383, 390,
		401, 412, 421, 431, 445, 451, 460, 464, 467, 475, 478, 481, 489, 492, 495,
		498, 505, 509, 521, 527, 532, 535, 540, 544, 551, 562, 566, 569, 578, 582,
		584, 588, 593, 604, 613, 628, 633, 641, 644, 649, 656, 659, 665, 668, 672,
		676, 689, 702, 704, 716, 721, 727, 735, 743, 746, 754, 763, 771, 778, 790,
		798, 806, 814, 818, 824, 843, 847, 852, 858, 865, 868, 876, 880, 887, 894,
		897, 901, 910, 921, 926, 934, 937, 940, 949, 952, 959, 967, 971, 980, 983,
		988, 996, 1002, 1012, 1018, 1026, 1032, 1042, 1067, 1071, 1075, 1079, 1088,
		1094, 1103, 1116, 1132, 1138, 1150, 1161, 1171, 1176, 1183, 1193, 1197,
		1201, 1208, 1212, 1216, 1220, 1239, 1244, 1250, 1256, 1275, 1302, 1305,
		1369, 1385, 1387, 1400, 1405, 1410, 1417, 1420, 1428, 1436, 1442, 1467,
		1473, 1477, 1480, 1484, 1489, 1494, 1500, 1515, 1519, 1522, 1529, 1532,
		1541, 1554, 1558, 1565, 1575, 1584, 1589, 1600, 1602, 1613, 1617, 1620,
		1631, 1641, 1646, 1651, 1665, 1670, 1676,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// GroovyParserInit initializes any static state used to implement GroovyParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewGroovyParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func GroovyParserInit() {
	staticData := &groovyparserParserStaticData
	staticData.once.Do(groovyparserParserInit)
}

// NewGroovyParser produces a new parser instance for the optional input antlr.TokenStream.
func NewGroovyParser(input antlr.TokenStream) *GroovyParser {
	GroovyParserInit()
	this := new(GroovyParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &groovyparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// GroovyParser tokens.
const (
	GroovyParserEOF                   = antlr.TokenEOF
	GroovyParserStringLiteral         = 1
	GroovyParserGStringBegin          = 2
	GroovyParserGStringEnd            = 3
	GroovyParserGStringPart           = 4
	GroovyParserGStringPathPart       = 5
	GroovyParserRollBackOne           = 6
	GroovyParserAS                    = 7
	GroovyParserDEF                   = 8
	GroovyParserIN                    = 9
	GroovyParserTRAIT                 = 10
	GroovyParserTHREADSAFE            = 11
	GroovyParserVAR                   = 12
	GroovyParserBuiltInPrimitiveType  = 13
	GroovyParserABSTRACT              = 14
	GroovyParserASSERT                = 15
	GroovyParserBREAK                 = 16
	GroovyParserCASE                  = 17
	GroovyParserCATCH                 = 18
	GroovyParserCLASS                 = 19
	GroovyParserCONST                 = 20
	GroovyParserCONTINUE              = 21
	GroovyParserDEFAULT               = 22
	GroovyParserDO                    = 23
	GroovyParserELSE                  = 24
	GroovyParserENUM                  = 25
	GroovyParserEXTENDS               = 26
	GroovyParserFINAL                 = 27
	GroovyParserFINALLY               = 28
	GroovyParserFOR                   = 29
	GroovyParserIF                    = 30
	GroovyParserGOTO                  = 31
	GroovyParserIMPLEMENTS            = 32
	GroovyParserIMPORT                = 33
	GroovyParserINSTANCEOF            = 34
	GroovyParserINTERFACE             = 35
	GroovyParserNATIVE                = 36
	GroovyParserNEW                   = 37
	GroovyParserPACKAGE               = 38
	GroovyParserPRIVATE               = 39
	GroovyParserPROTECTED             = 40
	GroovyParserPUBLIC                = 41
	GroovyParserRETURN                = 42
	GroovyParserSTATIC                = 43
	GroovyParserSTRICTFP              = 44
	GroovyParserSUPER                 = 45
	GroovyParserSWITCH                = 46
	GroovyParserSYNCHRONIZED          = 47
	GroovyParserTHIS                  = 48
	GroovyParserTHROW                 = 49
	GroovyParserTHROWS                = 50
	GroovyParserTRANSIENT             = 51
	GroovyParserTRY                   = 52
	GroovyParserVOID                  = 53
	GroovyParserVOLATILE              = 54
	GroovyParserWHILE                 = 55
	GroovyParserIntegerLiteral        = 56
	GroovyParserFloatingPointLiteral  = 57
	GroovyParserBooleanLiteral        = 58
	GroovyParserNullLiteral           = 59
	GroovyParserRANGE_INCLUSIVE       = 60
	GroovyParserRANGE_EXCLUSIVE       = 61
	GroovyParserSPREAD_DOT            = 62
	GroovyParserSAFE_DOT              = 63
	GroovyParserSAFE_CHAIN_DOT        = 64
	GroovyParserELVIS                 = 65
	GroovyParserMETHOD_POINTER        = 66
	GroovyParserMETHOD_REFERENCE      = 67
	GroovyParserREGEX_FIND            = 68
	GroovyParserREGEX_MATCH           = 69
	GroovyParserPOWER                 = 70
	GroovyParserPOWER_ASSIGN          = 71
	GroovyParserSPACESHIP             = 72
	GroovyParserIDENTICAL             = 73
	GroovyParserNOT_IDENTICAL         = 74
	GroovyParserARROW                 = 75
	GroovyParserNOT_INSTANCEOF        = 76
	GroovyParserNOT_IN                = 77
	GroovyParserLPAREN                = 78
	GroovyParserRPAREN                = 79
	GroovyParserLBRACE                = 80
	GroovyParserRBRACE                = 81
	GroovyParserLBRACK                = 82
	GroovyParserRBRACK                = 83
	GroovyParserSEMI                  = 84
	GroovyParserCOMMA                 = 85
	GroovyParserDOT                   = 86
	GroovyParserASSIGN                = 87
	GroovyParserGT                    = 88
	GroovyParserLT                    = 89
	GroovyParserNOT                   = 90
	GroovyParserBITNOT                = 91
	GroovyParserQUESTION              = 92
	GroovyParserCOLON                 = 93
	GroovyParserEQUAL                 = 94
	GroovyParserLE                    = 95
	GroovyParserGE                    = 96
	GroovyParserNOTEQUAL              = 97
	GroovyParserAND                   = 98
	GroovyParserOR                    = 99
	GroovyParserINC                   = 100
	GroovyParserDEC                   = 101
	GroovyParserADD                   = 102
	GroovyParserSUB                   = 103
	GroovyParserMUL                   = 104
	GroovyParserDIV                   = 105
	GroovyParserBITAND                = 106
	GroovyParserBITOR                 = 107
	GroovyParserXOR                   = 108
	GroovyParserMOD                   = 109
	GroovyParserADD_ASSIGN            = 110
	GroovyParserSUB_ASSIGN            = 111
	GroovyParserMUL_ASSIGN            = 112
	GroovyParserDIV_ASSIGN            = 113
	GroovyParserAND_ASSIGN            = 114
	GroovyParserOR_ASSIGN             = 115
	GroovyParserXOR_ASSIGN            = 116
	GroovyParserMOD_ASSIGN            = 117
	GroovyParserLSHIFT_ASSIGN         = 118
	GroovyParserRSHIFT_ASSIGN         = 119
	GroovyParserURSHIFT_ASSIGN        = 120
	GroovyParserELVIS_ASSIGN          = 121
	GroovyParserCapitalizedIdentifier = 122
	GroovyParserIdentifier            = 123
	GroovyParserAT                    = 124
	GroovyParserELLIPSIS              = 125
	GroovyParserWS                    = 126
	GroovyParserNL                    = 127
	GroovyParserSH_COMMENT            = 128
	GroovyParserUNEXPECTED_CHAR       = 129
)

// GroovyParser rules.
const (
	GroovyParserRULE_compilationUnit                = 0
	GroovyParserRULE_scriptStatements               = 1
	GroovyParserRULE_scriptStatement                = 2
	GroovyParserRULE_packageDeclaration             = 3
	GroovyParserRULE_importDeclaration              = 4
	GroovyParserRULE_typeDeclaration                = 5
	GroovyParserRULE_modifier                       = 6
	GroovyParserRULE_modifiersOpt                   = 7
	GroovyParserRULE_modifiers                      = 8
	GroovyParserRULE_classOrInterfaceModifiersOpt   = 9
	GroovyParserRULE_classOrInterfaceModifiers      = 10
	GroovyParserRULE_classOrInterfaceModifier       = 11
	GroovyParserRULE_variableModifier               = 12
	GroovyParserRULE_variableModifiersOpt           = 13
	GroovyParserRULE_variableModifiers              = 14
	GroovyParserRULE_typeParameters                 = 15
	GroovyParserRULE_typeParameter                  = 16
	GroovyParserRULE_typeBound                      = 17
	GroovyParserRULE_typeList                       = 18
	GroovyParserRULE_classDeclaration               = 19
	GroovyParserRULE_classBody                      = 20
	GroovyParserRULE_enumConstants                  = 21
	GroovyParserRULE_enumConstant                   = 22
	GroovyParserRULE_classBodyDeclaration           = 23
	GroovyParserRULE_memberDeclaration              = 24
	GroovyParserRULE_methodDeclaration              = 25
	GroovyParserRULE_methodName                     = 26
	GroovyParserRULE_returnType                     = 27
	GroovyParserRULE_fieldDeclaration               = 28
	GroovyParserRULE_variableDeclarators            = 29
	GroovyParserRULE_variableDeclarator             = 30
	GroovyParserRULE_variableDeclaratorId           = 31
	GroovyParserRULE_variableInitializer            = 32
	GroovyParserRULE_variableInitializers           = 33
	GroovyParserRULE_dims                           = 34
	GroovyParserRULE_dimsOpt                        = 35
	GroovyParserRULE_standardType                   = 36
	GroovyParserRULE_typeType                       = 37
	GroovyParserRULE_classOrInterfaceType           = 38
	GroovyParserRULE_generalClassOrInterfaceType    = 39
	GroovyParserRULE_standardClassOrInterfaceType   = 40
	GroovyParserRULE_primitiveType                  = 41
	GroovyParserRULE_typeArguments                  = 42
	GroovyParserRULE_typeArgument                   = 43
	GroovyParserRULE_annotatedQualifiedClassName    = 44
	GroovyParserRULE_qualifiedClassNameList         = 45
	GroovyParserRULE_formalParameters               = 46
	GroovyParserRULE_formalParameterList            = 47
	GroovyParserRULE_thisFormalParameter            = 48
	GroovyParserRULE_formalParameter                = 49
	GroovyParserRULE_methodBody                     = 50
	GroovyParserRULE_qualifiedName                  = 51
	GroovyParserRULE_qualifiedNameElement           = 52
	GroovyParserRULE_qualifiedNameElements          = 53
	GroovyParserRULE_qualifiedClassName             = 54
	GroovyParserRULE_qualifiedStandardClassName     = 55
	GroovyParserRULE_literal                        = 56
	GroovyParserRULE_gstring                        = 57
	GroovyParserRULE_gstringValue                   = 58
	GroovyParserRULE_gstringPath                    = 59
	GroovyParserRULE_lambdaExpression               = 60
	GroovyParserRULE_standardLambdaExpression       = 61
	GroovyParserRULE_lambdaParameters               = 62
	GroovyParserRULE_standardLambdaParameters       = 63
	GroovyParserRULE_lambdaBody                     = 64
	GroovyParserRULE_closure                        = 65
	GroovyParserRULE_closureOrLambdaExpression      = 66
	GroovyParserRULE_blockStatementsOpt             = 67
	GroovyParserRULE_blockStatements                = 68
	GroovyParserRULE_annotationsOpt                 = 69
	GroovyParserRULE_annotation                     = 70
	GroovyParserRULE_elementValues                  = 71
	GroovyParserRULE_annotationName                 = 72
	GroovyParserRULE_elementValuePairs              = 73
	GroovyParserRULE_elementValuePair               = 74
	GroovyParserRULE_elementValuePairName           = 75
	GroovyParserRULE_elementValue                   = 76
	GroovyParserRULE_elementValueArrayInitializer   = 77
	GroovyParserRULE_block                          = 78
	GroovyParserRULE_blockStatement                 = 79
	GroovyParserRULE_localVariableDeclaration       = 80
	GroovyParserRULE_classifiedModifiers            = 81
	GroovyParserRULE_variableDeclaration            = 82
	GroovyParserRULE_typeNamePairs                  = 83
	GroovyParserRULE_typeNamePair                   = 84
	GroovyParserRULE_variableNames                  = 85
	GroovyParserRULE_conditionalStatement           = 86
	GroovyParserRULE_ifElseStatement                = 87
	GroovyParserRULE_switchStatement                = 88
	GroovyParserRULE_loopStatement                  = 89
	GroovyParserRULE_continueStatement              = 90
	GroovyParserRULE_breakStatement                 = 91
	GroovyParserRULE_tryCatchStatement              = 92
	GroovyParserRULE_assertStatement                = 93
	GroovyParserRULE_statement                      = 94
	GroovyParserRULE_catchClause                    = 95
	GroovyParserRULE_catchType                      = 96
	GroovyParserRULE_finallyBlock                   = 97
	GroovyParserRULE_resources                      = 98
	GroovyParserRULE_resourceList                   = 99
	GroovyParserRULE_resource                       = 100
	GroovyParserRULE_switchBlockStatementGroup      = 101
	GroovyParserRULE_switchLabel                    = 102
	GroovyParserRULE_forControl                     = 103
	GroovyParserRULE_enhancedForControl             = 104
	GroovyParserRULE_classicalForControl            = 105
	GroovyParserRULE_forInit                        = 106
	GroovyParserRULE_forUpdate                      = 107
	GroovyParserRULE_castParExpression              = 108
	GroovyParserRULE_parExpression                  = 109
	GroovyParserRULE_expressionInPar                = 110
	GroovyParserRULE_expressionList                 = 111
	GroovyParserRULE_expressionListElement          = 112
	GroovyParserRULE_enhancedStatementExpression    = 113
	GroovyParserRULE_statementExpression            = 114
	GroovyParserRULE_postfixExpression              = 115
	GroovyParserRULE_expression                     = 116
	GroovyParserRULE_castOperandExpression          = 117
	GroovyParserRULE_commandExpression              = 118
	GroovyParserRULE_commandArgument                = 119
	GroovyParserRULE_pathExpression                 = 120
	GroovyParserRULE_pathElement                    = 121
	GroovyParserRULE_namePart                       = 122
	GroovyParserRULE_dynamicMemberName              = 123
	GroovyParserRULE_indexPropertyArgs              = 124
	GroovyParserRULE_namedPropertyArgs              = 125
	GroovyParserRULE_primary                        = 126
	GroovyParserRULE_list                           = 127
	GroovyParserRULE_normalMap                      = 128
	GroovyParserRULE_mapEntryList                   = 129
	GroovyParserRULE_mapEntry                       = 130
	GroovyParserRULE_mapEntryLabel                  = 131
	GroovyParserRULE_creator                        = 132
	GroovyParserRULE_arrayInitializer               = 133
	GroovyParserRULE_anonymousInnerClassDeclaration = 134
	GroovyParserRULE_createdName                    = 135
	GroovyParserRULE_nonWildcardTypeArguments       = 136
	GroovyParserRULE_typeArgumentsOrDiamond         = 137
	GroovyParserRULE_arguments                      = 138
	GroovyParserRULE_argumentList                   = 139
	GroovyParserRULE_enhancedArgumentList           = 140
	GroovyParserRULE_argumentListElement            = 141
	GroovyParserRULE_enhancedArgumentListElement    = 142
	GroovyParserRULE_stringLiteral                  = 143
	GroovyParserRULE_className                      = 144
	GroovyParserRULE_identifier                     = 145
	GroovyParserRULE_builtInType                    = 146
	GroovyParserRULE_keywords                       = 147
	GroovyParserRULE_rparen                         = 148
	GroovyParserRULE_nls                            = 149
	GroovyParserRULE_sep                            = 150
)

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *CompilationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserEOF, 0)
}

func (s *CompilationUnitContext) PackageDeclaration() IPackageDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageDeclarationContext)
}

func (s *CompilationUnitContext) Sep() ISepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *CompilationUnitContext) ScriptStatements() IScriptStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptStatementsContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (p *GroovyParser) CompilationUnit() (localctx ICompilationUnitContext) {
	this := p
	_ = this

	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, GroovyParserRULE_compilationUnit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(302)
		p.Nls()
	}
	p.SetState(304)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(303)
			p.PackageDeclaration()
		}

	}
	p.SetState(307)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(306)
			p.Sep()
		}

	}
	p.SetState(310)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(309)
			p.ScriptStatements()
		}

	}
	{
		p.SetState(312)
		p.Match(GroovyParserEOF)
	}

	return localctx
}

// IScriptStatementsContext is an interface to support dynamic dispatch.
type IScriptStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptStatementsContext differentiates from other interfaces.
	IsScriptStatementsContext()
}

type ScriptStatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptStatementsContext() *ScriptStatementsContext {
	var p = new(ScriptStatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_scriptStatements
	return p
}

func (*ScriptStatementsContext) IsScriptStatementsContext() {}

func NewScriptStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptStatementsContext {
	var p = new(ScriptStatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_scriptStatements

	return p
}

func (s *ScriptStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptStatementsContext) AllScriptStatement() []IScriptStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScriptStatementContext); ok {
			len++
		}
	}

	tst := make([]IScriptStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScriptStatementContext); ok {
			tst[i] = t.(IScriptStatementContext)
			i++
		}
	}

	return tst
}

func (s *ScriptStatementsContext) ScriptStatement(i int) IScriptStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptStatementContext)
}

func (s *ScriptStatementsContext) AllSep() []ISepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISepContext); ok {
			len++
		}
	}

	tst := make([]ISepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISepContext); ok {
			tst[i] = t.(ISepContext)
			i++
		}
	}

	return tst
}

func (s *ScriptStatementsContext) Sep(i int) ISepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ScriptStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterScriptStatements(s)
	}
}

func (s *ScriptStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitScriptStatements(s)
	}
}

func (p *GroovyParser) ScriptStatements() (localctx IScriptStatementsContext) {
	this := p
	_ = this

	localctx = NewScriptStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, GroovyParserRULE_scriptStatements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(314)
		p.ScriptStatement()
	}
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(315)
				p.Sep()
			}
			{
				p.SetState(316)
				p.ScriptStatement()
			}

		}
		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
	}
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserSEMI || _la == GroovyParserNL {
		{
			p.SetState(323)
			p.Sep()
		}

	}

	return localctx
}

// IScriptStatementContext is an interface to support dynamic dispatch.
type IScriptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptStatementContext differentiates from other interfaces.
	IsScriptStatementContext()
}

type ScriptStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptStatementContext() *ScriptStatementContext {
	var p = new(ScriptStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_scriptStatement
	return p
}

func (*ScriptStatementContext) IsScriptStatementContext() {}

func NewScriptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptStatementContext {
	var p = new(ScriptStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_scriptStatement

	return p
}

func (s *ScriptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptStatementContext) ImportDeclaration() IImportDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *ScriptStatementContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *ScriptStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ScriptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterScriptStatement(s)
	}
}

func (s *ScriptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitScriptStatement(s)
	}
}

func (p *GroovyParser) ScriptStatement() (localctx IScriptStatementContext) {
	this := p
	_ = this

	localctx = NewScriptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, GroovyParserRULE_scriptStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(326)
			p.ImportDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(327)
			p.TypeDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(328)
			p.Statement()
		}

	}

	return localctx
}

// IPackageDeclarationContext is an interface to support dynamic dispatch.
type IPackageDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageDeclarationContext differentiates from other interfaces.
	IsPackageDeclarationContext()
}

type PackageDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageDeclarationContext() *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_packageDeclaration
	return p
}

func (*PackageDeclarationContext) IsPackageDeclarationContext() {}

func NewPackageDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_packageDeclaration

	return p
}

func (s *PackageDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageDeclarationContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *PackageDeclarationContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPACKAGE, 0)
}

func (s *PackageDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PackageDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPackageDeclaration(s)
	}
}

func (s *PackageDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPackageDeclaration(s)
	}
}

func (p *GroovyParser) PackageDeclaration() (localctx IPackageDeclarationContext) {
	this := p
	_ = this

	localctx = NewPackageDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, GroovyParserRULE_packageDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(331)
		p.AnnotationsOpt()
	}
	{
		p.SetState(332)
		p.Match(GroovyParserPACKAGE)
	}
	{
		p.SetState(333)
		p.QualifiedName()
	}

	return localctx
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	alias  IIdentifierContext
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_importDeclaration
	return p
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) GetAlias() IIdentifierContext { return s.alias }

func (s *ImportDeclarationContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *ImportDeclarationContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *ImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPORT, 0)
}

func (s *ImportDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ImportDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *ImportDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, 0)
}

func (s *ImportDeclarationContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *ImportDeclarationContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *ImportDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterImportDeclaration(s)
	}
}

func (s *ImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitImportDeclaration(s)
	}
}

func (p *GroovyParser) ImportDeclaration() (localctx IImportDeclarationContext) {
	this := p
	_ = this

	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, GroovyParserRULE_importDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(335)
		p.AnnotationsOpt()
	}
	{
		p.SetState(336)
		p.Match(GroovyParserIMPORT)
	}
	p.SetState(338)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(337)
			p.Match(GroovyParserSTATIC)
		}

	}
	{
		p.SetState(340)
		p.QualifiedName()
	}
	p.SetState(345)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserDOT:
		{
			p.SetState(341)
			p.Match(GroovyParserDOT)
		}
		{
			p.SetState(342)
			p.Match(GroovyParserMUL)
		}

	case GroovyParserAS:
		{
			p.SetState(343)
			p.Match(GroovyParserAS)
		}
		{
			p.SetState(344)

			var _x = p.Identifier()

			localctx.(*ImportDeclarationContext).alias = _x
		}

	case GroovyParserEOF, GroovyParserSEMI, GroovyParserNL:

	default:
	}

	return localctx
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeDeclaration
	return p
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) ClassOrInterfaceModifiersOpt() IClassOrInterfaceModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifiersOptContext)
}

func (s *TypeDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeDeclaration(s)
	}
}

func (p *GroovyParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, GroovyParserRULE_typeDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(347)
		p.ClassOrInterfaceModifiersOpt()
	}
	{
		p.SetState(348)
		p.ClassDeclaration()
	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m token.
	GetM() antlr.Token

	// SetM sets the m token.
	SetM(antlr.Token)

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	m      antlr.Token
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) GetM() antlr.Token { return s.m }

func (s *ModifierContext) SetM(v antlr.Token) { s.m = v }

func (s *ModifierContext) ClassOrInterfaceModifier() IClassOrInterfaceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *ModifierContext) NATIVE() antlr.TerminalNode {
	return s.GetToken(GroovyParserNATIVE, 0)
}

func (s *ModifierContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSYNCHRONIZED, 0)
}

func (s *ModifierContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRANSIENT, 0)
}

func (s *ModifierContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOLATILE, 0)
}

func (s *ModifierContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *ModifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *GroovyParser) Modifier() (localctx IModifierContext) {
	this := p
	_ = this

	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, GroovyParserRULE_modifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(352)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserABSTRACT, GroovyParserDEFAULT, GroovyParserFINAL, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(350)
			p.ClassOrInterfaceModifier()
		}

	case GroovyParserDEF, GroovyParserVAR, GroovyParserNATIVE, GroovyParserSYNCHRONIZED, GroovyParserTRANSIENT, GroovyParserVOLATILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(351)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ModifierContext).m = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&20407004531003648) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ModifierContext).m = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModifiersOptContext is an interface to support dynamic dispatch.
type IModifiersOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifiersOptContext differentiates from other interfaces.
	IsModifiersOptContext()
}

type ModifiersOptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersOptContext() *ModifiersOptContext {
	var p = new(ModifiersOptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_modifiersOpt
	return p
}

func (*ModifiersOptContext) IsModifiersOptContext() {}

func NewModifiersOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersOptContext {
	var p = new(ModifiersOptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_modifiersOpt

	return p
}

func (s *ModifiersOptContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersOptContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ModifiersOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterModifiersOpt(s)
	}
}

func (s *ModifiersOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitModifiersOpt(s)
	}
}

func (p *GroovyParser) ModifiersOpt() (localctx IModifiersOptContext) {
	this := p
	_ = this

	localctx = NewModifiersOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, GroovyParserRULE_modifiersOpt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(355)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(354)
			p.Modifiers()
		}

	}

	return localctx
}

// IModifiersContext is an interface to support dynamic dispatch.
type IModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifiersContext differentiates from other interfaces.
	IsModifiersContext()
}

type ModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersContext() *ModifiersContext {
	var p = new(ModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_modifiers
	return p
}

func (*ModifiersContext) IsModifiersContext() {}

func NewModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersContext {
	var p = new(ModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_modifiers

	return p
}

func (s *ModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifiersContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ModifiersContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ModifiersContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterModifiers(s)
	}
}

func (s *ModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitModifiers(s)
	}
}

func (p *GroovyParser) Modifiers() (localctx IModifiersContext) {
	this := p
	_ = this

	localctx = NewModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, GroovyParserRULE_modifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(357)
				p.Modifier()
			}
			{
				p.SetState(358)
				p.Nls()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext())
	}

	return localctx
}

// IClassOrInterfaceModifiersOptContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifiersOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceModifiersOptContext differentiates from other interfaces.
	IsClassOrInterfaceModifiersOptContext()
}

type ClassOrInterfaceModifiersOptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceModifiersOptContext() *ClassOrInterfaceModifiersOptContext {
	var p = new(ClassOrInterfaceModifiersOptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiersOpt
	return p
}

func (*ClassOrInterfaceModifiersOptContext) IsClassOrInterfaceModifiersOptContext() {}

func NewClassOrInterfaceModifiersOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifiersOptContext {
	var p = new(ClassOrInterfaceModifiersOptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiersOpt

	return p
}

func (s *ClassOrInterfaceModifiersOptContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifiersOptContext) ClassOrInterfaceModifiers() IClassOrInterfaceModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifiersContext)
}

func (s *ClassOrInterfaceModifiersOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifiersOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifiersOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassOrInterfaceModifiersOpt(s)
	}
}

func (s *ClassOrInterfaceModifiersOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassOrInterfaceModifiersOpt(s)
	}
}

func (p *GroovyParser) ClassOrInterfaceModifiersOpt() (localctx IClassOrInterfaceModifiersOptContext) {
	this := p
	_ = this

	localctx = NewClassOrInterfaceModifiersOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, GroovyParserRULE_classOrInterfaceModifiersOpt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(365)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(364)
			p.ClassOrInterfaceModifiers()
		}

	}

	return localctx
}

// IClassOrInterfaceModifiersContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceModifiersContext differentiates from other interfaces.
	IsClassOrInterfaceModifiersContext()
}

type ClassOrInterfaceModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceModifiersContext() *ClassOrInterfaceModifiersContext {
	var p = new(ClassOrInterfaceModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiers
	return p
}

func (*ClassOrInterfaceModifiersContext) IsClassOrInterfaceModifiersContext() {}

func NewClassOrInterfaceModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifiersContext {
	var p = new(ClassOrInterfaceModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiers

	return p
}

func (s *ClassOrInterfaceModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifiersContext) AllClassOrInterfaceModifier() []IClassOrInterfaceModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassOrInterfaceModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			tst[i] = t.(IClassOrInterfaceModifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceModifiersContext) ClassOrInterfaceModifier(i int) IClassOrInterfaceModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *ClassOrInterfaceModifiersContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceModifiersContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassOrInterfaceModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassOrInterfaceModifiers(s)
	}
}

func (s *ClassOrInterfaceModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassOrInterfaceModifiers(s)
	}
}

func (p *GroovyParser) ClassOrInterfaceModifiers() (localctx IClassOrInterfaceModifiersContext) {
	this := p
	_ = this

	localctx = NewClassOrInterfaceModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, GroovyParserRULE_classOrInterfaceModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(367)
				p.ClassOrInterfaceModifier()
			}
			{
				p.SetState(368)
				p.Nls()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(372)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
	}

	return localctx
}

// IClassOrInterfaceModifierContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m token.
	GetM() antlr.Token

	// SetM sets the m token.
	SetM(antlr.Token)

	// IsClassOrInterfaceModifierContext differentiates from other interfaces.
	IsClassOrInterfaceModifierContext()
}

type ClassOrInterfaceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	m      antlr.Token
}

func NewEmptyClassOrInterfaceModifierContext() *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifier
	return p
}

func (*ClassOrInterfaceModifierContext) IsClassOrInterfaceModifierContext() {}

func NewClassOrInterfaceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifier

	return p
}

func (s *ClassOrInterfaceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifierContext) GetM() antlr.Token { return s.m }

func (s *ClassOrInterfaceModifierContext) SetM(v antlr.Token) { s.m = v }

func (s *ClassOrInterfaceModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassOrInterfaceModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserPUBLIC, 0)
}

func (s *ClassOrInterfaceModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(GroovyParserPROTECTED, 0)
}

func (s *ClassOrInterfaceModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPRIVATE, 0)
}

func (s *ClassOrInterfaceModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *ClassOrInterfaceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(GroovyParserABSTRACT, 0)
}

func (s *ClassOrInterfaceModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINAL, 0)
}

func (s *ClassOrInterfaceModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTRICTFP, 0)
}

func (s *ClassOrInterfaceModifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *ClassOrInterfaceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassOrInterfaceModifier(s)
	}
}

func (s *ClassOrInterfaceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassOrInterfaceModifier(s)
	}
}

func (p *GroovyParser) ClassOrInterfaceModifier() (localctx IClassOrInterfaceModifierContext) {
	this := p
	_ = this

	localctx = NewClassOrInterfaceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, GroovyParserRULE_classOrInterfaceModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(376)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(374)
			p.Annotation()
		}

	case GroovyParserABSTRACT, GroovyParserDEFAULT, GroovyParserFINAL, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserSTATIC, GroovyParserSTRICTFP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(375)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ClassOrInterfaceModifierContext).m = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&30236708192256) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ClassOrInterfaceModifierContext).m = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableModifierContext is an interface to support dynamic dispatch.
type IVariableModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m token.
	GetM() antlr.Token

	// SetM sets the m token.
	SetM(antlr.Token)

	// IsVariableModifierContext differentiates from other interfaces.
	IsVariableModifierContext()
}

type VariableModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	m      antlr.Token
}

func NewEmptyVariableModifierContext() *VariableModifierContext {
	var p = new(VariableModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableModifier
	return p
}

func (*VariableModifierContext) IsVariableModifierContext() {}

func NewVariableModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifierContext {
	var p = new(VariableModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableModifier

	return p
}

func (s *VariableModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifierContext) GetM() antlr.Token { return s.m }

func (s *VariableModifierContext) SetM(v antlr.Token) { s.m = v }

func (s *VariableModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINAL, 0)
}

func (s *VariableModifierContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *VariableModifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *VariableModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserPUBLIC, 0)
}

func (s *VariableModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(GroovyParserPROTECTED, 0)
}

func (s *VariableModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPRIVATE, 0)
}

func (s *VariableModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *VariableModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(GroovyParserABSTRACT, 0)
}

func (s *VariableModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTRICTFP, 0)
}

func (s *VariableModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableModifier(s)
	}
}

func (s *VariableModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableModifier(s)
	}
}

func (p *GroovyParser) VariableModifier() (localctx IVariableModifierContext) {
	this := p
	_ = this

	localctx = NewVariableModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, GroovyParserRULE_variableModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(380)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(378)
			p.Annotation()
		}

	case GroovyParserDEF, GroovyParserVAR, GroovyParserABSTRACT, GroovyParserFINAL, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserSTATIC, GroovyParserSTRICTFP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(379)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*VariableModifierContext).m = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&30236704002304) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*VariableModifierContext).m = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableModifiersOptContext is an interface to support dynamic dispatch.
type IVariableModifiersOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableModifiersOptContext differentiates from other interfaces.
	IsVariableModifiersOptContext()
}

type VariableModifiersOptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableModifiersOptContext() *VariableModifiersOptContext {
	var p = new(VariableModifiersOptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableModifiersOpt
	return p
}

func (*VariableModifiersOptContext) IsVariableModifiersOptContext() {}

func NewVariableModifiersOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifiersOptContext {
	var p = new(VariableModifiersOptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableModifiersOpt

	return p
}

func (s *VariableModifiersOptContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifiersOptContext) VariableModifiers() IVariableModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersContext)
}

func (s *VariableModifiersOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifiersOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifiersOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableModifiersOpt(s)
	}
}

func (s *VariableModifiersOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableModifiersOpt(s)
	}
}

func (p *GroovyParser) VariableModifiersOpt() (localctx IVariableModifiersOptContext) {
	this := p
	_ = this

	localctx = NewVariableModifiersOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, GroovyParserRULE_variableModifiersOpt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(383)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(382)
			p.VariableModifiers()
		}

	}

	return localctx
}

// IVariableModifiersContext is an interface to support dynamic dispatch.
type IVariableModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableModifiersContext differentiates from other interfaces.
	IsVariableModifiersContext()
}

type VariableModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableModifiersContext() *VariableModifiersContext {
	var p = new(VariableModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableModifiers
	return p
}

func (*VariableModifiersContext) IsVariableModifiersContext() {}

func NewVariableModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifiersContext {
	var p = new(VariableModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableModifiers

	return p
}

func (s *VariableModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifiersContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *VariableModifiersContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *VariableModifiersContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *VariableModifiersContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableModifiers(s)
	}
}

func (s *VariableModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableModifiers(s)
	}
}

func (p *GroovyParser) VariableModifiers() (localctx IVariableModifiersContext) {
	this := p
	_ = this

	localctx = NewVariableModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, GroovyParserRULE_variableModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(385)
				p.VariableModifier()
			}
			{
				p.SetState(386)
				p.Nls()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(390)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeParameters
	return p
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *TypeParametersContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *TypeParametersContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeParametersContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParametersContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *TypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (p *GroovyParser) TypeParameters() (localctx ITypeParametersContext) {
	this := p
	_ = this

	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, GroovyParserRULE_typeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.Match(GroovyParserLT)
	}
	{
		p.SetState(393)
		p.Nls()
	}
	{
		p.SetState(394)
		p.TypeParameter()
	}
	p.SetState(401)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(395)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(396)
			p.Nls()
		}
		{
			p.SetState(397)
			p.TypeParameter()
		}

		p.SetState(403)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(404)
		p.Nls()
	}
	{
		p.SetState(405)
		p.Match(GroovyParserGT)
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) ClassName() IClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *TypeParameterContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *TypeParameterContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeParameterContext) TypeBound() ITypeBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeBoundContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *GroovyParser) TypeParameter() (localctx ITypeParameterContext) {
	this := p
	_ = this

	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, GroovyParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)
		p.ClassName()
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserEXTENDS {
		{
			p.SetState(408)
			p.Match(GroovyParserEXTENDS)
		}
		{
			p.SetState(409)
			p.Nls()
		}
		{
			p.SetState(410)
			p.TypeBound()
		}

	}

	return localctx
}

// ITypeBoundContext is an interface to support dynamic dispatch.
type ITypeBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeBoundContext differentiates from other interfaces.
	IsTypeBoundContext()
}

type TypeBoundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeBoundContext() *TypeBoundContext {
	var p = new(TypeBoundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeBound
	return p
}

func (*TypeBoundContext) IsTypeBoundContext() {}

func NewTypeBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeBoundContext {
	var p = new(TypeBoundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeBound

	return p
}

func (s *TypeBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeBoundContext) AllTypeType() []ITypeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeTypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeTypeContext); ok {
			tst[i] = t.(ITypeTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeBoundContext) TypeType(i int) ITypeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeBoundContext) AllBITAND() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserBITAND)
}

func (s *TypeBoundContext) BITAND(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserBITAND, i)
}

func (s *TypeBoundContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *TypeBoundContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeBound(s)
	}
}

func (s *TypeBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeBound(s)
	}
}

func (p *GroovyParser) TypeBound() (localctx ITypeBoundContext) {
	this := p
	_ = this

	localctx = NewTypeBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, GroovyParserRULE_typeBound)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.TypeType()
	}
	p.SetState(421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserBITAND {
		{
			p.SetState(415)
			p.Match(GroovyParserBITAND)
		}
		{
			p.SetState(416)
			p.Nls()
		}
		{
			p.SetState(417)
			p.TypeType()
		}

		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeList
	return p
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllTypeType() []ITypeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeTypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeTypeContext); ok {
			tst[i] = t.(ITypeTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) TypeType(i int) ITypeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeListContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (p *GroovyParser) TypeList() (localctx ITypeListContext) {
	this := p
	_ = this

	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, GroovyParserRULE_typeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.TypeType()
	}
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(425)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(426)
				p.Nls()
			}
			{
				p.SetState(427)
				p.TypeType()
			}

		}
		p.SetState(433)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetScs returns the scs rule contexts.
	GetScs() ITypeListContext

	// GetSc returns the sc rule contexts.
	GetSc() ITypeTypeContext

	// GetIs returns the is rule contexts.
	GetIs() ITypeListContext

	// SetScs sets the scs rule contexts.
	SetScs(ITypeListContext)

	// SetSc sets the sc rule contexts.
	SetSc(ITypeTypeContext)

	// SetIs sets the is rule contexts.
	SetIs(ITypeListContext)

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      int
	scs    ITypeListContext
	sc     ITypeTypeContext
	is     ITypeListContext
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) GetScs() ITypeListContext { return s.scs }

func (s *ClassDeclarationContext) GetSc() ITypeTypeContext { return s.sc }

func (s *ClassDeclarationContext) GetIs() ITypeListContext { return s.is }

func (s *ClassDeclarationContext) SetScs(v ITypeListContext) { s.scs = v }

func (s *ClassDeclarationContext) SetSc(v ITypeTypeContext) { s.sc = v }

func (s *ClassDeclarationContext) SetIs(v ITypeListContext) { s.is = v }

func (s *ClassDeclarationContext) GetT() int { return s.t }

func (s *ClassDeclarationContext) SetT(v int) { s.t = v }

func (s *ClassDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDeclarationContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(GroovyParserCLASS, 0)
}

func (s *ClassDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserINTERFACE, 0)
}

func (s *ClassDeclarationContext) ENUM() antlr.TerminalNode {
	return s.GetToken(GroovyParserENUM, 0)
}

func (s *ClassDeclarationContext) AT() antlr.TerminalNode {
	return s.GetToken(GroovyParserAT, 0)
}

func (s *ClassDeclarationContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *ClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *ClassDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPLEMENTS, 0)
}

func (s *ClassDeclarationContext) AllTypeList() []ITypeListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeListContext); ok {
			len++
		}
	}

	tst := make([]ITypeListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeListContext); ok {
			tst[i] = t.(ITypeListContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) TypeList(i int) ITypeListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ClassDeclarationContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *GroovyParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	this := p
	_ = this

	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, GroovyParserRULE_classDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(445)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserCLASS:
		{
			p.SetState(434)
			p.Match(GroovyParserCLASS)
		}
		localctx.(*ClassDeclarationContext).SetT(0)

	case GroovyParserINTERFACE:
		{
			p.SetState(436)
			p.Match(GroovyParserINTERFACE)
		}
		localctx.(*ClassDeclarationContext).SetT(1)

	case GroovyParserENUM:
		{
			p.SetState(438)
			p.Match(GroovyParserENUM)
		}
		localctx.(*ClassDeclarationContext).SetT(2)

	case GroovyParserAT:
		{
			p.SetState(440)
			p.Match(GroovyParserAT)
		}
		{
			p.SetState(441)
			p.Match(GroovyParserINTERFACE)
		}
		localctx.(*ClassDeclarationContext).SetT(3)

	case GroovyParserTRAIT:
		{
			p.SetState(443)
			p.Match(GroovyParserTRAIT)
		}
		localctx.(*ClassDeclarationContext).SetT(4)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(447)
		p.Identifier()
	}
	{
		p.SetState(448)
		p.Nls()
	}
	p.SetState(481)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.SetState(449)

		if !(3 != localctx.(*ClassDeclarationContext).t) {
			panic(antlr.NewFailedPredicateException(p, " 3 != $t ", ""))
		}
		p.SetState(451)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(450)
				p.TypeParameters()
			}

		}
		{
			p.SetState(453)
			p.Nls()
		}
		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
		case 1:
			p.SetState(454)

			if !(2 != localctx.(*ClassDeclarationContext).t) {
				panic(antlr.NewFailedPredicateException(p, " 2 != $t ", ""))
			}
			p.SetState(464)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(455)
					p.Match(GroovyParserEXTENDS)
				}
				{
					p.SetState(456)
					p.Nls()
				}
				p.SetState(460)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
				case 1:
					p.SetState(457)

					if !(1 == localctx.(*ClassDeclarationContext).t) {
						panic(antlr.NewFailedPredicateException(p, "1 == $t", ""))
					}
					{
						p.SetState(458)

						var _x = p.TypeList()

						localctx.(*ClassDeclarationContext).scs = _x
					}

				case 2:
					{
						p.SetState(459)

						var _x = p.TypeType()

						localctx.(*ClassDeclarationContext).sc = _x
					}

				}
				{
					p.SetState(462)
					p.Nls()
				}

			}

		case 2:

		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
		case 1:
			p.SetState(469)

			if !(1 != localctx.(*ClassDeclarationContext).t) {
				panic(antlr.NewFailedPredicateException(p, "1 != $t", ""))
			}
			p.SetState(475)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == GroovyParserIMPLEMENTS {
				{
					p.SetState(470)
					p.Match(GroovyParserIMPLEMENTS)
				}
				{
					p.SetState(471)
					p.Nls()
				}
				{
					p.SetState(472)

					var _x = p.TypeList()

					localctx.(*ClassDeclarationContext).is = _x
				}
				{
					p.SetState(473)
					p.Nls()
				}

			}

		case 2:

		}

	case 2:

	}
	{
		p.SetState(483)
		p.ClassBody(localctx.(*ClassDeclarationContext).t)
	}

	return localctx
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classBody
	return p
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classBody

	p.t = t

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) GetT() int { return s.t }

func (s *ClassBodyContext) SetT(v int) { s.t = v }

func (s *ClassBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *ClassBodyContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *ClassBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *ClassBodyContext) AllSep() []ISepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISepContext); ok {
			len++
		}
	}

	tst := make([]ISepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISepContext); ok {
			tst[i] = t.(ISepContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) Sep(i int) ISepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ClassBodyContext) EnumConstants() IEnumConstantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantsContext)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (p *GroovyParser) ClassBody(t int) (localctx IClassBodyContext) {
	this := p
	_ = this

	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 40, GroovyParserRULE_classBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(GroovyParserLBRACE)
	}
	{
		p.SetState(486)
		p.Nls()
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.SetState(487)

		if !(2 == localctx.(*ClassBodyContext).t) {
			panic(antlr.NewFailedPredicateException(p, " 2 == $t ", ""))
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(488)
				p.EnumConstants()
			}

		}
		p.SetState(492)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(491)
				p.Sep()
			}

		}

	case 2:

	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(497)
			p.ClassBodyDeclaration(localctx.(*ClassBodyContext).t)
		}

	}
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(500)
				p.Sep()
			}
			{
				p.SetState(501)
				p.ClassBodyDeclaration(localctx.(*ClassBodyContext).t)
			}

		}
		p.SetState(507)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserSEMI || _la == GroovyParserNL {
		{
			p.SetState(508)
			p.Sep()
		}

	}
	{
		p.SetState(511)
		p.Match(GroovyParserRBRACE)
	}

	return localctx
}

// IEnumConstantsContext is an interface to support dynamic dispatch.
type IEnumConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantsContext differentiates from other interfaces.
	IsEnumConstantsContext()
}

type EnumConstantsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantsContext() *EnumConstantsContext {
	var p = new(EnumConstantsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enumConstants
	return p
}

func (*EnumConstantsContext) IsEnumConstantsContext() {}

func NewEnumConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantsContext {
	var p = new(EnumConstantsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enumConstants

	return p
}

func (s *EnumConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantsContext) AllEnumConstant() []IEnumConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumConstantContext); ok {
			len++
		}
	}

	tst := make([]IEnumConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumConstantContext); ok {
			tst[i] = t.(IEnumConstantContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantsContext) EnumConstant(i int) IEnumConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantContext)
}

func (s *EnumConstantsContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantsContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *EnumConstantsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *EnumConstantsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *EnumConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnumConstants(s)
	}
}

func (s *EnumConstantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnumConstants(s)
	}
}

func (p *GroovyParser) EnumConstants() (localctx IEnumConstantsContext) {
	this := p
	_ = this

	localctx = NewEnumConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, GroovyParserRULE_enumConstants)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.EnumConstant()
	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(514)
				p.Nls()
			}
			{
				p.SetState(515)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(516)
				p.Nls()
			}
			{
				p.SetState(517)
				p.EnumConstant()
			}

		}
		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(524)
			p.Nls()
		}
		{
			p.SetState(525)
			p.Match(GroovyParserCOMMA)
		}

	}

	return localctx
}

// IEnumConstantContext is an interface to support dynamic dispatch.
type IEnumConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantContext differentiates from other interfaces.
	IsEnumConstantContext()
}

type EnumConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantContext() *EnumConstantContext {
	var p = new(EnumConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enumConstant
	return p
}

func (*EnumConstantContext) IsEnumConstantContext() {}

func NewEnumConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantContext {
	var p = new(EnumConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enumConstant

	return p
}

func (s *EnumConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *EnumConstantContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumConstantContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *EnumConstantContext) AnonymousInnerClassDeclaration() IAnonymousInnerClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousInnerClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousInnerClassDeclarationContext)
}

func (s *EnumConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnumConstant(s)
	}
}

func (s *EnumConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnumConstant(s)
	}
}

func (p *GroovyParser) EnumConstant() (localctx IEnumConstantContext) {
	this := p
	_ = this

	localctx = NewEnumConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, GroovyParserRULE_enumConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.AnnotationsOpt()
	}
	{
		p.SetState(530)
		p.Identifier()
	}
	p.SetState(532)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(531)
			p.Arguments()
		}

	}
	p.SetState(535)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(534)
			p.AnonymousInnerClassDeclaration(1)
		}

	}

	return localctx
}

// IClassBodyDeclarationContext is an interface to support dynamic dispatch.
type IClassBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsClassBodyDeclarationContext differentiates from other interfaces.
	IsClassBodyDeclarationContext()
}

type ClassBodyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyClassBodyDeclarationContext() *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classBodyDeclaration
	return p
}

func (*ClassBodyDeclarationContext) IsClassBodyDeclarationContext() {}

func NewClassBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classBodyDeclaration

	p.t = t

	return p
}

func (s *ClassBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyDeclarationContext) GetT() int { return s.t }

func (s *ClassBodyDeclarationContext) SetT(v int) { s.t = v }

func (s *ClassBodyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(GroovyParserSEMI, 0)
}

func (s *ClassBodyDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ClassBodyDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *ClassBodyDeclarationContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassBodyDeclarationContext) MemberDeclaration() IMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberDeclarationContext)
}

func (s *ClassBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassBodyDeclaration(s)
	}
}

func (p *GroovyParser) ClassBodyDeclaration(t int) (localctx IClassBodyDeclarationContext) {
	this := p
	_ = this

	localctx = NewClassBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 46, GroovyParserRULE_classBodyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(537)
			p.Match(GroovyParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserSTATIC {
			{
				p.SetState(538)
				p.Match(GroovyParserSTATIC)
			}
			{
				p.SetState(539)
				p.Nls()
			}

		}
		{
			p.SetState(542)
			p.Block()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(543)
			p.MemberDeclaration(localctx.(*ClassBodyDeclarationContext).t)
		}

	}

	return localctx
}

// IMemberDeclarationContext is an interface to support dynamic dispatch.
type IMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsMemberDeclarationContext differentiates from other interfaces.
	IsMemberDeclarationContext()
}

type MemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyMemberDeclarationContext() *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_memberDeclaration
	return p
}

func (*MemberDeclarationContext) IsMemberDeclarationContext() {}

func NewMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_memberDeclaration

	p.t = t

	return p
}

func (s *MemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDeclarationContext) GetT() int { return s.t }

func (s *MemberDeclarationContext) SetT(v int) { s.t = v }

func (s *MemberDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *MemberDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *MemberDeclarationContext) ModifiersOpt() IModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersOptContext)
}

func (s *MemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *MemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMemberDeclaration(s)
	}
}

func (s *MemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMemberDeclaration(s)
	}
}

func (p *GroovyParser) MemberDeclaration(t int) (localctx IMemberDeclarationContext) {
	this := p
	_ = this

	localctx = NewMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 48, GroovyParserRULE_memberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(546)
			p.MethodDeclaration(0, localctx.(*MemberDeclarationContext).t)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(547)
			p.FieldDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(548)
			p.ModifiersOpt()
		}
		{
			p.SetState(549)
			p.ClassDeclaration()
		}

	}

	return localctx
}

// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// GetCt returns the ct attribute.
	GetCt() int

	// SetT sets the t attribute.
	SetT(int)

	// SetCt sets the ct attribute.
	SetCt(int)

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      int
	ct     int
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_methodDeclaration
	return p
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int, ct int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_methodDeclaration

	p.t = t
	p.ct = ct

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) GetT() int { return s.t }

func (s *MethodDeclarationContext) GetCt() int { return s.ct }

func (s *MethodDeclarationContext) SetT(v int) { s.t = v }

func (s *MethodDeclarationContext) SetCt(v int) { s.ct = v }

func (s *MethodDeclarationContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *MethodDeclarationContext) MethodName() IMethodNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodNameContext)
}

func (s *MethodDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *MethodDeclarationContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *MethodDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *MethodDeclarationContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *MethodDeclarationContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MethodDeclarationContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *MethodDeclarationContext) ModifiersOpt() IModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersOptContext)
}

func (s *MethodDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *MethodDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *MethodDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROWS, 0)
}

func (s *MethodDeclarationContext) QualifiedClassNameList() IQualifiedClassNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameListContext)
}

func (s *MethodDeclarationContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMethodDeclaration(s)
	}
}

func (p *GroovyParser) MethodDeclaration(t int, ct int) (localctx IMethodDeclarationContext) {
	this := p
	_ = this

	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t, ct)
	p.EnterRule(localctx, 50, GroovyParserRULE_methodDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(584)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(553)

		if !(3 == localctx.(*MethodDeclarationContext).ct) {
			panic(antlr.NewFailedPredicateException(p, " 3 == $ct ", ""))
		}
		{
			p.SetState(554)
			p.ReturnType(localctx.(*MethodDeclarationContext).ct)
		}
		{
			p.SetState(555)
			p.MethodName()
		}
		{
			p.SetState(556)
			p.Match(GroovyParserLPAREN)
		}
		{
			p.SetState(557)
			p.Rparen()
		}
		p.SetState(562)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(558)
				p.Match(GroovyParserDEFAULT)
			}
			{
				p.SetState(559)
				p.Nls()
			}
			{
				p.SetState(560)
				p.ElementValue()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(564)
			p.ModifiersOpt()
		}
		p.SetState(566)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(565)
				p.TypeParameters()
			}

		}
		p.SetState(569)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(568)
				p.ReturnType(localctx.(*MethodDeclarationContext).ct)
			}

		}
		{
			p.SetState(571)
			p.MethodName()
		}
		{
			p.SetState(572)
			p.FormalParameters()
		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(573)
				p.Nls()
			}
			{
				p.SetState(574)
				p.Match(GroovyParserTHROWS)
			}
			{
				p.SetState(575)
				p.Nls()
			}
			{
				p.SetState(576)
				p.QualifiedClassNameList()
			}

		}
		{
			p.SetState(580)
			p.Nls()
		}
		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserLBRACE {
			{
				p.SetState(581)
				p.MethodBody()
			}

		}

	}

	return localctx
}

// IMethodNameContext is an interface to support dynamic dispatch.
type IMethodNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodNameContext differentiates from other interfaces.
	IsMethodNameContext()
}

type MethodNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodNameContext() *MethodNameContext {
	var p = new(MethodNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_methodName
	return p
}

func (*MethodNameContext) IsMethodNameContext() {}

func NewMethodNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodNameContext {
	var p = new(MethodNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_methodName

	return p
}

func (s *MethodNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodNameContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *MethodNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMethodName(s)
	}
}

func (s *MethodNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMethodName(s)
	}
}

func (p *GroovyParser) MethodName() (localctx IMethodNameContext) {
	this := p
	_ = this

	localctx = NewMethodNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, GroovyParserRULE_methodName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(588)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAS, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserSTATIC, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(586)
			p.Identifier()
		}

	case GroovyParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(587)
			p.StringLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReturnTypeContext is an interface to support dynamic dispatch.
type IReturnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCt returns the ct attribute.
	GetCt() int

	// SetCt sets the ct attribute.
	SetCt(int)

	// IsReturnTypeContext differentiates from other interfaces.
	IsReturnTypeContext()
}

type ReturnTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	ct     int
}

func NewEmptyReturnTypeContext() *ReturnTypeContext {
	var p = new(ReturnTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_returnType
	return p
}

func (*ReturnTypeContext) IsReturnTypeContext() {}

func NewReturnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, ct int) *ReturnTypeContext {
	var p = new(ReturnTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_returnType

	p.ct = ct

	return p
}

func (s *ReturnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeContext) GetCt() int { return s.ct }

func (s *ReturnTypeContext) SetCt(v int) { s.ct = v }

func (s *ReturnTypeContext) StandardType() IStandardTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardTypeContext)
}

func (s *ReturnTypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *ReturnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterReturnType(s)
	}
}

func (s *ReturnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitReturnType(s)
	}
}

func (p *GroovyParser) ReturnType(ct int) (localctx IReturnTypeContext) {
	this := p
	_ = this

	localctx = NewReturnTypeContext(p, p.GetParserRuleContext(), p.GetState(), ct)
	p.EnterRule(localctx, 54, GroovyParserRULE_returnType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(590)
			p.StandardType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(591)

		if !(3 != localctx.(*ReturnTypeContext).ct) {
			panic(antlr.NewFailedPredicateException(p, " 3 != $ct ", ""))
		}
		{
			p.SetState(592)
			p.Match(GroovyParserVOID)
		}

	}

	return localctx
}

// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_fieldDeclaration
	return p
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFieldDeclaration(s)
	}
}

func (p *GroovyParser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	this := p
	_ = this

	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, GroovyParserRULE_fieldDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(595)
		p.VariableDeclaration(1)
	}

	return localctx
}

// IVariableDeclaratorsContext is an interface to support dynamic dispatch.
type IVariableDeclaratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorsContext differentiates from other interfaces.
	IsVariableDeclaratorsContext()
}

type VariableDeclaratorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorsContext() *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableDeclarators
	return p
}

func (*VariableDeclaratorsContext) IsVariableDeclaratorsContext() {}

func NewVariableDeclaratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclarators

	return p
}

func (s *VariableDeclaratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorsContext) AllVariableDeclarator() []IVariableDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclaratorContext); ok {
			tst[i] = t.(IVariableDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclaratorsContext) VariableDeclarator(i int) IVariableDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorContext)
}

func (s *VariableDeclaratorsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *VariableDeclaratorsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *VariableDeclaratorsContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclaratorsContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableDeclaratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableDeclarators(s)
	}
}

func (s *VariableDeclaratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableDeclarators(s)
	}
}

func (p *GroovyParser) VariableDeclarators() (localctx IVariableDeclaratorsContext) {
	this := p
	_ = this

	localctx = NewVariableDeclaratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, GroovyParserRULE_variableDeclarators)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		p.VariableDeclarator()
	}
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(598)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(599)
			p.Nls()
		}
		{
			p.SetState(600)
			p.VariableDeclarator()
		}

		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVariableDeclaratorContext is an interface to support dynamic dispatch.
type IVariableDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorContext differentiates from other interfaces.
	IsVariableDeclaratorContext()
}

type VariableDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorContext() *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableDeclarator
	return p
}

func (*VariableDeclaratorContext) IsVariableDeclaratorContext() {}

func NewVariableDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclarator

	return p
}

func (s *VariableDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *VariableDeclaratorContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclaratorContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableDeclaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *VariableDeclaratorContext) VariableInitializer() IVariableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableDeclarator(s)
	}
}

func (s *VariableDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableDeclarator(s)
	}
}

func (p *GroovyParser) VariableDeclarator() (localctx IVariableDeclaratorContext) {
	this := p
	_ = this

	localctx = NewVariableDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, GroovyParserRULE_variableDeclarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.VariableDeclaratorId()
	}
	p.SetState(613)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(608)
			p.Nls()
		}
		{
			p.SetState(609)
			p.Match(GroovyParserASSIGN)
		}
		{
			p.SetState(610)
			p.Nls()
		}
		{
			p.SetState(611)
			p.VariableInitializer()
		}

	}

	return localctx
}

// IVariableDeclaratorIdContext is an interface to support dynamic dispatch.
type IVariableDeclaratorIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorIdContext differentiates from other interfaces.
	IsVariableDeclaratorIdContext()
}

type VariableDeclaratorIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorIdContext() *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableDeclaratorId
	return p
}

func (*VariableDeclaratorIdContext) IsVariableDeclaratorIdContext() {}

func NewVariableDeclaratorIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclaratorId

	return p
}

func (s *VariableDeclaratorIdContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorIdContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclaratorIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableDeclaratorId(s)
	}
}

func (s *VariableDeclaratorIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableDeclaratorId(s)
	}
}

func (p *GroovyParser) VariableDeclaratorId() (localctx IVariableDeclaratorIdContext) {
	this := p
	_ = this

	localctx = NewVariableDeclaratorIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, GroovyParserRULE_variableDeclaratorId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		p.Identifier()
	}

	return localctx
}

// IVariableInitializerContext is an interface to support dynamic dispatch.
type IVariableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitializerContext differentiates from other interfaces.
	IsVariableInitializerContext()
}

type VariableInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerContext() *VariableInitializerContext {
	var p = new(VariableInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableInitializer
	return p
}

func (*VariableInitializerContext) IsVariableInitializerContext() {}

func NewVariableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerContext {
	var p = new(VariableInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableInitializer

	return p
}

func (s *VariableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerContext) EnhancedStatementExpression() IEnhancedStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedStatementExpressionContext)
}

func (s *VariableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableInitializer(s)
	}
}

func (s *VariableInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableInitializer(s)
	}
}

func (p *GroovyParser) VariableInitializer() (localctx IVariableInitializerContext) {
	this := p
	_ = this

	localctx = NewVariableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, GroovyParserRULE_variableInitializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.EnhancedStatementExpression()
	}

	return localctx
}

// IVariableInitializersContext is an interface to support dynamic dispatch.
type IVariableInitializersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitializersContext differentiates from other interfaces.
	IsVariableInitializersContext()
}

type VariableInitializersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializersContext() *VariableInitializersContext {
	var p = new(VariableInitializersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableInitializers
	return p
}

func (*VariableInitializersContext) IsVariableInitializersContext() {}

func NewVariableInitializersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializersContext {
	var p = new(VariableInitializersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableInitializers

	return p
}

func (s *VariableInitializersContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializersContext) AllVariableInitializer() []IVariableInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			len++
		}
	}

	tst := make([]IVariableInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableInitializerContext); ok {
			tst[i] = t.(IVariableInitializerContext)
			i++
		}
	}

	return tst
}

func (s *VariableInitializersContext) VariableInitializer(i int) IVariableInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableInitializersContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *VariableInitializersContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableInitializersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *VariableInitializersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *VariableInitializersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableInitializers(s)
	}
}

func (s *VariableInitializersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableInitializers(s)
	}
}

func (p *GroovyParser) VariableInitializers() (localctx IVariableInitializersContext) {
	this := p
	_ = this

	localctx = NewVariableInitializersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, GroovyParserRULE_variableInitializers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(619)
		p.VariableInitializer()
	}
	{
		p.SetState(620)
		p.Nls()
	}
	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(621)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(622)
				p.Nls()
			}
			{
				p.SetState(623)
				p.VariableInitializer()
			}
			{
				p.SetState(624)
				p.Nls()
			}

		}
		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
	}
	{
		p.SetState(631)
		p.Nls()
	}
	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserCOMMA {
		{
			p.SetState(632)
			p.Match(GroovyParserCOMMA)
		}

	}

	return localctx
}

// IDimsContext is an interface to support dynamic dispatch.
type IDimsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimsContext differentiates from other interfaces.
	IsDimsContext()
}

type DimsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimsContext() *DimsContext {
	var p = new(DimsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_dims
	return p
}

func (*DimsContext) IsDimsContext() {}

func NewDimsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimsContext {
	var p = new(DimsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_dims

	return p
}

func (s *DimsContext) GetParser() antlr.Parser { return s.parser }

func (s *DimsContext) AllAnnotationsOpt() []IAnnotationsOptContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationsOptContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationsOptContext); ok {
			tst[i] = t.(IAnnotationsOptContext)
			i++
		}
	}

	return tst
}

func (s *DimsContext) AnnotationsOpt(i int) IAnnotationsOptContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *DimsContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserLBRACK)
}

func (s *DimsContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, i)
}

func (s *DimsContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserRBRACK)
}

func (s *DimsContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, i)
}

func (s *DimsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterDims(s)
	}
}

func (s *DimsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitDims(s)
	}
}

func (p *GroovyParser) Dims() (localctx IDimsContext) {
	this := p
	_ = this

	localctx = NewDimsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, GroovyParserRULE_dims)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(639)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(635)
				p.AnnotationsOpt()
			}
			{
				p.SetState(636)
				p.Match(GroovyParserLBRACK)
			}
			{
				p.SetState(637)
				p.Match(GroovyParserRBRACK)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(641)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())
	}

	return localctx
}

// IDimsOptContext is an interface to support dynamic dispatch.
type IDimsOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimsOptContext differentiates from other interfaces.
	IsDimsOptContext()
}

type DimsOptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimsOptContext() *DimsOptContext {
	var p = new(DimsOptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_dimsOpt
	return p
}

func (*DimsOptContext) IsDimsOptContext() {}

func NewDimsOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimsOptContext {
	var p = new(DimsOptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_dimsOpt

	return p
}

func (s *DimsOptContext) GetParser() antlr.Parser { return s.parser }

func (s *DimsOptContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *DimsOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimsOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimsOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterDimsOpt(s)
	}
}

func (s *DimsOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitDimsOpt(s)
	}
}

func (p *GroovyParser) DimsOpt() (localctx IDimsOptContext) {
	this := p
	_ = this

	localctx = NewDimsOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, GroovyParserRULE_dimsOpt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(644)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(643)
			p.Dims()
		}

	}

	return localctx
}

// IStandardTypeContext is an interface to support dynamic dispatch.
type IStandardTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandardTypeContext differentiates from other interfaces.
	IsStandardTypeContext()
}

type StandardTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardTypeContext() *StandardTypeContext {
	var p = new(StandardTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_standardType
	return p
}

func (*StandardTypeContext) IsStandardTypeContext() {}

func NewStandardTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardTypeContext {
	var p = new(StandardTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardType

	return p
}

func (s *StandardTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardTypeContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *StandardTypeContext) DimsOpt() IDimsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsOptContext)
}

func (s *StandardTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *StandardTypeContext) StandardClassOrInterfaceType() IStandardClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardClassOrInterfaceTypeContext)
}

func (s *StandardTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStandardType(s)
	}
}

func (s *StandardTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStandardType(s)
	}
}

func (p *GroovyParser) StandardType() (localctx IStandardTypeContext) {
	this := p
	_ = this

	localctx = NewStandardTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, GroovyParserRULE_standardType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.AnnotationsOpt()
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserBuiltInPrimitiveType:
		{
			p.SetState(647)
			p.PrimitiveType()
		}

	case GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserSTATIC, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		{
			p.SetState(648)
			p.StandardClassOrInterfaceType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(651)
		p.DimsOpt()
	}

	return localctx
}

// ITypeTypeContext is an interface to support dynamic dispatch.
type ITypeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeTypeContext differentiates from other interfaces.
	IsTypeTypeContext()
}

type TypeTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTypeContext() *TypeTypeContext {
	var p = new(TypeTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeType
	return p
}

func (*TypeTypeContext) IsTypeTypeContext() {}

func NewTypeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTypeContext {
	var p = new(TypeTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeType

	return p
}

func (s *TypeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTypeContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *TypeTypeContext) DimsOpt() IDimsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsOptContext)
}

func (s *TypeTypeContext) GeneralClassOrInterfaceType() IGeneralClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralClassOrInterfaceTypeContext)
}

func (s *TypeTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeTypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *TypeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeType(s)
	}
}

func (s *TypeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeType(s)
	}
}

func (p *GroovyParser) TypeType() (localctx ITypeTypeContext) {
	this := p
	_ = this

	localctx = NewTypeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, GroovyParserRULE_typeType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(653)
		p.AnnotationsOpt()
	}
	p.SetState(659)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserBuiltInPrimitiveType, GroovyParserVOID:
		p.SetState(656)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case GroovyParserBuiltInPrimitiveType:
			{
				p.SetState(654)
				p.PrimitiveType()
			}

		case GroovyParserVOID:
			{
				p.SetState(655)
				p.Match(GroovyParserVOID)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserSTATIC, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		{
			p.SetState(658)
			p.GeneralClassOrInterfaceType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(661)
		p.DimsOpt()
	}

	return localctx
}

// IClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceTypeContext differentiates from other interfaces.
	IsClassOrInterfaceTypeContext()
}

type ClassOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceTypeContext() *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classOrInterfaceType
	return p
}

func (*ClassOrInterfaceTypeContext) IsClassOrInterfaceTypeContext() {}

func NewClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classOrInterfaceType

	return p
}

func (s *ClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceTypeContext) QualifiedClassName() IQualifiedClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *ClassOrInterfaceTypeContext) QualifiedStandardClassName() IQualifiedStandardClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStandardClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStandardClassNameContext)
}

func (s *ClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassOrInterfaceType(s)
	}
}

func (s *ClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassOrInterfaceType(s)
	}
}

func (p *GroovyParser) ClassOrInterfaceType() (localctx IClassOrInterfaceTypeContext) {
	this := p
	_ = this

	localctx = NewClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, GroovyParserRULE_classOrInterfaceType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(663)
			p.QualifiedClassName()
		}

	case 2:
		{
			p.SetState(664)
			p.QualifiedStandardClassName()
		}

	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserLT {
		{
			p.SetState(667)
			p.TypeArguments()
		}

	}

	return localctx
}

// IGeneralClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IGeneralClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneralClassOrInterfaceTypeContext differentiates from other interfaces.
	IsGeneralClassOrInterfaceTypeContext()
}

type GeneralClassOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralClassOrInterfaceTypeContext() *GeneralClassOrInterfaceTypeContext {
	var p = new(GeneralClassOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_generalClassOrInterfaceType
	return p
}

func (*GeneralClassOrInterfaceTypeContext) IsGeneralClassOrInterfaceTypeContext() {}

func NewGeneralClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralClassOrInterfaceTypeContext {
	var p = new(GeneralClassOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_generalClassOrInterfaceType

	return p
}

func (s *GeneralClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralClassOrInterfaceTypeContext) QualifiedClassName() IQualifiedClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *GeneralClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *GeneralClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterGeneralClassOrInterfaceType(s)
	}
}

func (s *GeneralClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitGeneralClassOrInterfaceType(s)
	}
}

func (p *GroovyParser) GeneralClassOrInterfaceType() (localctx IGeneralClassOrInterfaceTypeContext) {
	this := p
	_ = this

	localctx = NewGeneralClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, GroovyParserRULE_generalClassOrInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.QualifiedClassName()
	}
	p.SetState(672)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(671)
			p.TypeArguments()
		}

	}

	return localctx
}

// IStandardClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IStandardClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandardClassOrInterfaceTypeContext differentiates from other interfaces.
	IsStandardClassOrInterfaceTypeContext()
}

type StandardClassOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardClassOrInterfaceTypeContext() *StandardClassOrInterfaceTypeContext {
	var p = new(StandardClassOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_standardClassOrInterfaceType
	return p
}

func (*StandardClassOrInterfaceTypeContext) IsStandardClassOrInterfaceTypeContext() {}

func NewStandardClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardClassOrInterfaceTypeContext {
	var p = new(StandardClassOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardClassOrInterfaceType

	return p
}

func (s *StandardClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardClassOrInterfaceTypeContext) QualifiedStandardClassName() IQualifiedStandardClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStandardClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStandardClassNameContext)
}

func (s *StandardClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *StandardClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStandardClassOrInterfaceType(s)
	}
}

func (s *StandardClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStandardClassOrInterfaceType(s)
	}
}

func (p *GroovyParser) StandardClassOrInterfaceType() (localctx IStandardClassOrInterfaceTypeContext) {
	this := p
	_ = this

	localctx = NewStandardClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, GroovyParserRULE_standardClassOrInterfaceType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(674)
		p.QualifiedStandardClassName()
	}
	p.SetState(676)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserLT {
		{
			p.SetState(675)
			p.TypeArguments()
		}

	}

	return localctx
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_primitiveType
	return p
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) BuiltInPrimitiveType() antlr.TerminalNode {
	return s.GetToken(GroovyParserBuiltInPrimitiveType, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (p *GroovyParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	this := p
	_ = this

	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, GroovyParserRULE_primitiveType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Match(GroovyParserBuiltInPrimitiveType)
	}

	return localctx
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeArguments
	return p
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *TypeArgumentsContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentsContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeArgumentsContext) AllTypeArgument() []ITypeArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentContext); ok {
			tst[i] = t.(ITypeArgumentContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentsContext) TypeArgument(i int) ITypeArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentContext)
}

func (s *TypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *TypeArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (p *GroovyParser) TypeArguments() (localctx ITypeArgumentsContext) {
	this := p
	_ = this

	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, GroovyParserRULE_typeArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(GroovyParserLT)
	}
	{
		p.SetState(681)
		p.Nls()
	}
	{
		p.SetState(682)
		p.TypeArgument()
	}
	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(683)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(684)
			p.Nls()
		}
		{
			p.SetState(685)
			p.TypeArgument()
		}

		p.SetState(691)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(692)
		p.Nls()
	}
	{
		p.SetState(693)
		p.Match(GroovyParserGT)
	}

	return localctx
}

// ITypeArgumentContext is an interface to support dynamic dispatch.
type ITypeArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentContext differentiates from other interfaces.
	IsTypeArgumentContext()
}

type TypeArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentContext() *TypeArgumentContext {
	var p = new(TypeArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeArgument
	return p
}

func (*TypeArgumentContext) IsTypeArgumentContext() {}

func NewTypeArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentContext {
	var p = new(TypeArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeArgument

	return p
}

func (s *TypeArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeArgumentContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *TypeArgumentContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(GroovyParserQUESTION, 0)
}

func (s *TypeArgumentContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeArgumentContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *TypeArgumentContext) SUPER() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUPER, 0)
}

func (s *TypeArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeArgument(s)
	}
}

func (s *TypeArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeArgument(s)
	}
}

func (p *GroovyParser) TypeArgument() (localctx ITypeArgumentContext) {
	this := p
	_ = this

	localctx = NewTypeArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, GroovyParserRULE_typeArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(695)
			p.TypeType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(696)
			p.AnnotationsOpt()
		}
		{
			p.SetState(697)
			p.Match(GroovyParserQUESTION)
		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserEXTENDS || _la == GroovyParserSUPER {
			{
				p.SetState(698)
				_la = p.GetTokenStream().LA(1)

				if !(_la == GroovyParserEXTENDS || _la == GroovyParserSUPER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(699)
				p.Nls()
			}
			{
				p.SetState(700)
				p.TypeType()
			}

		}

	}

	return localctx
}

// IAnnotatedQualifiedClassNameContext is an interface to support dynamic dispatch.
type IAnnotatedQualifiedClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotatedQualifiedClassNameContext differentiates from other interfaces.
	IsAnnotatedQualifiedClassNameContext()
}

type AnnotatedQualifiedClassNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotatedQualifiedClassNameContext() *AnnotatedQualifiedClassNameContext {
	var p = new(AnnotatedQualifiedClassNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_annotatedQualifiedClassName
	return p
}

func (*AnnotatedQualifiedClassNameContext) IsAnnotatedQualifiedClassNameContext() {}

func NewAnnotatedQualifiedClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotatedQualifiedClassNameContext {
	var p = new(AnnotatedQualifiedClassNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotatedQualifiedClassName

	return p
}

func (s *AnnotatedQualifiedClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotatedQualifiedClassNameContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *AnnotatedQualifiedClassNameContext) QualifiedClassName() IQualifiedClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *AnnotatedQualifiedClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotatedQualifiedClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotatedQualifiedClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAnnotatedQualifiedClassName(s)
	}
}

func (s *AnnotatedQualifiedClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAnnotatedQualifiedClassName(s)
	}
}

func (p *GroovyParser) AnnotatedQualifiedClassName() (localctx IAnnotatedQualifiedClassNameContext) {
	this := p
	_ = this

	localctx = NewAnnotatedQualifiedClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, GroovyParserRULE_annotatedQualifiedClassName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.AnnotationsOpt()
	}
	{
		p.SetState(707)
		p.QualifiedClassName()
	}

	return localctx
}

// IQualifiedClassNameListContext is an interface to support dynamic dispatch.
type IQualifiedClassNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedClassNameListContext differentiates from other interfaces.
	IsQualifiedClassNameListContext()
}

type QualifiedClassNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedClassNameListContext() *QualifiedClassNameListContext {
	var p = new(QualifiedClassNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedClassNameList
	return p
}

func (*QualifiedClassNameListContext) IsQualifiedClassNameListContext() {}

func NewQualifiedClassNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedClassNameListContext {
	var p = new(QualifiedClassNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedClassNameList

	return p
}

func (s *QualifiedClassNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedClassNameListContext) AllAnnotatedQualifiedClassName() []IAnnotatedQualifiedClassNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotatedQualifiedClassNameContext); ok {
			len++
		}
	}

	tst := make([]IAnnotatedQualifiedClassNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotatedQualifiedClassNameContext); ok {
			tst[i] = t.(IAnnotatedQualifiedClassNameContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedClassNameListContext) AnnotatedQualifiedClassName(i int) IAnnotatedQualifiedClassNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotatedQualifiedClassNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotatedQualifiedClassNameContext)
}

func (s *QualifiedClassNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *QualifiedClassNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *QualifiedClassNameListContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedClassNameListContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *QualifiedClassNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedClassNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedClassNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedClassNameList(s)
	}
}

func (s *QualifiedClassNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedClassNameList(s)
	}
}

func (p *GroovyParser) QualifiedClassNameList() (localctx IQualifiedClassNameListContext) {
	this := p
	_ = this

	localctx = NewQualifiedClassNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, GroovyParserRULE_qualifiedClassNameList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.AnnotatedQualifiedClassName()
	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(710)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(711)
			p.Nls()
		}
		{
			p.SetState(712)
			p.AnnotatedQualifiedClassName()
		}

		p.SetState(718)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFormalParametersContext is an interface to support dynamic dispatch.
type IFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParametersContext differentiates from other interfaces.
	IsFormalParametersContext()
}

type FormalParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParametersContext() *FormalParametersContext {
	var p = new(FormalParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_formalParameters
	return p
}

func (*FormalParametersContext) IsFormalParametersContext() {}

func NewFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParametersContext {
	var p = new(FormalParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_formalParameters

	return p
}

func (s *FormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *FormalParametersContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *FormalParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFormalParameters(s)
	}
}

func (s *FormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFormalParameters(s)
	}
}

func (p *GroovyParser) FormalParameters() (localctx IFormalParametersContext) {
	this := p
	_ = this

	localctx = NewFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, GroovyParserRULE_formalParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(719)
		p.Match(GroovyParserLPAREN)
	}
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9037435958753152) != 0 || (int64((_la-122)) & ^0x3f) == 0 && ((int64(1)<<(_la-122))&15) != 0 {
		{
			p.SetState(720)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(723)
		p.Rparen()
	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterContext); ok {
			tst[i] = t.(IFormalParameterContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) ThisFormalParameter() IThisFormalParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThisFormalParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThisFormalParameterContext)
}

func (s *FormalParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *FormalParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *FormalParameterListContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (p *GroovyParser) FormalParameterList() (localctx IFormalParameterListContext) {
	this := p
	_ = this

	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, GroovyParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(725)
			p.FormalParameter()
		}

	case 2:
		{
			p.SetState(726)
			p.ThisFormalParameter()
		}

	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(729)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(730)
			p.Nls()
		}
		{
			p.SetState(731)
			p.FormalParameter()
		}

		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IThisFormalParameterContext is an interface to support dynamic dispatch.
type IThisFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThisFormalParameterContext differentiates from other interfaces.
	IsThisFormalParameterContext()
}

type ThisFormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThisFormalParameterContext() *ThisFormalParameterContext {
	var p = new(ThisFormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_thisFormalParameter
	return p
}

func (*ThisFormalParameterContext) IsThisFormalParameterContext() {}

func NewThisFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThisFormalParameterContext {
	var p = new(ThisFormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_thisFormalParameter

	return p
}

func (s *ThisFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ThisFormalParameterContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ThisFormalParameterContext) THIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHIS, 0)
}

func (s *ThisFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThisFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterThisFormalParameter(s)
	}
}

func (s *ThisFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitThisFormalParameter(s)
	}
}

func (p *GroovyParser) ThisFormalParameter() (localctx IThisFormalParameterContext) {
	this := p
	_ = this

	localctx = NewThisFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, GroovyParserRULE_thisFormalParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.TypeType()
	}
	{
		p.SetState(739)
		p.Match(GroovyParserTHIS)
	}

	return localctx
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_formalParameter
	return p
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) VariableModifiersOpt() IVariableModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersOptContext)
}

func (s *FormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *FormalParameterContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *FormalParameterContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserELLIPSIS, 0)
}

func (s *FormalParameterContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *FormalParameterContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *FormalParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFormalParameter(s)
	}
}

func (s *FormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFormalParameter(s)
	}
}

func (p *GroovyParser) FormalParameter() (localctx IFormalParameterContext) {
	this := p
	_ = this

	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, GroovyParserRULE_formalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.VariableModifiersOpt()
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(742)
			p.TypeType()
		}

	}
	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserELLIPSIS {
		{
			p.SetState(745)
			p.Match(GroovyParserELLIPSIS)
		}

	}
	{
		p.SetState(748)
		p.VariableDeclaratorId()
	}
	p.SetState(754)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(749)
			p.Nls()
		}
		{
			p.SetState(750)
			p.Match(GroovyParserASSIGN)
		}
		{
			p.SetState(751)
			p.Nls()
		}
		{
			p.SetState(752)
			p.expression(0)
		}

	}

	return localctx
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_methodBody
	return p
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMethodBody(s)
	}
}

func (s *MethodBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMethodBody(s)
	}
}

func (p *GroovyParser) MethodBody() (localctx IMethodBodyContext) {
	this := p
	_ = this

	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, GroovyParserRULE_methodBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(756)
		p.Block()
	}

	return localctx
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedName
	return p
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllQualifiedNameElement() []IQualifiedNameElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameElementContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameElementContext); ok {
			tst[i] = t.(IQualifiedNameElementContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) QualifiedNameElement(i int) IQualifiedNameElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (p *GroovyParser) QualifiedName() (localctx IQualifiedNameContext) {
	this := p
	_ = this

	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, GroovyParserRULE_qualifiedName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.QualifiedNameElement()
	}
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(759)
				p.Match(GroovyParserDOT)
			}
			{
				p.SetState(760)
				p.QualifiedNameElement()
			}

		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())
	}

	return localctx
}

// IQualifiedNameElementContext is an interface to support dynamic dispatch.
type IQualifiedNameElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameElementContext differentiates from other interfaces.
	IsQualifiedNameElementContext()
}

type QualifiedNameElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameElementContext() *QualifiedNameElementContext {
	var p = new(QualifiedNameElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedNameElement
	return p
}

func (*QualifiedNameElementContext) IsQualifiedNameElementContext() {}

func NewQualifiedNameElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameElementContext {
	var p = new(QualifiedNameElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedNameElement

	return p
}

func (s *QualifiedNameElementContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameElementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameElementContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *QualifiedNameElementContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *QualifiedNameElementContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *QualifiedNameElementContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *QualifiedNameElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedNameElement(s)
	}
}

func (s *QualifiedNameElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedNameElement(s)
	}
}

func (p *GroovyParser) QualifiedNameElement() (localctx IQualifiedNameElementContext) {
	this := p
	_ = this

	localctx = NewQualifiedNameElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, GroovyParserRULE_qualifiedNameElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(766)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(767)
			p.Match(GroovyParserDEF)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(768)
			p.Match(GroovyParserIN)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(769)
			p.Match(GroovyParserAS)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(770)
			p.Match(GroovyParserTRAIT)
		}

	}

	return localctx
}

// IQualifiedNameElementsContext is an interface to support dynamic dispatch.
type IQualifiedNameElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameElementsContext differentiates from other interfaces.
	IsQualifiedNameElementsContext()
}

type QualifiedNameElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameElementsContext() *QualifiedNameElementsContext {
	var p = new(QualifiedNameElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedNameElements
	return p
}

func (*QualifiedNameElementsContext) IsQualifiedNameElementsContext() {}

func NewQualifiedNameElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameElementsContext {
	var p = new(QualifiedNameElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedNameElements

	return p
}

func (s *QualifiedNameElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameElementsContext) AllQualifiedNameElement() []IQualifiedNameElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameElementContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameElementContext); ok {
			tst[i] = t.(IQualifiedNameElementContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameElementsContext) QualifiedNameElement(i int) IQualifiedNameElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementContext)
}

func (s *QualifiedNameElementsContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserDOT)
}

func (s *QualifiedNameElementsContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, i)
}

func (s *QualifiedNameElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedNameElements(s)
	}
}

func (s *QualifiedNameElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedNameElements(s)
	}
}

func (p *GroovyParser) QualifiedNameElements() (localctx IQualifiedNameElementsContext) {
	this := p
	_ = this

	localctx = NewQualifiedNameElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, GroovyParserRULE_qualifiedNameElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(773)
				p.QualifiedNameElement()
			}
			{
				p.SetState(774)
				p.Match(GroovyParserDOT)
			}

		}
		p.SetState(780)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
	}

	return localctx
}

// IQualifiedClassNameContext is an interface to support dynamic dispatch.
type IQualifiedClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedClassNameContext differentiates from other interfaces.
	IsQualifiedClassNameContext()
}

type QualifiedClassNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedClassNameContext() *QualifiedClassNameContext {
	var p = new(QualifiedClassNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedClassName
	return p
}

func (*QualifiedClassNameContext) IsQualifiedClassNameContext() {}

func NewQualifiedClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedClassNameContext {
	var p = new(QualifiedClassNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedClassName

	return p
}

func (s *QualifiedClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedClassNameContext) QualifiedNameElements() IQualifiedNameElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementsContext)
}

func (s *QualifiedClassNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedClassName(s)
	}
}

func (s *QualifiedClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedClassName(s)
	}
}

func (p *GroovyParser) QualifiedClassName() (localctx IQualifiedClassNameContext) {
	this := p
	_ = this

	localctx = NewQualifiedClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, GroovyParserRULE_qualifiedClassName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.QualifiedNameElements()
	}
	{
		p.SetState(782)
		p.Identifier()
	}

	return localctx
}

// IQualifiedStandardClassNameContext is an interface to support dynamic dispatch.
type IQualifiedStandardClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedStandardClassNameContext differentiates from other interfaces.
	IsQualifiedStandardClassNameContext()
}

type QualifiedStandardClassNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedStandardClassNameContext() *QualifiedStandardClassNameContext {
	var p = new(QualifiedStandardClassNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedStandardClassName
	return p
}

func (*QualifiedStandardClassNameContext) IsQualifiedStandardClassNameContext() {}

func NewQualifiedStandardClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedStandardClassNameContext {
	var p = new(QualifiedStandardClassNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedStandardClassName

	return p
}

func (s *QualifiedStandardClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedStandardClassNameContext) QualifiedNameElements() IQualifiedNameElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementsContext)
}

func (s *QualifiedStandardClassNameContext) AllClassName() []IClassNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassNameContext); ok {
			len++
		}
	}

	tst := make([]IClassNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassNameContext); ok {
			tst[i] = t.(IClassNameContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedStandardClassNameContext) ClassName(i int) IClassNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *QualifiedStandardClassNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserDOT)
}

func (s *QualifiedStandardClassNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, i)
}

func (s *QualifiedStandardClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedStandardClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedStandardClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedStandardClassName(s)
	}
}

func (s *QualifiedStandardClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedStandardClassName(s)
	}
}

func (p *GroovyParser) QualifiedStandardClassName() (localctx IQualifiedStandardClassNameContext) {
	this := p
	_ = this

	localctx = NewQualifiedStandardClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, GroovyParserRULE_qualifiedStandardClassName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.QualifiedNameElements()
	}
	{
		p.SetState(785)
		p.ClassName()
	}
	p.SetState(790)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserDOT {
		{
			p.SetState(786)
			p.Match(GroovyParserDOT)
		}
		{
			p.SetState(787)
			p.ClassName()
		}

		p.SetState(792)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyFrom(ctx *LiteralContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StringLiteralAltContext struct {
	*LiteralContext
}

func NewStringLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralAltContext {
	var p = new(StringLiteralAltContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *StringLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralAltContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *StringLiteralAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStringLiteralAlt(s)
	}
}

func (s *StringLiteralAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStringLiteralAlt(s)
	}
}

type IntegerLiteralAltContext struct {
	*LiteralContext
}

func NewIntegerLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralAltContext {
	var p = new(IntegerLiteralAltContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *IntegerLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralAltContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserIntegerLiteral, 0)
}

func (s *IntegerLiteralAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterIntegerLiteralAlt(s)
	}
}

func (s *IntegerLiteralAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitIntegerLiteralAlt(s)
	}
}

type FloatingPointLiteralAltContext struct {
	*LiteralContext
}

func NewFloatingPointLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FloatingPointLiteralAltContext {
	var p = new(FloatingPointLiteralAltContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *FloatingPointLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatingPointLiteralAltContext) FloatingPointLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserFloatingPointLiteral, 0)
}

func (s *FloatingPointLiteralAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFloatingPointLiteralAlt(s)
	}
}

func (s *FloatingPointLiteralAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFloatingPointLiteralAlt(s)
	}
}

type BoolLiteralAltContext struct {
	*LiteralContext
}

func NewBoolLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoolLiteralAltContext {
	var p = new(BoolLiteralAltContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *BoolLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolLiteralAltContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserBooleanLiteral, 0)
}

func (s *BoolLiteralAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBoolLiteralAlt(s)
	}
}

func (s *BoolLiteralAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBoolLiteralAlt(s)
	}
}

type NilLiteralAltContext struct {
	*LiteralContext
}

func NewNilLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NilLiteralAltContext {
	var p = new(NilLiteralAltContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *NilLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NilLiteralAltContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserNullLiteral, 0)
}

func (s *NilLiteralAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNilLiteralAlt(s)
	}
}

func (s *NilLiteralAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNilLiteralAlt(s)
	}
}

func (p *GroovyParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, GroovyParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(798)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserIntegerLiteral:
		localctx = NewIntegerLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(793)
			p.Match(GroovyParserIntegerLiteral)
		}

	case GroovyParserFloatingPointLiteral:
		localctx = NewFloatingPointLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(794)
			p.Match(GroovyParserFloatingPointLiteral)
		}

	case GroovyParserStringLiteral:
		localctx = NewStringLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(795)
			p.StringLiteral()
		}

	case GroovyParserBooleanLiteral:
		localctx = NewBoolLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(796)
			p.Match(GroovyParserBooleanLiteral)
		}

	case GroovyParserNullLiteral:
		localctx = NewNilLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(797)
			p.Match(GroovyParserNullLiteral)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGstringContext is an interface to support dynamic dispatch.
type IGstringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGstringContext differentiates from other interfaces.
	IsGstringContext()
}

type GstringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGstringContext() *GstringContext {
	var p = new(GstringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_gstring
	return p
}

func (*GstringContext) IsGstringContext() {}

func NewGstringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GstringContext {
	var p = new(GstringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_gstring

	return p
}

func (s *GstringContext) GetParser() antlr.Parser { return s.parser }

func (s *GstringContext) GStringBegin() antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringBegin, 0)
}

func (s *GstringContext) AllGstringValue() []IGstringValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGstringValueContext); ok {
			len++
		}
	}

	tst := make([]IGstringValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGstringValueContext); ok {
			tst[i] = t.(IGstringValueContext)
			i++
		}
	}

	return tst
}

func (s *GstringContext) GstringValue(i int) IGstringValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGstringValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGstringValueContext)
}

func (s *GstringContext) GStringEnd() antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringEnd, 0)
}

func (s *GstringContext) AllGStringPart() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserGStringPart)
}

func (s *GstringContext) GStringPart(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringPart, i)
}

func (s *GstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterGstring(s)
	}
}

func (s *GstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitGstring(s)
	}
}

func (p *GroovyParser) Gstring() (localctx IGstringContext) {
	this := p
	_ = this

	localctx = NewGstringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, GroovyParserRULE_gstring)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(800)
		p.Match(GroovyParserGStringBegin)
	}
	{
		p.SetState(801)
		p.GstringValue()
	}
	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserGStringPart {
		{
			p.SetState(802)
			p.Match(GroovyParserGStringPart)
		}
		{
			p.SetState(803)
			p.GstringValue()
		}

		p.SetState(808)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(809)
		p.Match(GroovyParserGStringEnd)
	}

	return localctx
}

// IGstringValueContext is an interface to support dynamic dispatch.
type IGstringValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGstringValueContext differentiates from other interfaces.
	IsGstringValueContext()
}

type GstringValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGstringValueContext() *GstringValueContext {
	var p = new(GstringValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_gstringValue
	return p
}

func (*GstringValueContext) IsGstringValueContext() {}

func NewGstringValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GstringValueContext {
	var p = new(GstringValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_gstringValue

	return p
}

func (s *GstringValueContext) GetParser() antlr.Parser { return s.parser }

func (s *GstringValueContext) GstringPath() IGstringPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGstringPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGstringPathContext)
}

func (s *GstringValueContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *GstringValueContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *GstringValueContext) StatementExpression() IStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *GstringValueContext) Closure() IClosureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureContext)
}

func (s *GstringValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GstringValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterGstringValue(s)
	}
}

func (s *GstringValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitGstringValue(s)
	}
}

func (p *GroovyParser) GstringValue() (localctx IGstringValueContext) {
	this := p
	_ = this

	localctx = NewGstringValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, GroovyParserRULE_gstringValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(811)
			p.GstringPath()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(812)
			p.Match(GroovyParserLBRACE)
		}
		p.SetState(814)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1090196702704449158) != 0 || (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&52776621060117) != 0 {
			{
				p.SetState(813)
				p.StatementExpression()
			}

		}
		{
			p.SetState(816)
			p.Match(GroovyParserRBRACE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(817)
			p.Closure()
		}

	}

	return localctx
}

// IGstringPathContext is an interface to support dynamic dispatch.
type IGstringPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGstringPathContext differentiates from other interfaces.
	IsGstringPathContext()
}

type GstringPathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGstringPathContext() *GstringPathContext {
	var p = new(GstringPathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_gstringPath
	return p
}

func (*GstringPathContext) IsGstringPathContext() {}

func NewGstringPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GstringPathContext {
	var p = new(GstringPathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_gstringPath

	return p
}

func (s *GstringPathContext) GetParser() antlr.Parser { return s.parser }

func (s *GstringPathContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GstringPathContext) AllGStringPathPart() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserGStringPathPart)
}

func (s *GstringPathContext) GStringPathPart(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringPathPart, i)
}

func (s *GstringPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GstringPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterGstringPath(s)
	}
}

func (s *GstringPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitGstringPath(s)
	}
}

func (p *GroovyParser) GstringPath() (localctx IGstringPathContext) {
	this := p
	_ = this

	localctx = NewGstringPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, GroovyParserRULE_gstringPath)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.Identifier()
	}
	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserGStringPathPart {
		{
			p.SetState(821)
			p.Match(GroovyParserGStringPathPart)
		}

		p.SetState(826)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_lambdaExpression
	return p
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) LambdaParameters() ILambdaParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParametersContext)
}

func (s *LambdaExpressionContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *LambdaExpressionContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserARROW, 0)
}

func (s *LambdaExpressionContext) LambdaBody() ILambdaBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaBodyContext)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (p *GroovyParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	this := p
	_ = this

	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, GroovyParserRULE_lambdaExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		p.LambdaParameters()
	}
	{
		p.SetState(828)
		p.Nls()
	}
	{
		p.SetState(829)
		p.Match(GroovyParserARROW)
	}
	{
		p.SetState(830)
		p.Nls()
	}
	{
		p.SetState(831)
		p.LambdaBody()
	}

	return localctx
}

// IStandardLambdaExpressionContext is an interface to support dynamic dispatch.
type IStandardLambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandardLambdaExpressionContext differentiates from other interfaces.
	IsStandardLambdaExpressionContext()
}

type StandardLambdaExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardLambdaExpressionContext() *StandardLambdaExpressionContext {
	var p = new(StandardLambdaExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_standardLambdaExpression
	return p
}

func (*StandardLambdaExpressionContext) IsStandardLambdaExpressionContext() {}

func NewStandardLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardLambdaExpressionContext {
	var p = new(StandardLambdaExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardLambdaExpression

	return p
}

func (s *StandardLambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardLambdaExpressionContext) StandardLambdaParameters() IStandardLambdaParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardLambdaParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardLambdaParametersContext)
}

func (s *StandardLambdaExpressionContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *StandardLambdaExpressionContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *StandardLambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserARROW, 0)
}

func (s *StandardLambdaExpressionContext) LambdaBody() ILambdaBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaBodyContext)
}

func (s *StandardLambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardLambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardLambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStandardLambdaExpression(s)
	}
}

func (s *StandardLambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStandardLambdaExpression(s)
	}
}

func (p *GroovyParser) StandardLambdaExpression() (localctx IStandardLambdaExpressionContext) {
	this := p
	_ = this

	localctx = NewStandardLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, GroovyParserRULE_standardLambdaExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.StandardLambdaParameters()
	}
	{
		p.SetState(834)
		p.Nls()
	}
	{
		p.SetState(835)
		p.Match(GroovyParserARROW)
	}
	{
		p.SetState(836)
		p.Nls()
	}
	{
		p.SetState(837)
		p.LambdaBody()
	}

	return localctx
}

// ILambdaParametersContext is an interface to support dynamic dispatch.
type ILambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaParametersContext differentiates from other interfaces.
	IsLambdaParametersContext()
}

type LambdaParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParametersContext() *LambdaParametersContext {
	var p = new(LambdaParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_lambdaParameters
	return p
}

func (*LambdaParametersContext) IsLambdaParametersContext() {}

func NewLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParametersContext {
	var p = new(LambdaParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_lambdaParameters

	return p
}

func (s *LambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParametersContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *LambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLambdaParameters(s)
	}
}

func (p *GroovyParser) LambdaParameters() (localctx ILambdaParametersContext) {
	this := p
	_ = this

	localctx = NewLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, GroovyParserRULE_lambdaParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(839)
		p.FormalParameters()
	}

	return localctx
}

// IStandardLambdaParametersContext is an interface to support dynamic dispatch.
type IStandardLambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandardLambdaParametersContext differentiates from other interfaces.
	IsStandardLambdaParametersContext()
}

type StandardLambdaParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardLambdaParametersContext() *StandardLambdaParametersContext {
	var p = new(StandardLambdaParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_standardLambdaParameters
	return p
}

func (*StandardLambdaParametersContext) IsStandardLambdaParametersContext() {}

func NewStandardLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardLambdaParametersContext {
	var p = new(StandardLambdaParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardLambdaParameters

	return p
}

func (s *StandardLambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardLambdaParametersContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *StandardLambdaParametersContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *StandardLambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardLambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardLambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStandardLambdaParameters(s)
	}
}

func (s *StandardLambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStandardLambdaParameters(s)
	}
}

func (p *GroovyParser) StandardLambdaParameters() (localctx IStandardLambdaParametersContext) {
	this := p
	_ = this

	localctx = NewStandardLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, GroovyParserRULE_standardLambdaParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(843)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(841)
			p.FormalParameters()
		}

	case GroovyParserAS, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserSTATIC, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(842)
			p.VariableDeclaratorId()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILambdaBodyContext is an interface to support dynamic dispatch.
type ILambdaBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaBodyContext differentiates from other interfaces.
	IsLambdaBodyContext()
}

type LambdaBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaBodyContext() *LambdaBodyContext {
	var p = new(LambdaBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_lambdaBody
	return p
}

func (*LambdaBodyContext) IsLambdaBodyContext() {}

func NewLambdaBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaBodyContext {
	var p = new(LambdaBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_lambdaBody

	return p
}

func (s *LambdaBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LambdaBodyContext) StatementExpression() IStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *LambdaBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLambdaBody(s)
	}
}

func (s *LambdaBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLambdaBody(s)
	}
}

func (p *GroovyParser) LambdaBody() (localctx ILambdaBodyContext) {
	this := p
	_ = this

	localctx = NewLambdaBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, GroovyParserRULE_lambdaBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(845)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(846)
			p.StatementExpression()
		}

	}

	return localctx
}

// IClosureContext is an interface to support dynamic dispatch.
type IClosureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosureContext differentiates from other interfaces.
	IsClosureContext()
}

type ClosureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosureContext() *ClosureContext {
	var p = new(ClosureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_closure
	return p
}

func (*ClosureContext) IsClosureContext() {}

func NewClosureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosureContext {
	var p = new(ClosureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_closure

	return p
}

func (s *ClosureContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosureContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *ClosureContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ClosureContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClosureContext) BlockStatementsOpt() IBlockStatementsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsOptContext)
}

func (s *ClosureContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *ClosureContext) ARROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserARROW, 0)
}

func (s *ClosureContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ClosureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClosure(s)
	}
}

func (s *ClosureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClosure(s)
	}
}

func (p *GroovyParser) Closure() (localctx IClosureContext) {
	this := p
	_ = this

	localctx = NewClosureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, GroovyParserRULE_closure)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(849)
		p.Match(GroovyParserLBRACE)
	}
	{
		p.SetState(850)
		p.Nls()
	}
	p.SetState(858)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
		p.SetState(852)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9037435958753152) != 0 || (int64((_la-122)) & ^0x3f) == 0 && ((int64(1)<<(_la-122))&15) != 0 {
			{
				p.SetState(851)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(854)
			p.Nls()
		}
		{
			p.SetState(855)
			p.Match(GroovyParserARROW)
		}
		{
			p.SetState(856)
			p.Nls()
		}

	}
	{
		p.SetState(860)
		p.BlockStatementsOpt()
	}
	{
		p.SetState(861)
		p.Match(GroovyParserRBRACE)
	}

	return localctx
}

// IClosureOrLambdaExpressionContext is an interface to support dynamic dispatch.
type IClosureOrLambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosureOrLambdaExpressionContext differentiates from other interfaces.
	IsClosureOrLambdaExpressionContext()
}

type ClosureOrLambdaExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosureOrLambdaExpressionContext() *ClosureOrLambdaExpressionContext {
	var p = new(ClosureOrLambdaExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_closureOrLambdaExpression
	return p
}

func (*ClosureOrLambdaExpressionContext) IsClosureOrLambdaExpressionContext() {}

func NewClosureOrLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosureOrLambdaExpressionContext {
	var p = new(ClosureOrLambdaExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_closureOrLambdaExpression

	return p
}

func (s *ClosureOrLambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosureOrLambdaExpressionContext) Closure() IClosureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureContext)
}

func (s *ClosureOrLambdaExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ClosureOrLambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureOrLambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosureOrLambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClosureOrLambdaExpression(s)
	}
}

func (s *ClosureOrLambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClosureOrLambdaExpression(s)
	}
}

func (p *GroovyParser) ClosureOrLambdaExpression() (localctx IClosureOrLambdaExpressionContext) {
	this := p
	_ = this

	localctx = NewClosureOrLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, GroovyParserRULE_closureOrLambdaExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(865)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(863)
			p.Closure()
		}

	case GroovyParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(864)
			p.LambdaExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBlockStatementsOptContext is an interface to support dynamic dispatch.
type IBlockStatementsOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementsOptContext differentiates from other interfaces.
	IsBlockStatementsOptContext()
}

type BlockStatementsOptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementsOptContext() *BlockStatementsOptContext {
	var p = new(BlockStatementsOptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_blockStatementsOpt
	return p
}

func (*BlockStatementsOptContext) IsBlockStatementsOptContext() {}

func NewBlockStatementsOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementsOptContext {
	var p = new(BlockStatementsOptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_blockStatementsOpt

	return p
}

func (s *BlockStatementsOptContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementsOptContext) BlockStatements() IBlockStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *BlockStatementsOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementsOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementsOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBlockStatementsOpt(s)
	}
}

func (s *BlockStatementsOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBlockStatementsOpt(s)
	}
}

func (p *GroovyParser) BlockStatementsOpt() (localctx IBlockStatementsOptContext) {
	this := p
	_ = this

	localctx = NewBlockStatementsOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, GroovyParserRULE_blockStatementsOpt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(868)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(867)
			p.BlockStatements()
		}

	}

	return localctx
}

// IBlockStatementsContext is an interface to support dynamic dispatch.
type IBlockStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementsContext differentiates from other interfaces.
	IsBlockStatementsContext()
}

type BlockStatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementsContext() *BlockStatementsContext {
	var p = new(BlockStatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_blockStatements
	return p
}

func (*BlockStatementsContext) IsBlockStatementsContext() {}

func NewBlockStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementsContext {
	var p = new(BlockStatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_blockStatements

	return p
}

func (s *BlockStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementsContext) AllBlockStatement() []IBlockStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockStatementContext); ok {
			len++
		}
	}

	tst := make([]IBlockStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockStatementContext); ok {
			tst[i] = t.(IBlockStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementsContext) BlockStatement(i int) IBlockStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *BlockStatementsContext) AllSep() []ISepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISepContext); ok {
			len++
		}
	}

	tst := make([]ISepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISepContext); ok {
			tst[i] = t.(ISepContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementsContext) Sep(i int) ISepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *BlockStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBlockStatements(s)
	}
}

func (s *BlockStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBlockStatements(s)
	}
}

func (p *GroovyParser) BlockStatements() (localctx IBlockStatementsContext) {
	this := p
	_ = this

	localctx = NewBlockStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, GroovyParserRULE_blockStatements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		p.BlockStatement()
	}
	p.SetState(876)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(871)
				p.Sep()
			}
			{
				p.SetState(872)
				p.BlockStatement()
			}

		}
		p.SetState(878)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())
	}
	p.SetState(880)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(879)
			p.Sep()
		}

	}

	return localctx
}

// IAnnotationsOptContext is an interface to support dynamic dispatch.
type IAnnotationsOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationsOptContext differentiates from other interfaces.
	IsAnnotationsOptContext()
}

type AnnotationsOptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationsOptContext() *AnnotationsOptContext {
	var p = new(AnnotationsOptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_annotationsOpt
	return p
}

func (*AnnotationsOptContext) IsAnnotationsOptContext() {}

func NewAnnotationsOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationsOptContext {
	var p = new(AnnotationsOptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotationsOpt

	return p
}

func (s *AnnotationsOptContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationsOptContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationsOptContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationsOptContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationsOptContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AnnotationsOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationsOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationsOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAnnotationsOpt(s)
	}
}

func (s *AnnotationsOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAnnotationsOpt(s)
	}
}

func (p *GroovyParser) AnnotationsOpt() (localctx IAnnotationsOptContext) {
	this := p
	_ = this

	localctx = NewAnnotationsOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, GroovyParserRULE_annotationsOpt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserAT {
		{
			p.SetState(882)
			p.Annotation()
		}
		{
			p.SetState(883)
			p.Nls()
		}

		p.SetState(889)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(GroovyParserAT, 0)
}

func (s *AnnotationContext) AnnotationName() IAnnotationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationNameContext)
}

func (s *AnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *AnnotationContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *AnnotationContext) ElementValues() IElementValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuesContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *GroovyParser) Annotation() (localctx IAnnotationContext) {
	this := p
	_ = this

	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, GroovyParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		p.Match(GroovyParserAT)
	}
	{
		p.SetState(891)
		p.AnnotationName()
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(892)
			p.Match(GroovyParserLPAREN)
		}
		p.SetState(894)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(893)
				p.ElementValues()
			}

		}
		{
			p.SetState(896)
			p.Rparen()
		}

	}

	return localctx
}

// IElementValuesContext is an interface to support dynamic dispatch.
type IElementValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuesContext differentiates from other interfaces.
	IsElementValuesContext()
}

type ElementValuesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuesContext() *ElementValuesContext {
	var p = new(ElementValuesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValues
	return p
}

func (*ElementValuesContext) IsElementValuesContext() {}

func NewElementValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuesContext {
	var p = new(ElementValuesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValues

	return p
}

func (s *ElementValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuesContext) ElementValuePairs() IElementValuePairsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairsContext)
}

func (s *ElementValuesContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValues(s)
	}
}

func (s *ElementValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValues(s)
	}
}

func (p *GroovyParser) ElementValues() (localctx IElementValuesContext) {
	this := p
	_ = this

	localctx = NewElementValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, GroovyParserRULE_elementValues)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(899)
			p.ElementValuePairs()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(900)
			p.ElementValue()
		}

	}

	return localctx
}

// IAnnotationNameContext is an interface to support dynamic dispatch.
type IAnnotationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationNameContext differentiates from other interfaces.
	IsAnnotationNameContext()
}

type AnnotationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationNameContext() *AnnotationNameContext {
	var p = new(AnnotationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_annotationName
	return p
}

func (*AnnotationNameContext) IsAnnotationNameContext() {}

func NewAnnotationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationNameContext {
	var p = new(AnnotationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotationName

	return p
}

func (s *AnnotationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationNameContext) QualifiedClassName() IQualifiedClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *AnnotationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAnnotationName(s)
	}
}

func (s *AnnotationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAnnotationName(s)
	}
}

func (p *GroovyParser) AnnotationName() (localctx IAnnotationNameContext) {
	this := p
	_ = this

	localctx = NewAnnotationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, GroovyParserRULE_annotationName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(903)
		p.QualifiedClassName()
	}

	return localctx
}

// IElementValuePairsContext is an interface to support dynamic dispatch.
type IElementValuePairsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairsContext differentiates from other interfaces.
	IsElementValuePairsContext()
}

type ElementValuePairsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairsContext() *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValuePairs
	return p
}

func (*ElementValuePairsContext) IsElementValuePairsContext() {}

func NewElementValuePairsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValuePairs

	return p
}

func (s *ElementValuePairsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairsContext) AllElementValuePair() []IElementValuePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValuePairContext); ok {
			len++
		}
	}

	tst := make([]IElementValuePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValuePairContext); ok {
			tst[i] = t.(IElementValuePairContext)
			i++
		}
	}

	return tst
}

func (s *ElementValuePairsContext) ElementValuePair(i int) IElementValuePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairContext)
}

func (s *ElementValuePairsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ElementValuePairsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ElementValuePairsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValuePairs(s)
	}
}

func (s *ElementValuePairsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValuePairs(s)
	}
}

func (p *GroovyParser) ElementValuePairs() (localctx IElementValuePairsContext) {
	this := p
	_ = this

	localctx = NewElementValuePairsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, GroovyParserRULE_elementValuePairs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.ElementValuePair()
	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(906)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(907)
				p.ElementValuePair()
			}

		}
		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())
	}

	return localctx
}

// IElementValuePairContext is an interface to support dynamic dispatch.
type IElementValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairContext differentiates from other interfaces.
	IsElementValuePairContext()
}

type ElementValuePairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairContext() *ElementValuePairContext {
	var p = new(ElementValuePairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValuePair
	return p
}

func (*ElementValuePairContext) IsElementValuePairContext() {}

func NewElementValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairContext {
	var p = new(ElementValuePairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValuePair

	return p
}

func (s *ElementValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairContext) ElementValuePairName() IElementValuePairNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairNameContext)
}

func (s *ElementValuePairContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ElementValuePairContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ElementValuePairContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *ElementValuePairContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValuePair(s)
	}
}

func (s *ElementValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValuePair(s)
	}
}

func (p *GroovyParser) ElementValuePair() (localctx IElementValuePairContext) {
	this := p
	_ = this

	localctx = NewElementValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, GroovyParserRULE_elementValuePair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(913)
		p.ElementValuePairName()
	}
	{
		p.SetState(914)
		p.Nls()
	}
	{
		p.SetState(915)
		p.Match(GroovyParserASSIGN)
	}
	{
		p.SetState(916)
		p.Nls()
	}
	{
		p.SetState(917)
		p.ElementValue()
	}

	return localctx
}

// IElementValuePairNameContext is an interface to support dynamic dispatch.
type IElementValuePairNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairNameContext differentiates from other interfaces.
	IsElementValuePairNameContext()
}

type ElementValuePairNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairNameContext() *ElementValuePairNameContext {
	var p = new(ElementValuePairNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValuePairName
	return p
}

func (*ElementValuePairNameContext) IsElementValuePairNameContext() {}

func NewElementValuePairNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairNameContext {
	var p = new(ElementValuePairNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValuePairName

	return p
}

func (s *ElementValuePairNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ElementValuePairNameContext) Keywords() IKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *ElementValuePairNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValuePairName(s)
	}
}

func (s *ElementValuePairNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValuePairName(s)
	}
}

func (p *GroovyParser) ElementValuePairName() (localctx IElementValuePairNameContext) {
	this := p
	_ = this

	localctx = NewElementValuePairNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, GroovyParserRULE_elementValuePairName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(919)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(920)
			p.Keywords()
		}

	}

	return localctx
}

// IElementValueContext is an interface to support dynamic dispatch.
type IElementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValueContext differentiates from other interfaces.
	IsElementValueContext()
}

type ElementValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueContext() *ElementValueContext {
	var p = new(ElementValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValue
	return p
}

func (*ElementValueContext) IsElementValueContext() {}

func NewElementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueContext {
	var p = new(ElementValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValue

	return p
}

func (s *ElementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueContext) ElementValueArrayInitializer() IElementValueArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueArrayInitializerContext)
}

func (s *ElementValueContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ElementValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValue(s)
	}
}

func (s *ElementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValue(s)
	}
}

func (p *GroovyParser) ElementValue() (localctx IElementValueContext) {
	this := p
	_ = this

	localctx = NewElementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, GroovyParserRULE_elementValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(926)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(923)
			p.ElementValueArrayInitializer()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(924)
			p.Annotation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(925)
			p.expression(0)
		}

	}

	return localctx
}

// IElementValueArrayInitializerContext is an interface to support dynamic dispatch.
type IElementValueArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValueArrayInitializerContext differentiates from other interfaces.
	IsElementValueArrayInitializerContext()
}

type ElementValueArrayInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueArrayInitializerContext() *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValueArrayInitializer
	return p
}

func (*ElementValueArrayInitializerContext) IsElementValueArrayInitializerContext() {}

func NewElementValueArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValueArrayInitializer

	return p
}

func (s *ElementValueArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueArrayInitializerContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *ElementValueArrayInitializerContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *ElementValueArrayInitializerContext) AllElementValue() []IElementValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValueContext); ok {
			len++
		}
	}

	tst := make([]IElementValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValueContext); ok {
			tst[i] = t.(IElementValueContext)
			i++
		}
	}

	return tst
}

func (s *ElementValueArrayInitializerContext) ElementValue(i int) IElementValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValueArrayInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ElementValueArrayInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ElementValueArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValueArrayInitializer(s)
	}
}

func (s *ElementValueArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValueArrayInitializer(s)
	}
}

func (p *GroovyParser) ElementValueArrayInitializer() (localctx IElementValueArrayInitializerContext) {
	this := p
	_ = this

	localctx = NewElementValueArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, GroovyParserRULE_elementValueArrayInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.Match(GroovyParserLBRACK)
	}
	p.SetState(937)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1090196702704449158) != 0 || (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&123145365237781) != 0 {
		{
			p.SetState(929)
			p.ElementValue()
		}
		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(930)
					p.Match(GroovyParserCOMMA)
				}
				{
					p.SetState(931)
					p.ElementValue()
				}

			}
			p.SetState(936)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
		}

	}
	p.SetState(940)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserCOMMA {
		{
			p.SetState(939)
			p.Match(GroovyParserCOMMA)
		}

	}
	{
		p.SetState(942)
		p.Match(GroovyParserRBRACK)
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *BlockContext) BlockStatementsOpt() IBlockStatementsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsOptContext)
}

func (s *BlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *BlockContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *BlockContext) AllSep() []ISepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISepContext); ok {
			len++
		}
	}

	tst := make([]ISepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISepContext); ok {
			tst[i] = t.(ISepContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Sep(i int) ISepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *GroovyParser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, GroovyParserRULE_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(944)
		p.Match(GroovyParserLBRACE)
	}
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(945)
			p.Nls()
		}

	case 2:
		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(946)
					p.Sep()
				}

			}
			p.SetState(951)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())
		}

	}
	{
		p.SetState(954)
		p.BlockStatementsOpt()
	}
	{
		p.SetState(955)
		p.Match(GroovyParserRBRACE)
	}

	return localctx
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_blockStatement
	return p
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *BlockStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (p *GroovyParser) BlockStatement() (localctx IBlockStatementContext) {
	this := p
	_ = this

	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, GroovyParserRULE_blockStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(957)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(958)
			p.Statement()
		}

	}

	return localctx
}

// ILocalVariableDeclarationContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalVariableDeclarationContext differentiates from other interfaces.
	IsLocalVariableDeclarationContext()
}

type LocalVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationContext() *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_localVariableDeclaration
	return p
}

func (*LocalVariableDeclarationContext) IsLocalVariableDeclarationContext() {}

func NewLocalVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_localVariableDeclaration

	return p
}

func (s *LocalVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *LocalVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLocalVariableDeclaration(s)
	}
}

func (s *LocalVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLocalVariableDeclaration(s)
	}
}

func (p *GroovyParser) LocalVariableDeclaration() (localctx ILocalVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewLocalVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, GroovyParserRULE_localVariableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(961)
		p.VariableDeclaration(0)
	}

	return localctx
}

// IClassifiedModifiersContext is an interface to support dynamic dispatch.
type IClassifiedModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsClassifiedModifiersContext differentiates from other interfaces.
	IsClassifiedModifiersContext()
}

type ClassifiedModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyClassifiedModifiersContext() *ClassifiedModifiersContext {
	var p = new(ClassifiedModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classifiedModifiers
	return p
}

func (*ClassifiedModifiersContext) IsClassifiedModifiersContext() {}

func NewClassifiedModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *ClassifiedModifiersContext {
	var p = new(ClassifiedModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classifiedModifiers

	p.t = t

	return p
}

func (s *ClassifiedModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassifiedModifiersContext) GetT() int { return s.t }

func (s *ClassifiedModifiersContext) SetT(v int) { s.t = v }

func (s *ClassifiedModifiersContext) VariableModifiers() IVariableModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersContext)
}

func (s *ClassifiedModifiersContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ClassifiedModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassifiedModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassifiedModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassifiedModifiers(s)
	}
}

func (s *ClassifiedModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassifiedModifiers(s)
	}
}

func (p *GroovyParser) ClassifiedModifiers(t int) (localctx IClassifiedModifiersContext) {
	this := p
	_ = this

	localctx = NewClassifiedModifiersContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 162, GroovyParserRULE_classifiedModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(963)

		if !(0 == localctx.(*ClassifiedModifiersContext).t) {
			panic(antlr.NewFailedPredicateException(p, " 0 == $t ", ""))
		}
		{
			p.SetState(964)
			p.VariableModifiers()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(965)

		if !(1 == localctx.(*ClassifiedModifiersContext).t) {
			panic(antlr.NewFailedPredicateException(p, " 1 == $t ", ""))
		}
		{
			p.SetState(966)
			p.Modifiers()
		}

	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclaration

	p.t = t

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) GetT() int { return s.t }

func (s *VariableDeclarationContext) SetT(v int) { s.t = v }

func (s *VariableDeclarationContext) ClassifiedModifiers() IClassifiedModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifiedModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifiedModifiersContext)
}

func (s *VariableDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *VariableDeclarationContext) TypeNamePairs() ITypeNamePairsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNamePairsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNamePairsContext)
}

func (s *VariableDeclarationContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *VariableDeclarationContext) VariableInitializer() IVariableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableDeclarationContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *GroovyParser) VariableDeclaration(t int) (localctx IVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 164, GroovyParserRULE_variableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(969)
			p.ClassifiedModifiers(localctx.(*VariableDeclarationContext).t)
		}
		p.SetState(980)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserSTATIC, GroovyParserVOID, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier, GroovyParserAT:
			p.SetState(971)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(970)
					p.TypeType()
				}

			}
			{
				p.SetState(973)
				p.VariableDeclarators()
			}

		case GroovyParserLPAREN:
			{
				p.SetState(974)
				p.TypeNamePairs()
			}
			{
				p.SetState(975)
				p.Nls()
			}
			{
				p.SetState(976)
				p.Match(GroovyParserASSIGN)
			}
			{
				p.SetState(977)
				p.Nls()
			}
			{
				p.SetState(978)
				p.VariableInitializer()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(983)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(982)
				p.ClassifiedModifiers(localctx.(*VariableDeclarationContext).t)
			}

		}
		{
			p.SetState(985)
			p.TypeType()
		}
		{
			p.SetState(986)
			p.VariableDeclarators()
		}

	}

	return localctx
}

// ITypeNamePairsContext is an interface to support dynamic dispatch.
type ITypeNamePairsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNamePairsContext differentiates from other interfaces.
	IsTypeNamePairsContext()
}

type TypeNamePairsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNamePairsContext() *TypeNamePairsContext {
	var p = new(TypeNamePairsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeNamePairs
	return p
}

func (*TypeNamePairsContext) IsTypeNamePairsContext() {}

func NewTypeNamePairsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNamePairsContext {
	var p = new(TypeNamePairsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeNamePairs

	return p
}

func (s *TypeNamePairsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNamePairsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *TypeNamePairsContext) AllTypeNamePair() []ITypeNamePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeNamePairContext); ok {
			len++
		}
	}

	tst := make([]ITypeNamePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeNamePairContext); ok {
			tst[i] = t.(ITypeNamePairContext)
			i++
		}
	}

	return tst
}

func (s *TypeNamePairsContext) TypeNamePair(i int) ITypeNamePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNamePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNamePairContext)
}

func (s *TypeNamePairsContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *TypeNamePairsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeNamePairsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeNamePairsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNamePairsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNamePairsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeNamePairs(s)
	}
}

func (s *TypeNamePairsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeNamePairs(s)
	}
}

func (p *GroovyParser) TypeNamePairs() (localctx ITypeNamePairsContext) {
	this := p
	_ = this

	localctx = NewTypeNamePairsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, GroovyParserRULE_typeNamePairs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(990)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(991)
		p.TypeNamePair()
	}
	p.SetState(996)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(992)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(993)
			p.TypeNamePair()
		}

		p.SetState(998)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(999)
		p.Rparen()
	}

	return localctx
}

// ITypeNamePairContext is an interface to support dynamic dispatch.
type ITypeNamePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNamePairContext differentiates from other interfaces.
	IsTypeNamePairContext()
}

type TypeNamePairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNamePairContext() *TypeNamePairContext {
	var p = new(TypeNamePairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeNamePair
	return p
}

func (*TypeNamePairContext) IsTypeNamePairContext() {}

func NewTypeNamePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNamePairContext {
	var p = new(TypeNamePairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeNamePair

	return p
}

func (s *TypeNamePairContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNamePairContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *TypeNamePairContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeNamePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNamePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNamePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeNamePair(s)
	}
}

func (s *TypeNamePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeNamePair(s)
	}
}

func (p *GroovyParser) TypeNamePair() (localctx ITypeNamePairContext) {
	this := p
	_ = this

	localctx = NewTypeNamePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, GroovyParserRULE_typeNamePair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1002)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1001)
			p.TypeType()
		}

	}
	{
		p.SetState(1004)
		p.VariableDeclaratorId()
	}

	return localctx
}

// IVariableNamesContext is an interface to support dynamic dispatch.
type IVariableNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableNamesContext differentiates from other interfaces.
	IsVariableNamesContext()
}

type VariableNamesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNamesContext() *VariableNamesContext {
	var p = new(VariableNamesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableNames
	return p
}

func (*VariableNamesContext) IsVariableNamesContext() {}

func NewVariableNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNamesContext {
	var p = new(VariableNamesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableNames

	return p
}

func (s *VariableNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNamesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *VariableNamesContext) AllVariableDeclaratorId() []IVariableDeclaratorIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclaratorIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclaratorIdContext); ok {
			tst[i] = t.(IVariableDeclaratorIdContext)
			i++
		}
	}

	return tst
}

func (s *VariableNamesContext) VariableDeclaratorId(i int) IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *VariableNamesContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *VariableNamesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *VariableNamesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *VariableNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableNames(s)
	}
}

func (s *VariableNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableNames(s)
	}
}

func (p *GroovyParser) VariableNames() (localctx IVariableNamesContext) {
	this := p
	_ = this

	localctx = NewVariableNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, GroovyParserRULE_variableNames)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1006)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(1007)
		p.VariableDeclaratorId()
	}
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == GroovyParserCOMMA {
		{
			p.SetState(1008)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(1009)
			p.VariableDeclaratorId()
		}

		p.SetState(1012)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1014)
		p.Rparen()
	}

	return localctx
}

// IConditionalStatementContext is an interface to support dynamic dispatch.
type IConditionalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionalStatementContext differentiates from other interfaces.
	IsConditionalStatementContext()
}

type ConditionalStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalStatementContext() *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_conditionalStatement
	return p
}

func (*ConditionalStatementContext) IsConditionalStatementContext() {}

func NewConditionalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_conditionalStatement

	return p
}

func (s *ConditionalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalStatementContext) IfElseStatement() IIfElseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfElseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfElseStatementContext)
}

func (s *ConditionalStatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *ConditionalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitConditionalStatement(s)
	}
}

func (p *GroovyParser) ConditionalStatement() (localctx IConditionalStatementContext) {
	this := p
	_ = this

	localctx = NewConditionalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, GroovyParserRULE_conditionalStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1018)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1016)
			p.IfElseStatement()
		}

	case GroovyParserSWITCH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1017)
			p.SwitchStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfElseStatementContext is an interface to support dynamic dispatch.
type IIfElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTb returns the tb rule contexts.
	GetTb() IStatementContext

	// GetFb returns the fb rule contexts.
	GetFb() IStatementContext

	// SetTb sets the tb rule contexts.
	SetTb(IStatementContext)

	// SetFb sets the fb rule contexts.
	SetFb(IStatementContext)

	// IsIfElseStatementContext differentiates from other interfaces.
	IsIfElseStatementContext()
}

type IfElseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	tb     IStatementContext
	fb     IStatementContext
}

func NewEmptyIfElseStatementContext() *IfElseStatementContext {
	var p = new(IfElseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_ifElseStatement
	return p
}

func (*IfElseStatementContext) IsIfElseStatementContext() {}

func NewIfElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfElseStatementContext {
	var p = new(IfElseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_ifElseStatement

	return p
}

func (s *IfElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfElseStatementContext) GetTb() IStatementContext { return s.tb }

func (s *IfElseStatementContext) GetFb() IStatementContext { return s.fb }

func (s *IfElseStatementContext) SetTb(v IStatementContext) { s.tb = v }

func (s *IfElseStatementContext) SetFb(v IStatementContext) { s.fb = v }

func (s *IfElseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(GroovyParserIF, 0)
}

func (s *IfElseStatementContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *IfElseStatementContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *IfElseStatementContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *IfElseStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfElseStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfElseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(GroovyParserELSE, 0)
}

func (s *IfElseStatementContext) Sep() ISepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *IfElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfElseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterIfElseStatement(s)
	}
}

func (s *IfElseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitIfElseStatement(s)
	}
}

func (p *GroovyParser) IfElseStatement() (localctx IIfElseStatementContext) {
	this := p
	_ = this

	localctx = NewIfElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, GroovyParserRULE_ifElseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)
		p.Match(GroovyParserIF)
	}
	{
		p.SetState(1021)
		p.ExpressionInPar()
	}
	{
		p.SetState(1022)
		p.Nls()
	}
	{
		p.SetState(1023)

		var _x = p.Statement()

		localctx.(*IfElseStatementContext).tb = _x
	}
	p.SetState(1032)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1024)
				p.Nls()
			}

		case 2:
			{
				p.SetState(1025)
				p.Sep()
			}

		}
		{
			p.SetState(1028)
			p.Match(GroovyParserELSE)
		}
		{
			p.SetState(1029)
			p.Nls()
		}
		{
			p.SetState(1030)

			var _x = p.Statement()

			localctx.(*IfElseStatementContext).fb = _x
		}

	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserSWITCH, 0)
}

func (s *SwitchStatementContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *SwitchStatementContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *SwitchStatementContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *SwitchStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *SwitchStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *SwitchStatementContext) AllSwitchBlockStatementGroup() []ISwitchBlockStatementGroupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			len++
		}
	}

	tst := make([]ISwitchBlockStatementGroupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			tst[i] = t.(ISwitchBlockStatementGroupContext)
			i++
		}
	}

	return tst
}

func (s *SwitchStatementContext) SwitchBlockStatementGroup(i int) ISwitchBlockStatementGroupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockStatementGroupContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (p *GroovyParser) SwitchStatement() (localctx ISwitchStatementContext) {
	this := p
	_ = this

	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, GroovyParserRULE_switchStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1034)
		p.Match(GroovyParserSWITCH)
	}
	{
		p.SetState(1035)
		p.ExpressionInPar()
	}
	{
		p.SetState(1036)
		p.Nls()
	}
	{
		p.SetState(1037)
		p.Match(GroovyParserLBRACE)
	}
	{
		p.SetState(1038)
		p.Nls()
	}
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCASE || _la == GroovyParserDEFAULT {
		{
			p.SetState(1039)
			p.SwitchBlockStatementGroup()
		}

		p.SetState(1044)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1045)
		p.Nls()
	}
	{
		p.SetState(1046)
		p.Match(GroovyParserRBRACE)
	}

	return localctx
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_loopStatement
	return p
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) CopyFrom(ctx *LoopStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DoWhileStmtAltContext struct {
	*LoopStatementContext
}

func NewDoWhileStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoWhileStmtAltContext {
	var p = new(DoWhileStmtAltContext)

	p.LoopStatementContext = NewEmptyLoopStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LoopStatementContext))

	return p
}

func (s *DoWhileStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStmtAltContext) DO() antlr.TerminalNode {
	return s.GetToken(GroovyParserDO, 0)
}

func (s *DoWhileStmtAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *DoWhileStmtAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *DoWhileStmtAltContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoWhileStmtAltContext) WHILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserWHILE, 0)
}

func (s *DoWhileStmtAltContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *DoWhileStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterDoWhileStmtAlt(s)
	}
}

func (s *DoWhileStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitDoWhileStmtAlt(s)
	}
}

type ForStmtAltContext struct {
	*LoopStatementContext
}

func NewForStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForStmtAltContext {
	var p = new(ForStmtAltContext)

	p.LoopStatementContext = NewEmptyLoopStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LoopStatementContext))

	return p
}

func (s *ForStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStmtAltContext) FOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserFOR, 0)
}

func (s *ForStmtAltContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ForStmtAltContext) ForControl() IForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForControlContext)
}

func (s *ForStmtAltContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ForStmtAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ForStmtAltContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterForStmtAlt(s)
	}
}

func (s *ForStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitForStmtAlt(s)
	}
}

type WhileStmtAltContext struct {
	*LoopStatementContext
}

func NewWhileStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhileStmtAltContext {
	var p = new(WhileStmtAltContext)

	p.LoopStatementContext = NewEmptyLoopStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LoopStatementContext))

	return p
}

func (s *WhileStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStmtAltContext) WHILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserWHILE, 0)
}

func (s *WhileStmtAltContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *WhileStmtAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *WhileStmtAltContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterWhileStmtAlt(s)
	}
}

func (s *WhileStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitWhileStmtAlt(s)
	}
}

func (p *GroovyParser) LoopStatement() (localctx ILoopStatementContext) {
	this := p
	_ = this

	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, GroovyParserRULE_loopStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1067)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserFOR:
		localctx = NewForStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1048)
			p.Match(GroovyParserFOR)
		}
		{
			p.SetState(1049)
			p.Match(GroovyParserLPAREN)
		}
		{
			p.SetState(1050)
			p.ForControl()
		}
		{
			p.SetState(1051)
			p.Rparen()
		}
		{
			p.SetState(1052)
			p.Nls()
		}
		{
			p.SetState(1053)
			p.Statement()
		}

	case GroovyParserWHILE:
		localctx = NewWhileStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1055)
			p.Match(GroovyParserWHILE)
		}
		{
			p.SetState(1056)
			p.ExpressionInPar()
		}
		{
			p.SetState(1057)
			p.Nls()
		}
		{
			p.SetState(1058)
			p.Statement()
		}

	case GroovyParserDO:
		localctx = NewDoWhileStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1060)
			p.Match(GroovyParserDO)
		}
		{
			p.SetState(1061)
			p.Nls()
		}
		{
			p.SetState(1062)
			p.Statement()
		}
		{
			p.SetState(1063)
			p.Nls()
		}
		{
			p.SetState(1064)
			p.Match(GroovyParserWHILE)
		}
		{
			p.SetState(1065)
			p.ExpressionInPar()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCONTINUE, 0)
}

func (s *ContinueStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *GroovyParser) ContinueStatement() (localctx IContinueStatementContext) {
	this := p
	_ = this

	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, GroovyParserRULE_continueStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1069)
		p.Match(GroovyParserCONTINUE)
	}
	p.SetState(1071)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8796093027968) != 0 || _la == GroovyParserCapitalizedIdentifier || _la == GroovyParserIdentifier {
		{
			p.SetState(1070)
			p.Identifier()
		}

	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(GroovyParserBREAK, 0)
}

func (s *BreakStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *GroovyParser) BreakStatement() (localctx IBreakStatementContext) {
	this := p
	_ = this

	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, GroovyParserRULE_breakStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1073)
		p.Match(GroovyParserBREAK)
	}
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8796093027968) != 0 || _la == GroovyParserCapitalizedIdentifier || _la == GroovyParserIdentifier {
		{
			p.SetState(1074)
			p.Identifier()
		}

	}

	return localctx
}

// ITryCatchStatementContext is an interface to support dynamic dispatch.
type ITryCatchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryCatchStatementContext differentiates from other interfaces.
	IsTryCatchStatementContext()
}

type TryCatchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryCatchStatementContext() *TryCatchStatementContext {
	var p = new(TryCatchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_tryCatchStatement
	return p
}

func (*TryCatchStatementContext) IsTryCatchStatementContext() {}

func NewTryCatchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryCatchStatementContext {
	var p = new(TryCatchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_tryCatchStatement

	return p
}

func (s *TryCatchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryCatchStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRY, 0)
}

func (s *TryCatchStatementContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *TryCatchStatementContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TryCatchStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryCatchStatementContext) Resources() IResourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourcesContext)
}

func (s *TryCatchStatementContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *TryCatchStatementContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryCatchStatementContext) FinallyBlock() IFinallyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *TryCatchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCatchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryCatchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTryCatchStatement(s)
	}
}

func (s *TryCatchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTryCatchStatement(s)
	}
}

func (p *GroovyParser) TryCatchStatement() (localctx ITryCatchStatementContext) {
	this := p
	_ = this

	localctx = NewTryCatchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, GroovyParserRULE_tryCatchStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1077)
		p.Match(GroovyParserTRY)
	}
	p.SetState(1079)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserLPAREN {
		{
			p.SetState(1078)
			p.Resources()
		}

	}
	{
		p.SetState(1081)
		p.Nls()
	}
	{
		p.SetState(1082)
		p.Block()
	}
	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1083)
				p.Nls()
			}
			{
				p.SetState(1084)
				p.CatchClause()
			}

		}
		p.SetState(1090)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())
	}
	p.SetState(1094)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1091)
			p.Nls()
		}
		{
			p.SetState(1092)
			p.FinallyBlock()
		}

	}

	return localctx
}

// IAssertStatementContext is an interface to support dynamic dispatch.
type IAssertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCe returns the ce rule contexts.
	GetCe() IExpressionContext

	// GetMe returns the me rule contexts.
	GetMe() IExpressionContext

	// SetCe sets the ce rule contexts.
	SetCe(IExpressionContext)

	// SetMe sets the me rule contexts.
	SetMe(IExpressionContext)

	// IsAssertStatementContext differentiates from other interfaces.
	IsAssertStatementContext()
}

type AssertStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	ce     IExpressionContext
	me     IExpressionContext
}

func NewEmptyAssertStatementContext() *AssertStatementContext {
	var p = new(AssertStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_assertStatement
	return p
}

func (*AssertStatementContext) IsAssertStatementContext() {}

func NewAssertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertStatementContext {
	var p = new(AssertStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_assertStatement

	return p
}

func (s *AssertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertStatementContext) GetCe() IExpressionContext { return s.ce }

func (s *AssertStatementContext) GetMe() IExpressionContext { return s.me }

func (s *AssertStatementContext) SetCe(v IExpressionContext) { s.ce = v }

func (s *AssertStatementContext) SetMe(v IExpressionContext) { s.me = v }

func (s *AssertStatementContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSERT, 0)
}

func (s *AssertStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssertStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssertStatementContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *AssertStatementContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AssertStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *AssertStatementContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *AssertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAssertStatement(s)
	}
}

func (s *AssertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAssertStatement(s)
	}
}

func (p *GroovyParser) AssertStatement() (localctx IAssertStatementContext) {
	this := p
	_ = this

	localctx = NewAssertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, GroovyParserRULE_assertStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1096)
		p.Match(GroovyParserASSERT)
	}
	{
		p.SetState(1097)

		var _x = p.expression(0)

		localctx.(*AssertStatementContext).ce = _x
	}
	p.SetState(1103)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1098)
			p.Nls()
		}
		{
			p.SetState(1099)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserCOMMA || _la == GroovyParserCOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1100)
			p.Nls()
		}
		{
			p.SetState(1101)

			var _x = p.expression(0)

			localctx.(*AssertStatementContext).me = _x
		}

	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyFrom(ctx *StatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ConditionalStmtAltContext struct {
	*StatementContext
}

func NewConditionalStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConditionalStmtAltContext {
	var p = new(ConditionalStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ConditionalStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalStmtAltContext) ConditionalStatement() IConditionalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalStatementContext)
}

func (s *ConditionalStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterConditionalStmtAlt(s)
	}
}

func (s *ConditionalStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitConditionalStmtAlt(s)
	}
}

type EmptyStmtAltContext struct {
	*StatementContext
}

func NewEmptyStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EmptyStmtAltContext {
	var p = new(EmptyStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *EmptyStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStmtAltContext) SEMI() antlr.TerminalNode {
	return s.GetToken(GroovyParserSEMI, 0)
}

func (s *EmptyStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEmptyStmtAlt(s)
	}
}

func (s *EmptyStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEmptyStmtAlt(s)
	}
}

type BlockStmtAltContext struct {
	*StatementContext
}

func NewBlockStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BlockStmtAltContext {
	var p = new(BlockStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *BlockStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStmtAltContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *BlockStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBlockStmtAlt(s)
	}
}

func (s *BlockStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBlockStmtAlt(s)
	}
}

type TryCatchStmtAltContext struct {
	*StatementContext
}

func NewTryCatchStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TryCatchStmtAltContext {
	var p = new(TryCatchStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *TryCatchStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCatchStmtAltContext) TryCatchStatement() ITryCatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryCatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryCatchStatementContext)
}

func (s *TryCatchStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTryCatchStmtAlt(s)
	}
}

func (s *TryCatchStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTryCatchStmtAlt(s)
	}
}

type BreakStmtAltContext struct {
	*StatementContext
}

func NewBreakStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BreakStmtAltContext {
	var p = new(BreakStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *BreakStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStmtAltContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *BreakStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBreakStmtAlt(s)
	}
}

func (s *BreakStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBreakStmtAlt(s)
	}
}

type ContinueStmtAltContext struct {
	*StatementContext
}

func NewContinueStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ContinueStmtAltContext {
	var p = new(ContinueStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ContinueStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStmtAltContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *ContinueStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterContinueStmtAlt(s)
	}
}

func (s *ContinueStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitContinueStmtAlt(s)
	}
}

type AssertStmtAltContext struct {
	*StatementContext
}

func NewAssertStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertStmtAltContext {
	var p = new(AssertStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AssertStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStmtAltContext) AssertStatement() IAssertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssertStatementContext)
}

func (s *AssertStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAssertStmtAlt(s)
	}
}

func (s *AssertStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAssertStmtAlt(s)
	}
}

type LoopStmtAltContext struct {
	*StatementContext
}

func NewLoopStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LoopStmtAltContext {
	var p = new(LoopStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *LoopStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStmtAltContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *LoopStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLoopStmtAlt(s)
	}
}

func (s *LoopStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLoopStmtAlt(s)
	}
}

type SynchronizedStmtAltContext struct {
	*StatementContext
}

func NewSynchronizedStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SynchronizedStmtAltContext {
	var p = new(SynchronizedStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *SynchronizedStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SynchronizedStmtAltContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSYNCHRONIZED, 0)
}

func (s *SynchronizedStmtAltContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *SynchronizedStmtAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *SynchronizedStmtAltContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SynchronizedStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSynchronizedStmtAlt(s)
	}
}

func (s *SynchronizedStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSynchronizedStmtAlt(s)
	}
}

type ExpressionStmtAltContext struct {
	*StatementContext
}

func NewExpressionStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionStmtAltContext {
	var p = new(ExpressionStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ExpressionStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStmtAltContext) StatementExpression() IStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *ExpressionStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterExpressionStmtAlt(s)
	}
}

func (s *ExpressionStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitExpressionStmtAlt(s)
	}
}

type MethodDeclarationStmtAltContext struct {
	*StatementContext
}

func NewMethodDeclarationStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MethodDeclarationStmtAltContext {
	var p = new(MethodDeclarationStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *MethodDeclarationStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationStmtAltContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *MethodDeclarationStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMethodDeclarationStmtAlt(s)
	}
}

func (s *MethodDeclarationStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMethodDeclarationStmtAlt(s)
	}
}

type LocalVariableDeclarationStmtAltContext struct {
	*StatementContext
}

func NewLocalVariableDeclarationStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LocalVariableDeclarationStmtAltContext {
	var p = new(LocalVariableDeclarationStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *LocalVariableDeclarationStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationStmtAltContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *LocalVariableDeclarationStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLocalVariableDeclarationStmtAlt(s)
	}
}

func (s *LocalVariableDeclarationStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLocalVariableDeclarationStmtAlt(s)
	}
}

type ReturnStmtAltContext struct {
	*StatementContext
}

func NewReturnStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReturnStmtAltContext {
	var p = new(ReturnStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ReturnStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtAltContext) RETURN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRETURN, 0)
}

func (s *ReturnStmtAltContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterReturnStmtAlt(s)
	}
}

func (s *ReturnStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitReturnStmtAlt(s)
	}
}

type ThrowStmtAltContext struct {
	*StatementContext
}

func NewThrowStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThrowStmtAltContext {
	var p = new(ThrowStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ThrowStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStmtAltContext) THROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROW, 0)
}

func (s *ThrowStmtAltContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterThrowStmtAlt(s)
	}
}

func (s *ThrowStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitThrowStmtAlt(s)
	}
}

type LabeledStmtAltContext struct {
	*StatementContext
}

func NewLabeledStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabeledStmtAltContext {
	var p = new(LabeledStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *LabeledStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStmtAltContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabeledStmtAltContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *LabeledStmtAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LabeledStmtAltContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabeledStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLabeledStmtAlt(s)
	}
}

func (s *LabeledStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLabeledStmtAlt(s)
	}
}

func (p *GroovyParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, GroovyParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBlockStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1105)
			p.Block()
		}

	case 2:
		localctx = NewConditionalStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1106)
			p.ConditionalStatement()
		}

	case 3:
		localctx = NewLoopStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1107)
			p.LoopStatement()
		}

	case 4:
		localctx = NewTryCatchStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1108)
			p.TryCatchStatement()
		}

	case 5:
		localctx = NewSynchronizedStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1109)
			p.Match(GroovyParserSYNCHRONIZED)
		}
		{
			p.SetState(1110)
			p.ExpressionInPar()
		}
		{
			p.SetState(1111)
			p.Nls()
		}
		{
			p.SetState(1112)
			p.Block()
		}

	case 6:
		localctx = NewReturnStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1114)
			p.Match(GroovyParserRETURN)
		}
		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1090196702704449158) != 0 || (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&52776621060117) != 0 {
			{
				p.SetState(1115)
				p.expression(0)
			}

		}

	case 7:
		localctx = NewThrowStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1118)
			p.Match(GroovyParserTHROW)
		}
		{
			p.SetState(1119)
			p.expression(0)
		}

	case 8:
		localctx = NewBreakStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1120)
			p.BreakStatement()
		}

	case 9:
		localctx = NewContinueStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1121)
			p.ContinueStatement()
		}

	case 10:
		localctx = NewLabeledStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1122)
			p.Identifier()
		}
		{
			p.SetState(1123)
			p.Match(GroovyParserCOLON)
		}
		{
			p.SetState(1124)
			p.Nls()
		}
		{
			p.SetState(1125)
			p.Statement()
		}

	case 11:
		localctx = NewAssertStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1127)
			p.AssertStatement()
		}

	case 12:
		localctx = NewLocalVariableDeclarationStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1128)
			p.LocalVariableDeclaration()
		}

	case 13:
		localctx = NewMethodDeclarationStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1129)
			p.MethodDeclaration(3, 9)
		}

	case 14:
		localctx = NewExpressionStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1130)
			p.StatementExpression()
		}

	case 15:
		localctx = NewEmptyStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1131)
			p.Match(GroovyParserSEMI)
		}

	}

	return localctx
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_catchClause
	return p
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) CATCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserCATCH, 0)
}

func (s *CatchClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *CatchClauseContext) VariableModifiersOpt() IVariableModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersOptContext)
}

func (s *CatchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatchClauseContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *CatchClauseContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) CatchType() ICatchTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchTypeContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCatchClause(s)
	}
}

func (p *GroovyParser) CatchClause() (localctx ICatchClauseContext) {
	this := p
	_ = this

	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, GroovyParserRULE_catchClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1134)
		p.Match(GroovyParserCATCH)
	}
	{
		p.SetState(1135)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(1136)
		p.VariableModifiersOpt()
	}
	p.SetState(1138)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1137)
			p.CatchType()
		}

	}
	{
		p.SetState(1140)
		p.Identifier()
	}
	{
		p.SetState(1141)
		p.Rparen()
	}
	{
		p.SetState(1142)
		p.Nls()
	}
	{
		p.SetState(1143)
		p.Block()
	}

	return localctx
}

// ICatchTypeContext is an interface to support dynamic dispatch.
type ICatchTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchTypeContext differentiates from other interfaces.
	IsCatchTypeContext()
}

type CatchTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchTypeContext() *CatchTypeContext {
	var p = new(CatchTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_catchType
	return p
}

func (*CatchTypeContext) IsCatchTypeContext() {}

func NewCatchTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchTypeContext {
	var p = new(CatchTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_catchType

	return p
}

func (s *CatchTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchTypeContext) AllQualifiedClassName() []IQualifiedClassNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedClassNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedClassNameContext); ok {
			tst[i] = t.(IQualifiedClassNameContext)
			i++
		}
	}

	return tst
}

func (s *CatchTypeContext) QualifiedClassName(i int) IQualifiedClassNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *CatchTypeContext) AllBITOR() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserBITOR)
}

func (s *CatchTypeContext) BITOR(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserBITOR, i)
}

func (s *CatchTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCatchType(s)
	}
}

func (s *CatchTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCatchType(s)
	}
}

func (p *GroovyParser) CatchType() (localctx ICatchTypeContext) {
	this := p
	_ = this

	localctx = NewCatchTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, GroovyParserRULE_catchType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1145)
		p.QualifiedClassName()
	}
	p.SetState(1150)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserBITOR {
		{
			p.SetState(1146)
			p.Match(GroovyParserBITOR)
		}
		{
			p.SetState(1147)
			p.QualifiedClassName()
		}

		p.SetState(1152)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_finallyBlock
	return p
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINALLY, 0)
}

func (s *FinallyBlockContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFinallyBlock(s)
	}
}

func (p *GroovyParser) FinallyBlock() (localctx IFinallyBlockContext) {
	this := p
	_ = this

	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, GroovyParserRULE_finallyBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1153)
		p.Match(GroovyParserFINALLY)
	}
	{
		p.SetState(1154)
		p.Nls()
	}
	{
		p.SetState(1155)
		p.Block()
	}

	return localctx
}

// IResourcesContext is an interface to support dynamic dispatch.
type IResourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourcesContext differentiates from other interfaces.
	IsResourcesContext()
}

type ResourcesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourcesContext() *ResourcesContext {
	var p = new(ResourcesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_resources
	return p
}

func (*ResourcesContext) IsResourcesContext() {}

func NewResourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourcesContext {
	var p = new(ResourcesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_resources

	return p
}

func (s *ResourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourcesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ResourcesContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ResourcesContext) ResourceList() IResourceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceListContext)
}

func (s *ResourcesContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ResourcesContext) Sep() ISepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ResourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterResources(s)
	}
}

func (s *ResourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitResources(s)
	}
}

func (p *GroovyParser) Resources() (localctx IResourcesContext) {
	this := p
	_ = this

	localctx = NewResourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, GroovyParserRULE_resources)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1157)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(1158)
		p.Nls()
	}
	{
		p.SetState(1159)
		p.ResourceList()
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1160)
			p.Sep()
		}

	}
	{
		p.SetState(1163)
		p.Rparen()
	}

	return localctx
}

// IResourceListContext is an interface to support dynamic dispatch.
type IResourceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourceListContext differentiates from other interfaces.
	IsResourceListContext()
}

type ResourceListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceListContext() *ResourceListContext {
	var p = new(ResourceListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_resourceList
	return p
}

func (*ResourceListContext) IsResourceListContext() {}

func NewResourceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceListContext {
	var p = new(ResourceListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_resourceList

	return p
}

func (s *ResourceListContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceListContext) AllResource() []IResourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceContext); ok {
			len++
		}
	}

	tst := make([]IResourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceContext); ok {
			tst[i] = t.(IResourceContext)
			i++
		}
	}

	return tst
}

func (s *ResourceListContext) Resource(i int) IResourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *ResourceListContext) AllSep() []ISepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISepContext); ok {
			len++
		}
	}

	tst := make([]ISepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISepContext); ok {
			tst[i] = t.(ISepContext)
			i++
		}
	}

	return tst
}

func (s *ResourceListContext) Sep(i int) ISepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ResourceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterResourceList(s)
	}
}

func (s *ResourceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitResourceList(s)
	}
}

func (p *GroovyParser) ResourceList() (localctx IResourceListContext) {
	this := p
	_ = this

	localctx = NewResourceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, GroovyParserRULE_resourceList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1165)
		p.Resource()
	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1166)
				p.Sep()
			}
			{
				p.SetState(1167)
				p.Resource()
			}

		}
		p.SetState(1173)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext())
	}

	return localctx
}

// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_resource
	return p
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ResourceContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterResource(s)
	}
}

func (s *ResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitResource(s)
	}
}

func (p *GroovyParser) Resource() (localctx IResourceContext) {
	this := p
	_ = this

	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, GroovyParserRULE_resource)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1176)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1174)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1175)
			p.expression(0)
		}

	}

	return localctx
}

// ISwitchBlockStatementGroupContext is an interface to support dynamic dispatch.
type ISwitchBlockStatementGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchBlockStatementGroupContext differentiates from other interfaces.
	IsSwitchBlockStatementGroupContext()
}

type SwitchBlockStatementGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockStatementGroupContext() *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_switchBlockStatementGroup
	return p
}

func (*SwitchBlockStatementGroupContext) IsSwitchBlockStatementGroupContext() {}

func NewSwitchBlockStatementGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchBlockStatementGroup

	return p
}

func (s *SwitchBlockStatementGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockStatementGroupContext) BlockStatements() IBlockStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *SwitchBlockStatementGroupContext) AllSwitchLabel() []ISwitchLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			len++
		}
	}

	tst := make([]ISwitchLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchLabelContext); ok {
			tst[i] = t.(ISwitchLabelContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupContext) SwitchLabel(i int) ISwitchLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *SwitchBlockStatementGroupContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *SwitchBlockStatementGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockStatementGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockStatementGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSwitchBlockStatementGroup(s)
	}
}

func (s *SwitchBlockStatementGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSwitchBlockStatementGroup(s)
	}
}

func (p *GroovyParser) SwitchBlockStatementGroup() (localctx ISwitchBlockStatementGroupContext) {
	this := p
	_ = this

	localctx = NewSwitchBlockStatementGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, GroovyParserRULE_switchBlockStatementGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1181)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1178)
				p.SwitchLabel()
			}
			{
				p.SetState(1179)
				p.Nls()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1183)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext())
	}
	{
		p.SetState(1185)
		p.BlockStatements()
	}

	return localctx
}

// ISwitchLabelContext is an interface to support dynamic dispatch.
type ISwitchLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchLabelContext differentiates from other interfaces.
	IsSwitchLabelContext()
}

type SwitchLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchLabelContext() *SwitchLabelContext {
	var p = new(SwitchLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_switchLabel
	return p
}

func (*SwitchLabelContext) IsSwitchLabelContext() {}

func NewSwitchLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchLabelContext {
	var p = new(SwitchLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchLabel

	return p
}

func (s *SwitchLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchLabelContext) CASE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCASE, 0)
}

func (s *SwitchLabelContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchLabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *SwitchLabelContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *SwitchLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSwitchLabel(s)
	}
}

func (s *SwitchLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSwitchLabel(s)
	}
}

func (p *GroovyParser) SwitchLabel() (localctx ISwitchLabelContext) {
	this := p
	_ = this

	localctx = NewSwitchLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, GroovyParserRULE_switchLabel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1193)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1187)
			p.Match(GroovyParserCASE)
		}
		{
			p.SetState(1188)
			p.expression(0)
		}
		{
			p.SetState(1189)
			p.Match(GroovyParserCOLON)
		}

	case GroovyParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1191)
			p.Match(GroovyParserDEFAULT)
		}
		{
			p.SetState(1192)
			p.Match(GroovyParserCOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForControlContext is an interface to support dynamic dispatch.
type IForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForControlContext differentiates from other interfaces.
	IsForControlContext()
}

type ForControlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForControlContext() *ForControlContext {
	var p = new(ForControlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_forControl
	return p
}

func (*ForControlContext) IsForControlContext() {}

func NewForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForControlContext {
	var p = new(ForControlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_forControl

	return p
}

func (s *ForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *ForControlContext) EnhancedForControl() IEnhancedForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedForControlContext)
}

func (s *ForControlContext) ClassicalForControl() IClassicalForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassicalForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassicalForControlContext)
}

func (s *ForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterForControl(s)
	}
}

func (s *ForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitForControl(s)
	}
}

func (p *GroovyParser) ForControl() (localctx IForControlContext) {
	this := p
	_ = this

	localctx = NewForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, GroovyParserRULE_forControl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1197)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1195)
			p.EnhancedForControl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1196)
			p.ClassicalForControl()
		}

	}

	return localctx
}

// IEnhancedForControlContext is an interface to support dynamic dispatch.
type IEnhancedForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedForControlContext differentiates from other interfaces.
	IsEnhancedForControlContext()
}

type EnhancedForControlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForControlContext() *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enhancedForControl
	return p
}

func (*EnhancedForControlContext) IsEnhancedForControlContext() {}

func NewEnhancedForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedForControl

	return p
}

func (s *EnhancedForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForControlContext) VariableModifiersOpt() IVariableModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersOptContext)
}

func (s *EnhancedForControlContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *EnhancedForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForControlContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *EnhancedForControlContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *EnhancedForControlContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *EnhancedForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnhancedForControl(s)
	}
}

func (s *EnhancedForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnhancedForControl(s)
	}
}

func (p *GroovyParser) EnhancedForControl() (localctx IEnhancedForControlContext) {
	this := p
	_ = this

	localctx = NewEnhancedForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, GroovyParserRULE_enhancedForControl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1199)
		p.VariableModifiersOpt()
	}
	p.SetState(1201)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1200)
			p.TypeType()
		}

	}
	{
		p.SetState(1203)
		p.VariableDeclaratorId()
	}
	{
		p.SetState(1204)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GroovyParserIN || _la == GroovyParserCOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1205)
		p.expression(0)
	}

	return localctx
}

// IClassicalForControlContext is an interface to support dynamic dispatch.
type IClassicalForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassicalForControlContext differentiates from other interfaces.
	IsClassicalForControlContext()
}

type ClassicalForControlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassicalForControlContext() *ClassicalForControlContext {
	var p = new(ClassicalForControlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classicalForControl
	return p
}

func (*ClassicalForControlContext) IsClassicalForControlContext() {}

func NewClassicalForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassicalForControlContext {
	var p = new(ClassicalForControlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classicalForControl

	return p
}

func (s *ClassicalForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassicalForControlContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserSEMI)
}

func (s *ClassicalForControlContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserSEMI, i)
}

func (s *ClassicalForControlContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ClassicalForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassicalForControlContext) ForUpdate() IForUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *ClassicalForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassicalForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassicalForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassicalForControl(s)
	}
}

func (s *ClassicalForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassicalForControl(s)
	}
}

func (p *GroovyParser) ClassicalForControl() (localctx IClassicalForControlContext) {
	this := p
	_ = this

	localctx = NewClassicalForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, GroovyParserRULE_classicalForControl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1208)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1207)
			p.ForInit()
		}

	}
	{
		p.SetState(1210)
		p.Match(GroovyParserSEMI)
	}
	p.SetState(1212)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1090196702704449158) != 0 || (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&52776621060117) != 0 {
		{
			p.SetState(1211)
			p.expression(0)
		}

	}
	{
		p.SetState(1214)
		p.Match(GroovyParserSEMI)
	}
	p.SetState(1216)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1215)
			p.ForUpdate()
		}

	}

	return localctx
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_forInit
	return p
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ForInitContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterForInit(s)
	}
}

func (s *ForInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitForInit(s)
	}
}

func (p *GroovyParser) ForInit() (localctx IForInitContext) {
	this := p
	_ = this

	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, GroovyParserRULE_forInit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1220)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1218)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1219)
			p.ExpressionList(false)
		}

	}

	return localctx
}

// IForUpdateContext is an interface to support dynamic dispatch.
type IForUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForUpdateContext differentiates from other interfaces.
	IsForUpdateContext()
}

type ForUpdateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForUpdateContext() *ForUpdateContext {
	var p = new(ForUpdateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_forUpdate
	return p
}

func (*ForUpdateContext) IsForUpdateContext() {}

func NewForUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForUpdateContext {
	var p = new(ForUpdateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_forUpdate

	return p
}

func (s *ForUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *ForUpdateContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterForUpdate(s)
	}
}

func (s *ForUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitForUpdate(s)
	}
}

func (p *GroovyParser) ForUpdate() (localctx IForUpdateContext) {
	this := p
	_ = this

	localctx = NewForUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, GroovyParserRULE_forUpdate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1222)
		p.ExpressionList(false)
	}

	return localctx
}

// ICastParExpressionContext is an interface to support dynamic dispatch.
type ICastParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastParExpressionContext differentiates from other interfaces.
	IsCastParExpressionContext()
}

type CastParExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastParExpressionContext() *CastParExpressionContext {
	var p = new(CastParExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_castParExpression
	return p
}

func (*CastParExpressionContext) IsCastParExpressionContext() {}

func NewCastParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastParExpressionContext {
	var p = new(CastParExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_castParExpression

	return p
}

func (s *CastParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastParExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *CastParExpressionContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *CastParExpressionContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *CastParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastParExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCastParExpression(s)
	}
}

func (s *CastParExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCastParExpression(s)
	}
}

func (p *GroovyParser) CastParExpression() (localctx ICastParExpressionContext) {
	this := p
	_ = this

	localctx = NewCastParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, GroovyParserRULE_castParExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1224)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(1225)
		p.TypeType()
	}
	{
		p.SetState(1226)
		p.Rparen()
	}

	return localctx
}

// IParExpressionContext is an interface to support dynamic dispatch.
type IParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParExpressionContext differentiates from other interfaces.
	IsParExpressionContext()
}

type ParExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParExpressionContext() *ParExpressionContext {
	var p = new(ParExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_parExpression
	return p
}

func (*ParExpressionContext) IsParExpressionContext() {}

func NewParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParExpressionContext {
	var p = new(ParExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_parExpression

	return p
}

func (s *ParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParExpressionContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *ParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterParExpression(s)
	}
}

func (s *ParExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitParExpression(s)
	}
}

func (p *GroovyParser) ParExpression() (localctx IParExpressionContext) {
	this := p
	_ = this

	localctx = NewParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, GroovyParserRULE_parExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1228)
		p.ExpressionInPar()
	}

	return localctx
}

// IExpressionInParContext is an interface to support dynamic dispatch.
type IExpressionInParContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionInParContext differentiates from other interfaces.
	IsExpressionInParContext()
}

type ExpressionInParContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionInParContext() *ExpressionInParContext {
	var p = new(ExpressionInParContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_expressionInPar
	return p
}

func (*ExpressionInParContext) IsExpressionInParContext() {}

func NewExpressionInParContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionInParContext {
	var p = new(ExpressionInParContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expressionInPar

	return p
}

func (s *ExpressionInParContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionInParContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ExpressionInParContext) EnhancedStatementExpression() IEnhancedStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedStatementExpressionContext)
}

func (s *ExpressionInParContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ExpressionInParContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionInParContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionInParContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterExpressionInPar(s)
	}
}

func (s *ExpressionInParContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitExpressionInPar(s)
	}
}

func (p *GroovyParser) ExpressionInPar() (localctx IExpressionInParContext) {
	this := p
	_ = this

	localctx = NewExpressionInParContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, GroovyParserRULE_expressionInPar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1230)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(1231)
		p.EnhancedStatementExpression()
	}
	{
		p.SetState(1232)
		p.Rparen()
	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCanSpread returns the canSpread attribute.
	GetCanSpread() bool

	// SetCanSpread sets the canSpread attribute.
	SetCanSpread(bool)

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	canSpread bool
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, canSpread bool) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expressionList

	p.canSpread = canSpread

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) GetCanSpread() bool { return s.canSpread }

func (s *ExpressionListContext) SetCanSpread(v bool) { s.canSpread = v }

func (s *ExpressionListContext) AllExpressionListElement() []IExpressionListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionListElementContext); ok {
			len++
		}
	}

	tst := make([]IExpressionListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionListElementContext); ok {
			tst[i] = t.(IExpressionListElementContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) ExpressionListElement(i int) IExpressionListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListElementContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *GroovyParser) ExpressionList(canSpread bool) (localctx IExpressionListContext) {
	this := p
	_ = this

	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState(), canSpread)
	p.EnterRule(localctx, 222, GroovyParserRULE_expressionList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1234)
		p.ExpressionListElement(localctx.(*ExpressionListContext).canSpread)
	}
	p.SetState(1239)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1235)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(1236)
				p.ExpressionListElement(localctx.(*ExpressionListContext).canSpread)
			}

		}
		p.SetState(1241)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionListElementContext is an interface to support dynamic dispatch.
type IExpressionListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCanSpread returns the canSpread attribute.
	GetCanSpread() bool

	// SetCanSpread sets the canSpread attribute.
	SetCanSpread(bool)

	// IsExpressionListElementContext differentiates from other interfaces.
	IsExpressionListElementContext()
}

type ExpressionListElementContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	canSpread bool
}

func NewEmptyExpressionListElementContext() *ExpressionListElementContext {
	var p = new(ExpressionListElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_expressionListElement
	return p
}

func (*ExpressionListElementContext) IsExpressionListElementContext() {}

func NewExpressionListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, canSpread bool) *ExpressionListElementContext {
	var p = new(ExpressionListElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expressionListElement

	p.canSpread = canSpread

	return p
}

func (s *ExpressionListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListElementContext) GetCanSpread() bool { return s.canSpread }

func (s *ExpressionListElementContext) SetCanSpread(v bool) { s.canSpread = v }

func (s *ExpressionListElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListElementContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *ExpressionListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterExpressionListElement(s)
	}
}

func (s *ExpressionListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitExpressionListElement(s)
	}
}

func (p *GroovyParser) ExpressionListElement(canSpread bool) (localctx IExpressionListElementContext) {
	this := p
	_ = this

	localctx = NewExpressionListElementContext(p, p.GetParserRuleContext(), p.GetState(), canSpread)
	p.EnterRule(localctx, 224, GroovyParserRULE_expressionListElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1244)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserMUL:
		{
			p.SetState(1242)
			p.Match(GroovyParserMUL)
		}

	case GroovyParserStringLiteral, GroovyParserGStringBegin, GroovyParserAS, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserNEW, GroovyParserSTATIC, GroovyParserSUPER, GroovyParserTHIS, GroovyParserVOID, GroovyParserIntegerLiteral, GroovyParserFloatingPointLiteral, GroovyParserBooleanLiteral, GroovyParserNullLiteral, GroovyParserLPAREN, GroovyParserLBRACE, GroovyParserLBRACK, GroovyParserNOT, GroovyParserBITNOT, GroovyParserINC, GroovyParserDEC, GroovyParserADD, GroovyParserSUB, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1246)
		p.expression(0)
	}

	return localctx
}

// IEnhancedStatementExpressionContext is an interface to support dynamic dispatch.
type IEnhancedStatementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedStatementExpressionContext differentiates from other interfaces.
	IsEnhancedStatementExpressionContext()
}

type EnhancedStatementExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedStatementExpressionContext() *EnhancedStatementExpressionContext {
	var p = new(EnhancedStatementExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enhancedStatementExpression
	return p
}

func (*EnhancedStatementExpressionContext) IsEnhancedStatementExpressionContext() {}

func NewEnhancedStatementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedStatementExpressionContext {
	var p = new(EnhancedStatementExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedStatementExpression

	return p
}

func (s *EnhancedStatementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedStatementExpressionContext) StatementExpression() IStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *EnhancedStatementExpressionContext) StandardLambdaExpression() IStandardLambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardLambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardLambdaExpressionContext)
}

func (s *EnhancedStatementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedStatementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedStatementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnhancedStatementExpression(s)
	}
}

func (s *EnhancedStatementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnhancedStatementExpression(s)
	}
}

func (p *GroovyParser) EnhancedStatementExpression() (localctx IEnhancedStatementExpressionContext) {
	this := p
	_ = this

	localctx = NewEnhancedStatementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, GroovyParserRULE_enhancedStatementExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1250)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1248)
			p.StatementExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1249)
			p.StandardLambdaExpression()
		}

	}

	return localctx
}

// IStatementExpressionContext is an interface to support dynamic dispatch.
type IStatementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementExpressionContext differentiates from other interfaces.
	IsStatementExpressionContext()
}

type StatementExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementExpressionContext() *StatementExpressionContext {
	var p = new(StatementExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_statementExpression
	return p
}

func (*StatementExpressionContext) IsStatementExpressionContext() {}

func NewStatementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementExpressionContext {
	var p = new(StatementExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_statementExpression

	return p
}

func (s *StatementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementExpressionContext) CopyFrom(ctx *StatementExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CommandExprAltContext struct {
	*StatementExpressionContext
}

func NewCommandExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommandExprAltContext {
	var p = new(CommandExprAltContext)

	p.StatementExpressionContext = NewEmptyStatementExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementExpressionContext))

	return p
}

func (s *CommandExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandExprAltContext) CommandExpression() ICommandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandExpressionContext)
}

func (s *CommandExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCommandExprAlt(s)
	}
}

func (s *CommandExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCommandExprAlt(s)
	}
}

func (p *GroovyParser) StatementExpression() (localctx IStatementExpressionContext) {
	this := p
	_ = this

	localctx = NewStatementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, GroovyParserRULE_statementExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewCommandExprAltContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1252)
		p.CommandExpression()
	}

	return localctx
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_postfixExpression
	return p
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) GetOp() antlr.Token { return s.op }

func (s *PostfixExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *PostfixExpressionContext) PathExpression() IPathExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathExpressionContext)
}

func (s *PostfixExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(GroovyParserINC, 0)
}

func (s *PostfixExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEC, 0)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPostfixExpression(s)
	}
}

func (p *GroovyParser) PostfixExpression() (localctx IPostfixExpressionContext) {
	this := p
	_ = this

	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, GroovyParserRULE_postfixExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1254)
		p.PathExpression()
	}
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1255)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PostfixExpressionContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserINC || _la == GroovyParserDEC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PostfixExpressionContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CastExprAltForExprContext struct {
	*ExpressionContext
}

func NewCastExprAltForExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExprAltForExprContext {
	var p = new(CastExprAltForExprContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CastExprAltForExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprAltForExprContext) CastParExpression() ICastParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastParExpressionContext)
}

func (s *CastExprAltForExprContext) CastOperandExpression() ICastOperandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastOperandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *CastExprAltForExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCastExprAltForExpr(s)
	}
}

func (s *CastExprAltForExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCastExprAltForExpr(s)
	}
}

type ShiftExprAltContext struct {
	*ExpressionContext
	left    IExpressionContext
	dlOp    antlr.Token
	tgOp    antlr.Token
	dgOp    antlr.Token
	rangeOp antlr.Token
	right   IExpressionContext
}

func NewShiftExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShiftExprAltContext {
	var p = new(ShiftExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ShiftExprAltContext) GetDlOp() antlr.Token { return s.dlOp }

func (s *ShiftExprAltContext) GetTgOp() antlr.Token { return s.tgOp }

func (s *ShiftExprAltContext) GetDgOp() antlr.Token { return s.dgOp }

func (s *ShiftExprAltContext) GetRangeOp() antlr.Token { return s.rangeOp }

func (s *ShiftExprAltContext) SetDlOp(v antlr.Token) { s.dlOp = v }

func (s *ShiftExprAltContext) SetTgOp(v antlr.Token) { s.tgOp = v }

func (s *ShiftExprAltContext) SetDgOp(v antlr.Token) { s.dgOp = v }

func (s *ShiftExprAltContext) SetRangeOp(v antlr.Token) { s.rangeOp = v }

func (s *ShiftExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *ShiftExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *ShiftExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *ShiftExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *ShiftExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ShiftExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ShiftExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ShiftExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShiftExprAltContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserLT)
}

func (s *ShiftExprAltContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, i)
}

func (s *ShiftExprAltContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserGT)
}

func (s *ShiftExprAltContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, i)
}

func (s *ShiftExprAltContext) RANGE_INCLUSIVE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRANGE_INCLUSIVE, 0)
}

func (s *ShiftExprAltContext) RANGE_EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRANGE_EXCLUSIVE, 0)
}

func (s *ShiftExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterShiftExprAlt(s)
	}
}

func (s *ShiftExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitShiftExprAlt(s)
	}
}

type MultipleAssignmentExprAltContext struct {
	*ExpressionContext
	left  IVariableNamesContext
	op    antlr.Token
	right IStatementExpressionContext
}

func NewMultipleAssignmentExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleAssignmentExprAltContext {
	var p = new(MultipleAssignmentExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *MultipleAssignmentExprAltContext) GetOp() antlr.Token { return s.op }

func (s *MultipleAssignmentExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultipleAssignmentExprAltContext) GetLeft() IVariableNamesContext { return s.left }

func (s *MultipleAssignmentExprAltContext) GetRight() IStatementExpressionContext { return s.right }

func (s *MultipleAssignmentExprAltContext) SetLeft(v IVariableNamesContext) { s.left = v }

func (s *MultipleAssignmentExprAltContext) SetRight(v IStatementExpressionContext) { s.right = v }

func (s *MultipleAssignmentExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleAssignmentExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *MultipleAssignmentExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MultipleAssignmentExprAltContext) VariableNames() IVariableNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNamesContext)
}

func (s *MultipleAssignmentExprAltContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *MultipleAssignmentExprAltContext) StatementExpression() IStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *MultipleAssignmentExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMultipleAssignmentExprAlt(s)
	}
}

func (s *MultipleAssignmentExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMultipleAssignmentExprAlt(s)
	}
}

type ExclusiveOrExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewExclusiveOrExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExclusiveOrExprAltContext {
	var p = new(ExclusiveOrExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ExclusiveOrExprAltContext) GetOp() antlr.Token { return s.op }

func (s *ExclusiveOrExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExclusiveOrExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *ExclusiveOrExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *ExclusiveOrExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *ExclusiveOrExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *ExclusiveOrExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusiveOrExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ExclusiveOrExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ExclusiveOrExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExclusiveOrExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExclusiveOrExprAltContext) XOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserXOR, 0)
}

func (s *ExclusiveOrExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterExclusiveOrExprAlt(s)
	}
}

func (s *ExclusiveOrExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitExclusiveOrExprAlt(s)
	}
}

type AdditiveExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewAdditiveExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExprAltContext {
	var p = new(AdditiveExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *AdditiveExprAltContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *AdditiveExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *AdditiveExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *AdditiveExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *AdditiveExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AdditiveExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AdditiveExprAltContext) ADD() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD, 0)
}

func (s *AdditiveExprAltContext) SUB() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB, 0)
}

func (s *AdditiveExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAdditiveExprAlt(s)
	}
}

func (s *AdditiveExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAdditiveExprAlt(s)
	}
}

type RegexExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewRegexExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexExprAltContext {
	var p = new(RegexExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *RegexExprAltContext) GetOp() antlr.Token { return s.op }

func (s *RegexExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *RegexExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *RegexExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *RegexExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *RegexExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *RegexExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegexExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *RegexExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *RegexExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RegexExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RegexExprAltContext) REGEX_FIND() antlr.TerminalNode {
	return s.GetToken(GroovyParserREGEX_FIND, 0)
}

func (s *RegexExprAltContext) REGEX_MATCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserREGEX_MATCH, 0)
}

func (s *RegexExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterRegexExprAlt(s)
	}
}

func (s *RegexExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitRegexExprAlt(s)
	}
}

type UnaryNotExprAltForExprContext struct {
	*ExpressionContext
}

func NewUnaryNotExprAltForExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryNotExprAltForExprContext {
	var p = new(UnaryNotExprAltForExprContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryNotExprAltForExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryNotExprAltForExprContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *UnaryNotExprAltForExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryNotExprAltForExprContext) BITNOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITNOT, 0)
}

func (s *UnaryNotExprAltForExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT, 0)
}

func (s *UnaryNotExprAltForExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterUnaryNotExprAltForExpr(s)
	}
}

func (s *UnaryNotExprAltForExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitUnaryNotExprAltForExpr(s)
	}
}

type ConditionalExprAltContext struct {
	*ExpressionContext
	con IExpressionContext
	tb  IExpressionContext
	fb  IExpressionContext
}

func NewConditionalExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConditionalExprAltContext {
	var p = new(ConditionalExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ConditionalExprAltContext) GetCon() IExpressionContext { return s.con }

func (s *ConditionalExprAltContext) GetTb() IExpressionContext { return s.tb }

func (s *ConditionalExprAltContext) GetFb() IExpressionContext { return s.fb }

func (s *ConditionalExprAltContext) SetCon(v IExpressionContext) { s.con = v }

func (s *ConditionalExprAltContext) SetTb(v IExpressionContext) { s.tb = v }

func (s *ConditionalExprAltContext) SetFb(v IExpressionContext) { s.fb = v }

func (s *ConditionalExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ConditionalExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ConditionalExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConditionalExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalExprAltContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(GroovyParserQUESTION, 0)
}

func (s *ConditionalExprAltContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *ConditionalExprAltContext) ELVIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserELVIS, 0)
}

func (s *ConditionalExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterConditionalExprAlt(s)
	}
}

func (s *ConditionalExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitConditionalExprAlt(s)
	}
}

type PowerExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewPowerExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExprAltContext {
	var p = new(PowerExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PowerExprAltContext) GetOp() antlr.Token { return s.op }

func (s *PowerExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *PowerExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *PowerExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *PowerExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *PowerExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *PowerExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExprAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *PowerExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PowerExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PowerExprAltContext) POWER() antlr.TerminalNode {
	return s.GetToken(GroovyParserPOWER, 0)
}

func (s *PowerExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPowerExprAlt(s)
	}
}

func (s *PowerExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPowerExprAlt(s)
	}
}

type RelationalExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewRelationalExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationalExprAltContext {
	var p = new(RelationalExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *RelationalExprAltContext) GetOp() antlr.Token { return s.op }

func (s *RelationalExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *RelationalExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *RelationalExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *RelationalExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *RelationalExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *RelationalExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *RelationalExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RelationalExprAltContext) LE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLE, 0)
}

func (s *RelationalExprAltContext) GE() antlr.TerminalNode {
	return s.GetToken(GroovyParserGE, 0)
}

func (s *RelationalExprAltContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *RelationalExprAltContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *RelationalExprAltContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *RelationalExprAltContext) NOT_IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT_IN, 0)
}

func (s *RelationalExprAltContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *RelationalExprAltContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *RelationalExprAltContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserINSTANCEOF, 0)
}

func (s *RelationalExprAltContext) NOT_INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT_INSTANCEOF, 0)
}

func (s *RelationalExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterRelationalExprAlt(s)
	}
}

func (s *RelationalExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitRelationalExprAlt(s)
	}
}

type LogicalAndExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewLogicalAndExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndExprAltContext {
	var p = new(LogicalAndExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalAndExprAltContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *LogicalAndExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *LogicalAndExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *LogicalAndExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *LogicalAndExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LogicalAndExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalAndExprAltContext) AND() antlr.TerminalNode {
	return s.GetToken(GroovyParserAND, 0)
}

func (s *LogicalAndExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLogicalAndExprAlt(s)
	}
}

func (s *LogicalAndExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLogicalAndExprAlt(s)
	}
}

type AssignmentExprAltContext struct {
	*ExpressionContext
	left IExpressionContext
	op   antlr.Token
}

func NewAssignmentExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExprAltContext {
	var p = new(AssignmentExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *AssignmentExprAltContext) GetOp() antlr.Token { return s.op }

func (s *AssignmentExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignmentExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *AssignmentExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *AssignmentExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AssignmentExprAltContext) EnhancedStatementExpression() IEnhancedStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedStatementExpressionContext)
}

func (s *AssignmentExprAltContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentExprAltContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *AssignmentExprAltContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserDIV_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserAND_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserOR_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserXOR_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) RSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRSHIFT_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) URSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserURSHIFT_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) LSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLSHIFT_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserMOD_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) POWER_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserPOWER_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) ELVIS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserELVIS_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAssignmentExprAlt(s)
	}
}

func (s *AssignmentExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAssignmentExprAlt(s)
	}
}

type PostfixExprAltForExprContext struct {
	*ExpressionContext
}

func NewPostfixExprAltForExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixExprAltForExprContext {
	var p = new(PostfixExprAltForExprContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PostfixExprAltForExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprAltForExprContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostfixExprAltForExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPostfixExprAltForExpr(s)
	}
}

func (s *PostfixExprAltForExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPostfixExprAltForExpr(s)
	}
}

type MultiplicativeExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewMultiplicativeExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExprAltContext {
	var p = new(MultiplicativeExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *MultiplicativeExprAltContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *MultiplicativeExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *MultiplicativeExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *MultiplicativeExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *MultiplicativeExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MultiplicativeExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultiplicativeExprAltContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *MultiplicativeExprAltContext) DIV() antlr.TerminalNode {
	return s.GetToken(GroovyParserDIV, 0)
}

func (s *MultiplicativeExprAltContext) MOD() antlr.TerminalNode {
	return s.GetToken(GroovyParserMOD, 0)
}

func (s *MultiplicativeExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMultiplicativeExprAlt(s)
	}
}

func (s *MultiplicativeExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMultiplicativeExprAlt(s)
	}
}

type InclusiveOrExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewInclusiveOrExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InclusiveOrExprAltContext {
	var p = new(InclusiveOrExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *InclusiveOrExprAltContext) GetOp() antlr.Token { return s.op }

func (s *InclusiveOrExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *InclusiveOrExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *InclusiveOrExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *InclusiveOrExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *InclusiveOrExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *InclusiveOrExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InclusiveOrExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *InclusiveOrExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *InclusiveOrExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InclusiveOrExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InclusiveOrExprAltContext) BITOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITOR, 0)
}

func (s *InclusiveOrExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterInclusiveOrExprAlt(s)
	}
}

func (s *InclusiveOrExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitInclusiveOrExprAlt(s)
	}
}

type LogicalOrExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewLogicalOrExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrExprAltContext {
	var p = new(LogicalOrExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalOrExprAltContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *LogicalOrExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *LogicalOrExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *LogicalOrExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *LogicalOrExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LogicalOrExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalOrExprAltContext) OR() antlr.TerminalNode {
	return s.GetToken(GroovyParserOR, 0)
}

func (s *LogicalOrExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLogicalOrExprAlt(s)
	}
}

func (s *LogicalOrExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLogicalOrExprAlt(s)
	}
}

type EqualityExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewEqualityExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExprAltContext {
	var p = new(EqualityExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *EqualityExprAltContext) GetOp() antlr.Token { return s.op }

func (s *EqualityExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *EqualityExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *EqualityExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *EqualityExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *EqualityExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *EqualityExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EqualityExprAltContext) IDENTICAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserIDENTICAL, 0)
}

func (s *EqualityExprAltContext) NOT_IDENTICAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT_IDENTICAL, 0)
}

func (s *EqualityExprAltContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserEQUAL, 0)
}

func (s *EqualityExprAltContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOTEQUAL, 0)
}

func (s *EqualityExprAltContext) SPACESHIP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSPACESHIP, 0)
}

func (s *EqualityExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEqualityExprAlt(s)
	}
}

func (s *EqualityExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEqualityExprAlt(s)
	}
}

type AndExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewAndExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AndExprAltContext {
	var p = new(AndExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *AndExprAltContext) GetOp() antlr.Token { return s.op }

func (s *AndExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *AndExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *AndExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *AndExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *AndExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *AndExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *AndExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AndExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AndExprAltContext) BITAND() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITAND, 0)
}

func (s *AndExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAndExprAlt(s)
	}
}

func (s *AndExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAndExprAlt(s)
	}
}

type UnaryAddExprAltForExprContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewUnaryAddExprAltForExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryAddExprAltForExprContext {
	var p = new(UnaryAddExprAltForExprContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryAddExprAltForExprContext) GetOp() antlr.Token { return s.op }

func (s *UnaryAddExprAltForExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryAddExprAltForExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryAddExprAltForExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryAddExprAltForExprContext) INC() antlr.TerminalNode {
	return s.GetToken(GroovyParserINC, 0)
}

func (s *UnaryAddExprAltForExprContext) DEC() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEC, 0)
}

func (s *UnaryAddExprAltForExprContext) ADD() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD, 0)
}

func (s *UnaryAddExprAltForExprContext) SUB() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB, 0)
}

func (s *UnaryAddExprAltForExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterUnaryAddExprAltForExpr(s)
	}
}

func (s *UnaryAddExprAltForExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitUnaryAddExprAltForExpr(s)
	}
}

func (p *GroovyParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *GroovyParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 232
	p.EnterRecursionRule(localctx, 232, GroovyParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1275)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCastExprAltForExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1259)
			p.CastParExpression()
		}
		{
			p.SetState(1260)
			p.CastOperandExpression()
		}

	case 2:
		localctx = NewPostfixExprAltForExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1262)
			p.PostfixExpression()
		}

	case 3:
		localctx = NewUnaryNotExprAltForExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1263)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserNOT || _la == GroovyParserBITNOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1264)
			p.Nls()
		}
		{
			p.SetState(1265)
			p.expression(18)
		}

	case 4:
		localctx = NewUnaryAddExprAltForExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1267)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryAddExprAltForExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-100)) & ^0x3f) == 0 && ((int64(1)<<(_la-100))&15) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryAddExprAltForExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1268)
			p.expression(16)
		}

	case 5:
		localctx = NewMultipleAssignmentExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1269)

			var _x = p.VariableNames()

			localctx.(*MultipleAssignmentExprAltContext).left = _x
		}
		{
			p.SetState(1270)
			p.Nls()
		}
		{
			p.SetState(1271)

			var _m = p.Match(GroovyParserASSIGN)

			localctx.(*MultipleAssignmentExprAltContext).op = _m
		}
		{
			p.SetState(1272)
			p.Nls()
		}
		{
			p.SetState(1273)

			var _x = p.StatementExpression()

			localctx.(*MultipleAssignmentExprAltContext).right = _x
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1387)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1385)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPowerExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*PowerExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1277)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(1278)

					var _m = p.Match(GroovyParserPOWER)

					localctx.(*PowerExprAltContext).op = _m
				}
				{
					p.SetState(1279)
					p.Nls()
				}
				{
					p.SetState(1280)

					var _x = p.expression(18)

					localctx.(*PowerExprAltContext).right = _x
				}

			case 2:
				localctx = NewMultiplicativeExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*MultiplicativeExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1282)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(1283)
					p.Nls()
				}
				{
					p.SetState(1284)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*MultiplicativeExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-104)) & ^0x3f) == 0 && ((int64(1)<<(_la-104))&35) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*MultiplicativeExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1285)
					p.Nls()
				}
				{
					p.SetState(1286)

					var _x = p.expression(16)

					localctx.(*MultiplicativeExprAltContext).right = _x
				}

			case 3:
				localctx = NewAdditiveExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*AdditiveExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1288)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(1289)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*AdditiveExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserADD || _la == GroovyParserSUB) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*AdditiveExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1290)
					p.Nls()
				}
				{
					p.SetState(1291)

					var _x = p.expression(15)

					localctx.(*AdditiveExprAltContext).right = _x
				}

			case 4:
				localctx = NewShiftExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*ShiftExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1293)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(1294)
					p.Nls()
				}
				p.SetState(1305)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case GroovyParserGT, GroovyParserLT:
					p.SetState(1302)
					p.GetErrorHandler().Sync(p)
					switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) {
					case 1:
						{
							p.SetState(1295)

							var _m = p.Match(GroovyParserLT)

							localctx.(*ShiftExprAltContext).dlOp = _m
						}
						{
							p.SetState(1296)
							p.Match(GroovyParserLT)
						}

					case 2:
						{
							p.SetState(1297)

							var _m = p.Match(GroovyParserGT)

							localctx.(*ShiftExprAltContext).tgOp = _m
						}
						{
							p.SetState(1298)
							p.Match(GroovyParserGT)
						}
						{
							p.SetState(1299)
							p.Match(GroovyParserGT)
						}

					case 3:
						{
							p.SetState(1300)

							var _m = p.Match(GroovyParserGT)

							localctx.(*ShiftExprAltContext).dgOp = _m
						}
						{
							p.SetState(1301)
							p.Match(GroovyParserGT)
						}

					}

				case GroovyParserRANGE_INCLUSIVE, GroovyParserRANGE_EXCLUSIVE:
					{
						p.SetState(1304)

						var _lt = p.GetTokenStream().LT(1)

						localctx.(*ShiftExprAltContext).rangeOp = _lt

						_la = p.GetTokenStream().LA(1)

						if !(_la == GroovyParserRANGE_INCLUSIVE || _la == GroovyParserRANGE_EXCLUSIVE) {
							var _ri = p.GetErrorHandler().RecoverInline(p)

							localctx.(*ShiftExprAltContext).rangeOp = _ri
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				{
					p.SetState(1307)
					p.Nls()
				}
				{
					p.SetState(1308)

					var _x = p.expression(14)

					localctx.(*ShiftExprAltContext).right = _x
				}

			case 5:
				localctx = NewRelationalExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*RelationalExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1310)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(1311)
					p.Nls()
				}
				{
					p.SetState(1312)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RelationalExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserIN || (int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&792577) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RelationalExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1313)
					p.Nls()
				}
				{
					p.SetState(1314)

					var _x = p.expression(12)

					localctx.(*RelationalExprAltContext).right = _x
				}

			case 6:
				localctx = NewEqualityExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*EqualityExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1316)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1317)
					p.Nls()
				}
				{
					p.SetState(1318)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*EqualityExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&37748743) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*EqualityExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1319)
					p.Nls()
				}
				{
					p.SetState(1320)

					var _x = p.expression(11)

					localctx.(*EqualityExprAltContext).right = _x
				}

			case 7:
				localctx = NewRegexExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*RegexExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1322)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1323)
					p.Nls()
				}
				{
					p.SetState(1324)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RegexExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserREGEX_FIND || _la == GroovyParserREGEX_MATCH) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RegexExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1325)
					p.Nls()
				}
				{
					p.SetState(1326)

					var _x = p.expression(10)

					localctx.(*RegexExprAltContext).right = _x
				}

			case 8:
				localctx = NewAndExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*AndExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1328)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1329)
					p.Nls()
				}
				{
					p.SetState(1330)

					var _m = p.Match(GroovyParserBITAND)

					localctx.(*AndExprAltContext).op = _m
				}
				{
					p.SetState(1331)
					p.Nls()
				}
				{
					p.SetState(1332)

					var _x = p.expression(9)

					localctx.(*AndExprAltContext).right = _x
				}

			case 9:
				localctx = NewExclusiveOrExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*ExclusiveOrExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1334)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(1335)
					p.Nls()
				}
				{
					p.SetState(1336)

					var _m = p.Match(GroovyParserXOR)

					localctx.(*ExclusiveOrExprAltContext).op = _m
				}
				{
					p.SetState(1337)
					p.Nls()
				}
				{
					p.SetState(1338)

					var _x = p.expression(8)

					localctx.(*ExclusiveOrExprAltContext).right = _x
				}

			case 10:
				localctx = NewInclusiveOrExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*InclusiveOrExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1340)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(1341)
					p.Nls()
				}
				{
					p.SetState(1342)

					var _m = p.Match(GroovyParserBITOR)

					localctx.(*InclusiveOrExprAltContext).op = _m
				}
				{
					p.SetState(1343)
					p.Nls()
				}
				{
					p.SetState(1344)

					var _x = p.expression(7)

					localctx.(*InclusiveOrExprAltContext).right = _x
				}

			case 11:
				localctx = NewLogicalAndExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalAndExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1346)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1347)
					p.Nls()
				}
				{
					p.SetState(1348)

					var _m = p.Match(GroovyParserAND)

					localctx.(*LogicalAndExprAltContext).op = _m
				}
				{
					p.SetState(1349)
					p.Nls()
				}
				{
					p.SetState(1350)

					var _x = p.expression(6)

					localctx.(*LogicalAndExprAltContext).right = _x
				}

			case 12:
				localctx = NewLogicalOrExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalOrExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1352)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(1353)
					p.Nls()
				}
				{
					p.SetState(1354)

					var _m = p.Match(GroovyParserOR)

					localctx.(*LogicalOrExprAltContext).op = _m
				}
				{
					p.SetState(1355)
					p.Nls()
				}
				{
					p.SetState(1356)

					var _x = p.expression(5)

					localctx.(*LogicalOrExprAltContext).right = _x
				}

			case 13:
				localctx = NewConditionalExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConditionalExprAltContext).con = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1358)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1359)
					p.Nls()
				}
				p.SetState(1369)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case GroovyParserQUESTION:
					{
						p.SetState(1360)
						p.Match(GroovyParserQUESTION)
					}
					{
						p.SetState(1361)
						p.Nls()
					}
					{
						p.SetState(1362)

						var _x = p.expression(0)

						localctx.(*ConditionalExprAltContext).tb = _x
					}
					{
						p.SetState(1363)
						p.Nls()
					}
					{
						p.SetState(1364)
						p.Match(GroovyParserCOLON)
					}
					{
						p.SetState(1365)
						p.Nls()
					}

				case GroovyParserELVIS:
					{
						p.SetState(1367)
						p.Match(GroovyParserELVIS)
					}
					{
						p.SetState(1368)
						p.Nls()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				{
					p.SetState(1371)

					var _x = p.expression(3)

					localctx.(*ConditionalExprAltContext).fb = _x
				}

			case 14:
				localctx = NewRelationalExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*RelationalExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1373)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1374)
					p.Nls()
				}
				{
					p.SetState(1375)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RelationalExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserAS || _la == GroovyParserINSTANCEOF || _la == GroovyParserNOT_INSTANCEOF) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RelationalExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1376)
					p.Nls()
				}
				{
					p.SetState(1377)
					p.TypeType()
				}

			case 15:
				localctx = NewAssignmentExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*AssignmentExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1379)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1380)
					p.Nls()
				}
				{
					p.SetState(1381)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*AssignmentExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&2251250057936897) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*AssignmentExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1382)
					p.Nls()
				}
				{
					p.SetState(1383)
					p.EnhancedStatementExpression()
				}

			}

		}
		p.SetState(1389)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())
	}

	return localctx
}

// ICastOperandExpressionContext is an interface to support dynamic dispatch.
type ICastOperandExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastOperandExpressionContext differentiates from other interfaces.
	IsCastOperandExpressionContext()
}

type CastOperandExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastOperandExpressionContext() *CastOperandExpressionContext {
	var p = new(CastOperandExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_castOperandExpression
	return p
}

func (*CastOperandExpressionContext) IsCastOperandExpressionContext() {}

func NewCastOperandExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastOperandExpressionContext {
	var p = new(CastOperandExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_castOperandExpression

	return p
}

func (s *CastOperandExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastOperandExpressionContext) CopyFrom(ctx *CastOperandExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CastOperandExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastOperandExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PostfixExprAltContext struct {
	*CastOperandExpressionContext
}

func NewPostfixExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixExprAltContext {
	var p = new(PostfixExprAltContext)

	p.CastOperandExpressionContext = NewEmptyCastOperandExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *PostfixExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprAltContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostfixExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPostfixExprAlt(s)
	}
}

func (s *PostfixExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPostfixExprAlt(s)
	}
}

type UnaryNotExprAltContext struct {
	*CastOperandExpressionContext
}

func NewUnaryNotExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryNotExprAltContext {
	var p = new(UnaryNotExprAltContext)

	p.CastOperandExpressionContext = NewEmptyCastOperandExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *UnaryNotExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryNotExprAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *UnaryNotExprAltContext) CastOperandExpression() ICastOperandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastOperandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *UnaryNotExprAltContext) BITNOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITNOT, 0)
}

func (s *UnaryNotExprAltContext) NOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT, 0)
}

func (s *UnaryNotExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterUnaryNotExprAlt(s)
	}
}

func (s *UnaryNotExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitUnaryNotExprAlt(s)
	}
}

type UnaryAddExprAltContext struct {
	*CastOperandExpressionContext
	op antlr.Token
}

func NewUnaryAddExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryAddExprAltContext {
	var p = new(UnaryAddExprAltContext)

	p.CastOperandExpressionContext = NewEmptyCastOperandExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *UnaryAddExprAltContext) GetOp() antlr.Token { return s.op }

func (s *UnaryAddExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryAddExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryAddExprAltContext) CastOperandExpression() ICastOperandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastOperandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *UnaryAddExprAltContext) INC() antlr.TerminalNode {
	return s.GetToken(GroovyParserINC, 0)
}

func (s *UnaryAddExprAltContext) DEC() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEC, 0)
}

func (s *UnaryAddExprAltContext) ADD() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD, 0)
}

func (s *UnaryAddExprAltContext) SUB() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB, 0)
}

func (s *UnaryAddExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterUnaryAddExprAlt(s)
	}
}

func (s *UnaryAddExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitUnaryAddExprAlt(s)
	}
}

type CastExprAltContext struct {
	*CastOperandExpressionContext
}

func NewCastExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExprAltContext {
	var p = new(CastExprAltContext)

	p.CastOperandExpressionContext = NewEmptyCastOperandExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *CastExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprAltContext) CastParExpression() ICastParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastParExpressionContext)
}

func (s *CastExprAltContext) CastOperandExpression() ICastOperandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastOperandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *CastExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCastExprAlt(s)
	}
}

func (s *CastExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCastExprAlt(s)
	}
}

func (p *GroovyParser) CastOperandExpression() (localctx ICastOperandExpressionContext) {
	this := p
	_ = this

	localctx = NewCastOperandExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, GroovyParserRULE_castOperandExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1400)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCastExprAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1390)
			p.CastParExpression()
		}
		{
			p.SetState(1391)
			p.CastOperandExpression()
		}

	case 2:
		localctx = NewPostfixExprAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1393)
			p.PostfixExpression()
		}

	case 3:
		localctx = NewUnaryNotExprAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1394)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserNOT || _la == GroovyParserBITNOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1395)
			p.Nls()
		}
		{
			p.SetState(1396)
			p.CastOperandExpression()
		}

	case 4:
		localctx = NewUnaryAddExprAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1398)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryAddExprAltContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-100)) & ^0x3f) == 0 && ((int64(1)<<(_la-100))&15) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryAddExprAltContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1399)
			p.CastOperandExpression()
		}

	}

	return localctx
}

// ICommandExpressionContext is an interface to support dynamic dispatch.
type ICommandExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommandExpressionContext differentiates from other interfaces.
	IsCommandExpressionContext()
}

type CommandExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandExpressionContext() *CommandExpressionContext {
	var p = new(CommandExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_commandExpression
	return p
}

func (*CommandExpressionContext) IsCommandExpressionContext() {}

func NewCommandExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandExpressionContext {
	var p = new(CommandExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_commandExpression

	return p
}

func (s *CommandExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CommandExpressionContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *CommandExpressionContext) AllCommandArgument() []ICommandArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommandArgumentContext); ok {
			len++
		}
	}

	tst := make([]ICommandArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommandArgumentContext); ok {
			tst[i] = t.(ICommandArgumentContext)
			i++
		}
	}

	return tst
}

func (s *CommandExpressionContext) CommandArgument(i int) ICommandArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandArgumentContext)
}

func (s *CommandExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCommandExpression(s)
	}
}

func (s *CommandExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCommandExpression(s)
	}
}

func (p *GroovyParser) CommandExpression() (localctx ICommandExpressionContext) {
	this := p
	_ = this

	localctx = NewCommandExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, GroovyParserRULE_commandExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1402)
		p.expression(0)
	}
	p.SetState(1405)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1403)
			p.ArgumentList()
		}

	case 2:

	}
	p.SetState(1410)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1407)
				p.CommandArgument()
			}

		}
		p.SetState(1412)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext())
	}

	return localctx
}

// ICommandArgumentContext is an interface to support dynamic dispatch.
type ICommandArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommandArgumentContext differentiates from other interfaces.
	IsCommandArgumentContext()
}

type CommandArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandArgumentContext() *CommandArgumentContext {
	var p = new(CommandArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_commandArgument
	return p
}

func (*CommandArgumentContext) IsCommandArgumentContext() {}

func NewCommandArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandArgumentContext {
	var p = new(CommandArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_commandArgument

	return p
}

func (s *CommandArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandArgumentContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *CommandArgumentContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *CommandArgumentContext) AllPathElement() []IPathElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathElementContext); ok {
			len++
		}
	}

	tst := make([]IPathElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathElementContext); ok {
			tst[i] = t.(IPathElementContext)
			i++
		}
	}

	return tst
}

func (s *CommandArgumentContext) PathElement(i int) IPathElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathElementContext)
}

func (s *CommandArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCommandArgument(s)
	}
}

func (s *CommandArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCommandArgument(s)
	}
}

func (p *GroovyParser) CommandArgument() (localctx ICommandArgumentContext) {
	this := p
	_ = this

	localctx = NewCommandArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, GroovyParserRULE_commandArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1413)
		p.Primary()
	}
	p.SetState(1420)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		p.SetState(1415)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1414)
					p.PathElement()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1417)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1419)
			p.ArgumentList()
		}

	}

	return localctx
}

// IPathExpressionContext is an interface to support dynamic dispatch.
type IPathExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_pathElement returns the _pathElement rule contexts.
	Get_pathElement() IPathElementContext

	// Set_pathElement sets the _pathElement rule contexts.
	Set_pathElement(IPathElementContext)

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsPathExpressionContext differentiates from other interfaces.
	IsPathExpressionContext()
}

type PathExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	t            int
	_pathElement IPathElementContext
}

func NewEmptyPathExpressionContext() *PathExpressionContext {
	var p = new(PathExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_pathExpression
	return p
}

func (*PathExpressionContext) IsPathExpressionContext() {}

func NewPathExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathExpressionContext {
	var p = new(PathExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_pathExpression

	return p
}

func (s *PathExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PathExpressionContext) Get_pathElement() IPathElementContext { return s._pathElement }

func (s *PathExpressionContext) Set_pathElement(v IPathElementContext) { s._pathElement = v }

func (s *PathExpressionContext) GetT() int { return s.t }

func (s *PathExpressionContext) SetT(v int) { s.t = v }

func (s *PathExpressionContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *PathExpressionContext) AllPathElement() []IPathElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathElementContext); ok {
			len++
		}
	}

	tst := make([]IPathElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathElementContext); ok {
			tst[i] = t.(IPathElementContext)
			i++
		}
	}

	return tst
}

func (s *PathExpressionContext) PathElement(i int) IPathElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathElementContext)
}

func (s *PathExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPathExpression(s)
	}
}

func (s *PathExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPathExpression(s)
	}
}

func (p *GroovyParser) PathExpression() (localctx IPathExpressionContext) {
	this := p
	_ = this

	localctx = NewPathExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, GroovyParserRULE_pathExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1422)
		p.Primary()
	}
	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1423)

				var _x = p.PathElement()

				localctx.(*PathExpressionContext)._pathElement = _x
			}
			localctx.(*PathExpressionContext).SetT(localctx.(*PathExpressionContext).Get_pathElement().GetT())

		}
		p.SetState(1430)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())
	}

	return localctx
}

// IPathElementContext is an interface to support dynamic dispatch.
type IPathElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsPathElementContext differentiates from other interfaces.
	IsPathElementContext()
}

type PathElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyPathElementContext() *PathElementContext {
	var p = new(PathElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_pathElement
	return p
}

func (*PathElementContext) IsPathElementContext() {}

func NewPathElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathElementContext {
	var p = new(PathElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_pathElement

	return p
}

func (s *PathElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PathElementContext) GetT() int { return s.t }

func (s *PathElementContext) SetT(v int) { s.t = v }

func (s *PathElementContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *PathElementContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *PathElementContext) NamePart() INamePartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamePartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamePartContext)
}

func (s *PathElementContext) METHOD_POINTER() antlr.TerminalNode {
	return s.GetToken(GroovyParserMETHOD_POINTER, 0)
}

func (s *PathElementContext) METHOD_REFERENCE() antlr.TerminalNode {
	return s.GetToken(GroovyParserMETHOD_REFERENCE, 0)
}

func (s *PathElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, 0)
}

func (s *PathElementContext) SPREAD_DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserSPREAD_DOT, 0)
}

func (s *PathElementContext) SAFE_DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserSAFE_DOT, 0)
}

func (s *PathElementContext) SAFE_CHAIN_DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserSAFE_CHAIN_DOT, 0)
}

func (s *PathElementContext) AT() antlr.TerminalNode {
	return s.GetToken(GroovyParserAT, 0)
}

func (s *PathElementContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *PathElementContext) NEW() antlr.TerminalNode {
	return s.GetToken(GroovyParserNEW, 0)
}

func (s *PathElementContext) Creator() ICreatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatorContext)
}

func (s *PathElementContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *PathElementContext) ClosureOrLambdaExpression() IClosureOrLambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureOrLambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureOrLambdaExpressionContext)
}

func (s *PathElementContext) IndexPropertyArgs() IIndexPropertyArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexPropertyArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexPropertyArgsContext)
}

func (s *PathElementContext) NamedPropertyArgs() INamedPropertyArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedPropertyArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedPropertyArgsContext)
}

func (s *PathElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPathElement(s)
	}
}

func (s *PathElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPathElement(s)
	}
}

func (p *GroovyParser) PathElement() (localctx IPathElementContext) {
	this := p
	_ = this

	localctx = NewPathElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, GroovyParserRULE_pathElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1467)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1431)
			p.Nls()
		}
		p.SetState(1442)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case GroovyParserSPREAD_DOT, GroovyParserSAFE_DOT, GroovyParserSAFE_CHAIN_DOT, GroovyParserDOT:
			{
				p.SetState(1432)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-62)) & ^0x3f) == 0 && ((int64(1)<<(_la-62))&16777223) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1433)
				p.Nls()
			}
			p.SetState(1436)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case GroovyParserAT:
				{
					p.SetState(1434)
					p.Match(GroovyParserAT)
				}

			case GroovyParserLT:
				{
					p.SetState(1435)
					p.NonWildcardTypeArguments()
				}

			case GroovyParserStringLiteral, GroovyParserGStringBegin, GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserTHREADSAFE, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserABSTRACT, GroovyParserASSERT, GroovyParserBREAK, GroovyParserCASE, GroovyParserCATCH, GroovyParserCLASS, GroovyParserCONST, GroovyParserCONTINUE, GroovyParserDEFAULT, GroovyParserDO, GroovyParserELSE, GroovyParserENUM, GroovyParserEXTENDS, GroovyParserFINAL, GroovyParserFINALLY, GroovyParserFOR, GroovyParserIF, GroovyParserGOTO, GroovyParserIMPLEMENTS, GroovyParserIMPORT, GroovyParserINSTANCEOF, GroovyParserINTERFACE, GroovyParserNATIVE, GroovyParserNEW, GroovyParserPACKAGE, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserRETURN, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserSUPER, GroovyParserSWITCH, GroovyParserSYNCHRONIZED, GroovyParserTHIS, GroovyParserTHROW, GroovyParserTHROWS, GroovyParserTRANSIENT, GroovyParserTRY, GroovyParserVOID, GroovyParserVOLATILE, GroovyParserWHILE, GroovyParserBooleanLiteral, GroovyParserNullLiteral, GroovyParserLPAREN, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:

			default:
			}

		case GroovyParserMETHOD_POINTER:
			{
				p.SetState(1438)
				p.Match(GroovyParserMETHOD_POINTER)
			}
			{
				p.SetState(1439)
				p.Nls()
			}

		case GroovyParserMETHOD_REFERENCE:
			{
				p.SetState(1440)
				p.Match(GroovyParserMETHOD_REFERENCE)
			}
			{
				p.SetState(1441)
				p.Nls()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1444)
			p.NamePart()
		}
		localctx.(*PathElementContext).SetT(1)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1447)
			p.Nls()
		}
		{
			p.SetState(1448)
			p.Match(GroovyParserDOT)
		}
		{
			p.SetState(1449)
			p.Nls()
		}
		{
			p.SetState(1450)
			p.Match(GroovyParserNEW)
		}
		{
			p.SetState(1451)
			p.Creator(1)
		}
		localctx.(*PathElementContext).SetT(6)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1454)
			p.Arguments()
		}
		localctx.(*PathElementContext).SetT(2)

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1457)
			p.Nls()
		}
		{
			p.SetState(1458)
			p.ClosureOrLambdaExpression()
		}
		localctx.(*PathElementContext).SetT(3)

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1461)
			p.IndexPropertyArgs()
		}
		localctx.(*PathElementContext).SetT(4)

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1464)
			p.NamedPropertyArgs()
		}
		localctx.(*PathElementContext).SetT(5)

	}

	return localctx
}

// INamePartContext is an interface to support dynamic dispatch.
type INamePartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamePartContext differentiates from other interfaces.
	IsNamePartContext()
}

type NamePartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamePartContext() *NamePartContext {
	var p = new(NamePartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_namePart
	return p
}

func (*NamePartContext) IsNamePartContext() {}

func NewNamePartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamePartContext {
	var p = new(NamePartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namePart

	return p
}

func (s *NamePartContext) GetParser() antlr.Parser { return s.parser }

func (s *NamePartContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamePartContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *NamePartContext) DynamicMemberName() IDynamicMemberNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamicMemberNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamicMemberNameContext)
}

func (s *NamePartContext) Keywords() IKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *NamePartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamePartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamePartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNamePart(s)
	}
}

func (s *NamePartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNamePart(s)
	}
}

func (p *GroovyParser) NamePart() (localctx INamePartContext) {
	this := p
	_ = this

	localctx = NewNamePartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, GroovyParserRULE_namePart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1469)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(1470)
			p.StringLiteral()
		}

	case 3:
		{
			p.SetState(1471)
			p.DynamicMemberName()
		}

	case 4:
		{
			p.SetState(1472)
			p.Keywords()
		}

	}

	return localctx
}

// IDynamicMemberNameContext is an interface to support dynamic dispatch.
type IDynamicMemberNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDynamicMemberNameContext differentiates from other interfaces.
	IsDynamicMemberNameContext()
}

type DynamicMemberNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDynamicMemberNameContext() *DynamicMemberNameContext {
	var p = new(DynamicMemberNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_dynamicMemberName
	return p
}

func (*DynamicMemberNameContext) IsDynamicMemberNameContext() {}

func NewDynamicMemberNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DynamicMemberNameContext {
	var p = new(DynamicMemberNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_dynamicMemberName

	return p
}

func (s *DynamicMemberNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DynamicMemberNameContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *DynamicMemberNameContext) Gstring() IGstringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGstringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *DynamicMemberNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DynamicMemberNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DynamicMemberNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterDynamicMemberName(s)
	}
}

func (s *DynamicMemberNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitDynamicMemberName(s)
	}
}

func (p *GroovyParser) DynamicMemberName() (localctx IDynamicMemberNameContext) {
	this := p
	_ = this

	localctx = NewDynamicMemberNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, GroovyParserRULE_dynamicMemberName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1477)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1475)
			p.ParExpression()
		}

	case GroovyParserGStringBegin:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1476)
			p.Gstring()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndexPropertyArgsContext is an interface to support dynamic dispatch.
type IIndexPropertyArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexPropertyArgsContext differentiates from other interfaces.
	IsIndexPropertyArgsContext()
}

type IndexPropertyArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexPropertyArgsContext() *IndexPropertyArgsContext {
	var p = new(IndexPropertyArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_indexPropertyArgs
	return p
}

func (*IndexPropertyArgsContext) IsIndexPropertyArgsContext() {}

func NewIndexPropertyArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexPropertyArgsContext {
	var p = new(IndexPropertyArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_indexPropertyArgs

	return p
}

func (s *IndexPropertyArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexPropertyArgsContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *IndexPropertyArgsContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *IndexPropertyArgsContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(GroovyParserQUESTION, 0)
}

func (s *IndexPropertyArgsContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *IndexPropertyArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexPropertyArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexPropertyArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterIndexPropertyArgs(s)
	}
}

func (s *IndexPropertyArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitIndexPropertyArgs(s)
	}
}

func (p *GroovyParser) IndexPropertyArgs() (localctx IIndexPropertyArgsContext) {
	this := p
	_ = this

	localctx = NewIndexPropertyArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, GroovyParserRULE_indexPropertyArgs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1480)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserQUESTION {
		{
			p.SetState(1479)
			p.Match(GroovyParserQUESTION)
		}

	}
	{
		p.SetState(1482)
		p.Match(GroovyParserLBRACK)
	}
	p.SetState(1484)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1090196702704449158) != 0 || (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&52776688168981) != 0 {
		{
			p.SetState(1483)
			p.ExpressionList(true)
		}

	}
	{
		p.SetState(1486)
		p.Match(GroovyParserRBRACK)
	}

	return localctx
}

// INamedPropertyArgsContext is an interface to support dynamic dispatch.
type INamedPropertyArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedPropertyArgsContext differentiates from other interfaces.
	IsNamedPropertyArgsContext()
}

type NamedPropertyArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedPropertyArgsContext() *NamedPropertyArgsContext {
	var p = new(NamedPropertyArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_namedPropertyArgs
	return p
}

func (*NamedPropertyArgsContext) IsNamedPropertyArgsContext() {}

func NewNamedPropertyArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedPropertyArgsContext {
	var p = new(NamedPropertyArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namedPropertyArgs

	return p
}

func (s *NamedPropertyArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedPropertyArgsContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *NamedPropertyArgsContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *NamedPropertyArgsContext) MapEntryList() IMapEntryListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapEntryListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapEntryListContext)
}

func (s *NamedPropertyArgsContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *NamedPropertyArgsContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(GroovyParserQUESTION, 0)
}

func (s *NamedPropertyArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedPropertyArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedPropertyArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNamedPropertyArgs(s)
	}
}

func (s *NamedPropertyArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNamedPropertyArgs(s)
	}
}

func (p *GroovyParser) NamedPropertyArgs() (localctx INamedPropertyArgsContext) {
	this := p
	_ = this

	localctx = NewNamedPropertyArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, GroovyParserRULE_namedPropertyArgs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserQUESTION {
		{
			p.SetState(1488)
			p.Match(GroovyParserQUESTION)
		}

	}
	{
		p.SetState(1491)
		p.Match(GroovyParserLBRACK)
	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserStringLiteral, GroovyParserGStringBegin, GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserTHREADSAFE, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserABSTRACT, GroovyParserASSERT, GroovyParserBREAK, GroovyParserCASE, GroovyParserCATCH, GroovyParserCLASS, GroovyParserCONST, GroovyParserCONTINUE, GroovyParserDEFAULT, GroovyParserDO, GroovyParserELSE, GroovyParserENUM, GroovyParserEXTENDS, GroovyParserFINAL, GroovyParserFINALLY, GroovyParserFOR, GroovyParserIF, GroovyParserGOTO, GroovyParserIMPLEMENTS, GroovyParserIMPORT, GroovyParserINSTANCEOF, GroovyParserINTERFACE, GroovyParserNATIVE, GroovyParserNEW, GroovyParserPACKAGE, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserRETURN, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserSUPER, GroovyParserSWITCH, GroovyParserSYNCHRONIZED, GroovyParserTHIS, GroovyParserTHROW, GroovyParserTHROWS, GroovyParserTRANSIENT, GroovyParserTRY, GroovyParserVOID, GroovyParserVOLATILE, GroovyParserWHILE, GroovyParserIntegerLiteral, GroovyParserFloatingPointLiteral, GroovyParserBooleanLiteral, GroovyParserNullLiteral, GroovyParserLPAREN, GroovyParserLBRACE, GroovyParserLBRACK, GroovyParserMUL, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		{
			p.SetState(1492)
			p.MapEntryList()
		}

	case GroovyParserCOLON:
		{
			p.SetState(1493)
			p.Match(GroovyParserCOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1496)
		p.Match(GroovyParserRBRACK)
	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) CopyFrom(ctx *PrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MapPrmrAltContext struct {
	*PrimaryContext
}

func NewMapPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapPrmrAltContext {
	var p = new(MapPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *MapPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapPrmrAltContext) NormalMap() INormalMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalMapContext)
}

func (s *MapPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMapPrmrAlt(s)
	}
}

func (s *MapPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMapPrmrAlt(s)
	}
}

type GstringPrmrAltContext struct {
	*PrimaryContext
}

func NewGstringPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GstringPrmrAltContext {
	var p = new(GstringPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *GstringPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringPrmrAltContext) Gstring() IGstringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGstringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *GstringPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterGstringPrmrAlt(s)
	}
}

func (s *GstringPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitGstringPrmrAlt(s)
	}
}

type ListPrmrAltContext struct {
	*PrimaryContext
}

func NewListPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListPrmrAltContext {
	var p = new(ListPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *ListPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPrmrAltContext) List() IListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListContext)
}

func (s *ListPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterListPrmrAlt(s)
	}
}

func (s *ListPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitListPrmrAlt(s)
	}
}

type NewPrmrAltContext struct {
	*PrimaryContext
}

func NewNewPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewPrmrAltContext {
	var p = new(NewPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *NewPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewPrmrAltContext) NEW() antlr.TerminalNode {
	return s.GetToken(GroovyParserNEW, 0)
}

func (s *NewPrmrAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *NewPrmrAltContext) Creator() ICreatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatorContext)
}

func (s *NewPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNewPrmrAlt(s)
	}
}

func (s *NewPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNewPrmrAlt(s)
	}
}

type LiteralPrmrAltContext struct {
	*PrimaryContext
}

func NewLiteralPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralPrmrAltContext {
	var p = new(LiteralPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *LiteralPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralPrmrAltContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLiteralPrmrAlt(s)
	}
}

func (s *LiteralPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLiteralPrmrAlt(s)
	}
}

type ThisPrmrAltContext struct {
	*PrimaryContext
}

func NewThisPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisPrmrAltContext {
	var p = new(ThisPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *ThisPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisPrmrAltContext) THIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHIS, 0)
}

func (s *ThisPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterThisPrmrAlt(s)
	}
}

func (s *ThisPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitThisPrmrAlt(s)
	}
}

type ClosureOrLambdaExpressionPrmrAltContext struct {
	*PrimaryContext
}

func NewClosureOrLambdaExpressionPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClosureOrLambdaExpressionPrmrAltContext {
	var p = new(ClosureOrLambdaExpressionPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *ClosureOrLambdaExpressionPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureOrLambdaExpressionPrmrAltContext) ClosureOrLambdaExpression() IClosureOrLambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureOrLambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureOrLambdaExpressionContext)
}

func (s *ClosureOrLambdaExpressionPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClosureOrLambdaExpressionPrmrAlt(s)
	}
}

func (s *ClosureOrLambdaExpressionPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClosureOrLambdaExpressionPrmrAlt(s)
	}
}

type BuiltInTypePrmrAltContext struct {
	*PrimaryContext
}

func NewBuiltInTypePrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BuiltInTypePrmrAltContext {
	var p = new(BuiltInTypePrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *BuiltInTypePrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltInTypePrmrAltContext) BuiltInType() IBuiltInTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBuiltInTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBuiltInTypeContext)
}

func (s *BuiltInTypePrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBuiltInTypePrmrAlt(s)
	}
}

func (s *BuiltInTypePrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBuiltInTypePrmrAlt(s)
	}
}

type IdentifierPrmrAltContext struct {
	*PrimaryContext
}

func NewIdentifierPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierPrmrAltContext {
	var p = new(IdentifierPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *IdentifierPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPrmrAltContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierPrmrAltContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *IdentifierPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterIdentifierPrmrAlt(s)
	}
}

func (s *IdentifierPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitIdentifierPrmrAlt(s)
	}
}

type SuperPrmrAltContext struct {
	*PrimaryContext
}

func NewSuperPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuperPrmrAltContext {
	var p = new(SuperPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *SuperPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperPrmrAltContext) SUPER() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUPER, 0)
}

func (s *SuperPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSuperPrmrAlt(s)
	}
}

func (s *SuperPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSuperPrmrAlt(s)
	}
}

type ParenPrmrAltContext struct {
	*PrimaryContext
}

func NewParenPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenPrmrAltContext {
	var p = new(ParenPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *ParenPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenPrmrAltContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *ParenPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterParenPrmrAlt(s)
	}
}

func (s *ParenPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitParenPrmrAlt(s)
	}
}

func (p *GroovyParser) Primary() (localctx IPrimaryContext) {
	this := p
	_ = this

	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, GroovyParserRULE_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIdentifierPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1498)
			p.Identifier()
		}
		p.SetState(1500)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1499)
				p.TypeArguments()
			}

		}

	case 2:
		localctx = NewLiteralPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1502)
			p.Literal()
		}

	case 3:
		localctx = NewGstringPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1503)
			p.Gstring()
		}

	case 4:
		localctx = NewNewPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1504)
			p.Match(GroovyParserNEW)
		}
		{
			p.SetState(1505)
			p.Nls()
		}
		{
			p.SetState(1506)
			p.Creator(0)
		}

	case 5:
		localctx = NewThisPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1508)
			p.Match(GroovyParserTHIS)
		}

	case 6:
		localctx = NewSuperPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1509)
			p.Match(GroovyParserSUPER)
		}

	case 7:
		localctx = NewParenPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1510)
			p.ParExpression()
		}

	case 8:
		localctx = NewClosureOrLambdaExpressionPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1511)
			p.ClosureOrLambdaExpression()
		}

	case 9:
		localctx = NewListPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1512)
			p.List()
		}

	case 10:
		localctx = NewMapPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1513)
			p.NormalMap()
		}

	case 11:
		localctx = NewBuiltInTypePrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1514)
			p.BuiltInType()
		}

	}

	return localctx
}

// IListContext is an interface to support dynamic dispatch.
type IListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListContext differentiates from other interfaces.
	IsListContext()
}

type ListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListContext() *ListContext {
	var p = new(ListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_list
	return p
}

func (*ListContext) IsListContext() {}

func NewListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListContext {
	var p = new(ListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_list

	return p
}

func (s *ListContext) GetParser() antlr.Parser { return s.parser }

func (s *ListContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *ListContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *ListContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *ListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterList(s)
	}
}

func (s *ListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitList(s)
	}
}

func (p *GroovyParser) List() (localctx IListContext) {
	this := p
	_ = this

	localctx = NewListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, GroovyParserRULE_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1517)
		p.Match(GroovyParserLBRACK)
	}
	p.SetState(1519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1090196702704449158) != 0 || (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&52776688168981) != 0 {
		{
			p.SetState(1518)
			p.ExpressionList(true)
		}

	}
	p.SetState(1522)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserCOMMA {
		{
			p.SetState(1521)
			p.Match(GroovyParserCOMMA)
		}

	}
	{
		p.SetState(1524)
		p.Match(GroovyParserRBRACK)
	}

	return localctx
}

// INormalMapContext is an interface to support dynamic dispatch.
type INormalMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNormalMapContext differentiates from other interfaces.
	IsNormalMapContext()
}

type NormalMapContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalMapContext() *NormalMapContext {
	var p = new(NormalMapContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_normalMap
	return p
}

func (*NormalMapContext) IsNormalMapContext() {}

func NewNormalMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalMapContext {
	var p = new(NormalMapContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_normalMap

	return p
}

func (s *NormalMapContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalMapContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *NormalMapContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *NormalMapContext) MapEntryList() IMapEntryListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapEntryListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapEntryListContext)
}

func (s *NormalMapContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *NormalMapContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *NormalMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNormalMap(s)
	}
}

func (s *NormalMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNormalMap(s)
	}
}

func (p *GroovyParser) NormalMap() (localctx INormalMapContext) {
	this := p
	_ = this

	localctx = NewNormalMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, GroovyParserRULE_normalMap)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1526)
		p.Match(GroovyParserLBRACK)
	}
	p.SetState(1532)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserStringLiteral, GroovyParserGStringBegin, GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserTHREADSAFE, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserABSTRACT, GroovyParserASSERT, GroovyParserBREAK, GroovyParserCASE, GroovyParserCATCH, GroovyParserCLASS, GroovyParserCONST, GroovyParserCONTINUE, GroovyParserDEFAULT, GroovyParserDO, GroovyParserELSE, GroovyParserENUM, GroovyParserEXTENDS, GroovyParserFINAL, GroovyParserFINALLY, GroovyParserFOR, GroovyParserIF, GroovyParserGOTO, GroovyParserIMPLEMENTS, GroovyParserIMPORT, GroovyParserINSTANCEOF, GroovyParserINTERFACE, GroovyParserNATIVE, GroovyParserNEW, GroovyParserPACKAGE, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserRETURN, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserSUPER, GroovyParserSWITCH, GroovyParserSYNCHRONIZED, GroovyParserTHIS, GroovyParserTHROW, GroovyParserTHROWS, GroovyParserTRANSIENT, GroovyParserTRY, GroovyParserVOID, GroovyParserVOLATILE, GroovyParserWHILE, GroovyParserIntegerLiteral, GroovyParserFloatingPointLiteral, GroovyParserBooleanLiteral, GroovyParserNullLiteral, GroovyParserLPAREN, GroovyParserLBRACE, GroovyParserLBRACK, GroovyParserMUL, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		{
			p.SetState(1527)
			p.MapEntryList()
		}
		p.SetState(1529)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserCOMMA {
			{
				p.SetState(1528)
				p.Match(GroovyParserCOMMA)
			}

		}

	case GroovyParserCOLON:
		{
			p.SetState(1531)
			p.Match(GroovyParserCOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1534)
		p.Match(GroovyParserRBRACK)
	}

	return localctx
}

// IMapEntryListContext is an interface to support dynamic dispatch.
type IMapEntryListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapEntryListContext differentiates from other interfaces.
	IsMapEntryListContext()
}

type MapEntryListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapEntryListContext() *MapEntryListContext {
	var p = new(MapEntryListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_mapEntryList
	return p
}

func (*MapEntryListContext) IsMapEntryListContext() {}

func NewMapEntryListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapEntryListContext {
	var p = new(MapEntryListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_mapEntryList

	return p
}

func (s *MapEntryListContext) GetParser() antlr.Parser { return s.parser }

func (s *MapEntryListContext) AllMapEntry() []IMapEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapEntryContext); ok {
			len++
		}
	}

	tst := make([]IMapEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapEntryContext); ok {
			tst[i] = t.(IMapEntryContext)
			i++
		}
	}

	return tst
}

func (s *MapEntryListContext) MapEntry(i int) IMapEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapEntryContext)
}

func (s *MapEntryListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *MapEntryListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *MapEntryListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapEntryListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapEntryListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMapEntryList(s)
	}
}

func (s *MapEntryListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMapEntryList(s)
	}
}

func (p *GroovyParser) MapEntryList() (localctx IMapEntryListContext) {
	this := p
	_ = this

	localctx = NewMapEntryListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, GroovyParserRULE_mapEntryList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1536)
		p.MapEntry()
	}
	p.SetState(1541)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1537)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(1538)
				p.MapEntry()
			}

		}
		p.SetState(1543)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext())
	}

	return localctx
}

// IMapEntryContext is an interface to support dynamic dispatch.
type IMapEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapEntryContext differentiates from other interfaces.
	IsMapEntryContext()
}

type MapEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapEntryContext() *MapEntryContext {
	var p = new(MapEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_mapEntry
	return p
}

func (*MapEntryContext) IsMapEntryContext() {}

func NewMapEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapEntryContext {
	var p = new(MapEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_mapEntry

	return p
}

func (s *MapEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *MapEntryContext) MapEntryLabel() IMapEntryLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapEntryLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapEntryLabelContext)
}

func (s *MapEntryContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *MapEntryContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MapEntryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapEntryContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *MapEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMapEntry(s)
	}
}

func (s *MapEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMapEntry(s)
	}
}

func (p *GroovyParser) MapEntry() (localctx IMapEntryContext) {
	this := p
	_ = this

	localctx = NewMapEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, GroovyParserRULE_mapEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1554)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserStringLiteral, GroovyParserGStringBegin, GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserTHREADSAFE, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserABSTRACT, GroovyParserASSERT, GroovyParserBREAK, GroovyParserCASE, GroovyParserCATCH, GroovyParserCLASS, GroovyParserCONST, GroovyParserCONTINUE, GroovyParserDEFAULT, GroovyParserDO, GroovyParserELSE, GroovyParserENUM, GroovyParserEXTENDS, GroovyParserFINAL, GroovyParserFINALLY, GroovyParserFOR, GroovyParserIF, GroovyParserGOTO, GroovyParserIMPLEMENTS, GroovyParserIMPORT, GroovyParserINSTANCEOF, GroovyParserINTERFACE, GroovyParserNATIVE, GroovyParserNEW, GroovyParserPACKAGE, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserRETURN, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserSUPER, GroovyParserSWITCH, GroovyParserSYNCHRONIZED, GroovyParserTHIS, GroovyParserTHROW, GroovyParserTHROWS, GroovyParserTRANSIENT, GroovyParserTRY, GroovyParserVOID, GroovyParserVOLATILE, GroovyParserWHILE, GroovyParserIntegerLiteral, GroovyParserFloatingPointLiteral, GroovyParserBooleanLiteral, GroovyParserNullLiteral, GroovyParserLPAREN, GroovyParserLBRACE, GroovyParserLBRACK, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1544)
			p.MapEntryLabel()
		}
		{
			p.SetState(1545)
			p.Match(GroovyParserCOLON)
		}
		{
			p.SetState(1546)
			p.Nls()
		}
		{
			p.SetState(1547)
			p.expression(0)
		}

	case GroovyParserMUL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1549)
			p.Match(GroovyParserMUL)
		}
		{
			p.SetState(1550)
			p.Match(GroovyParserCOLON)
		}
		{
			p.SetState(1551)
			p.Nls()
		}
		{
			p.SetState(1552)
			p.expression(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMapEntryLabelContext is an interface to support dynamic dispatch.
type IMapEntryLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapEntryLabelContext differentiates from other interfaces.
	IsMapEntryLabelContext()
}

type MapEntryLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapEntryLabelContext() *MapEntryLabelContext {
	var p = new(MapEntryLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_mapEntryLabel
	return p
}

func (*MapEntryLabelContext) IsMapEntryLabelContext() {}

func NewMapEntryLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapEntryLabelContext {
	var p = new(MapEntryLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_mapEntryLabel

	return p
}

func (s *MapEntryLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *MapEntryLabelContext) Keywords() IKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *MapEntryLabelContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *MapEntryLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapEntryLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapEntryLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMapEntryLabel(s)
	}
}

func (s *MapEntryLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMapEntryLabel(s)
	}
}

func (p *GroovyParser) MapEntryLabel() (localctx IMapEntryLabelContext) {
	this := p
	_ = this

	localctx = NewMapEntryLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, GroovyParserRULE_mapEntryLabel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1558)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1556)
			p.Keywords()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1557)
			p.Primary()
		}

	}

	return localctx
}

// ICreatorContext is an interface to support dynamic dispatch.
type ICreatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsCreatorContext differentiates from other interfaces.
	IsCreatorContext()
}

type CreatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyCreatorContext() *CreatorContext {
	var p = new(CreatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_creator
	return p
}

func (*CreatorContext) IsCreatorContext() {}

func NewCreatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *CreatorContext {
	var p = new(CreatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_creator

	p.t = t

	return p
}

func (s *CreatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatorContext) GetT() int { return s.t }

func (s *CreatorContext) SetT(v int) { s.t = v }

func (s *CreatorContext) CreatedName() ICreatedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatedNameContext)
}

func (s *CreatorContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *CreatorContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *CreatorContext) DimsOpt() IDimsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsOptContext)
}

func (s *CreatorContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *CreatorContext) ArrayInitializer() IArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *CreatorContext) AnonymousInnerClassDeclaration() IAnonymousInnerClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousInnerClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousInnerClassDeclarationContext)
}

func (s *CreatorContext) AllAnnotationsOpt() []IAnnotationsOptContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationsOptContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationsOptContext); ok {
			tst[i] = t.(IAnnotationsOptContext)
			i++
		}
	}

	return tst
}

func (s *CreatorContext) AnnotationsOpt(i int) IAnnotationsOptContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *CreatorContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserLBRACK)
}

func (s *CreatorContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, i)
}

func (s *CreatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CreatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreatorContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserRBRACK)
}

func (s *CreatorContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, i)
}

func (s *CreatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCreator(s)
	}
}

func (s *CreatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCreator(s)
	}
}

func (p *GroovyParser) Creator(t int) (localctx ICreatorContext) {
	this := p
	_ = this

	localctx = NewCreatorContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 264, GroovyParserRULE_creator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1560)
		p.CreatedName()
	}
	p.SetState(1584)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1561)

		if !(0 == localctx.(*CreatorContext).t || 1 == localctx.(*CreatorContext).t) {
			panic(antlr.NewFailedPredicateException(p, "0 == $t || 1 == $t", ""))
		}
		{
			p.SetState(1562)
			p.Nls()
		}
		{
			p.SetState(1563)
			p.Arguments()
		}
		p.SetState(1565)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1564)
				p.AnonymousInnerClassDeclaration(0)
			}

		}

	case 2:
		p.SetState(1567)

		if !(0 == localctx.(*CreatorContext).t) {
			panic(antlr.NewFailedPredicateException(p, "0 == $t", ""))
		}
		p.SetState(1573)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1568)
					p.AnnotationsOpt()
				}
				{
					p.SetState(1569)
					p.Match(GroovyParserLBRACK)
				}
				{
					p.SetState(1570)
					p.expression(0)
				}
				{
					p.SetState(1571)
					p.Match(GroovyParserRBRACK)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1575)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())
		}
		{
			p.SetState(1577)
			p.DimsOpt()
		}

	case 3:
		p.SetState(1579)

		if !(0 == localctx.(*CreatorContext).t) {
			panic(antlr.NewFailedPredicateException(p, "0 == $t", ""))
		}
		{
			p.SetState(1580)
			p.Dims()
		}
		{
			p.SetState(1581)
			p.Nls()
		}
		{
			p.SetState(1582)
			p.ArrayInitializer()
		}

	}

	return localctx
}

// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_arrayInitializer
	return p
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *ArrayInitializerContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ArrayInitializerContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *ArrayInitializerContext) VariableInitializers() IVariableInitializersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializersContext)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitArrayInitializer(s)
	}
}

func (p *GroovyParser) ArrayInitializer() (localctx IArrayInitializerContext) {
	this := p
	_ = this

	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, GroovyParserRULE_arrayInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1586)
		p.Match(GroovyParserLBRACE)
	}
	{
		p.SetState(1587)
		p.Nls()
	}
	p.SetState(1589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1090196702704449158) != 0 || (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&52776621060117) != 0 {
		{
			p.SetState(1588)
			p.VariableInitializers()
		}

	}
	{
		p.SetState(1591)
		p.Nls()
	}
	{
		p.SetState(1592)
		p.Match(GroovyParserRBRACE)
	}

	return localctx
}

// IAnonymousInnerClassDeclarationContext is an interface to support dynamic dispatch.
type IAnonymousInnerClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsAnonymousInnerClassDeclarationContext differentiates from other interfaces.
	IsAnonymousInnerClassDeclarationContext()
}

type AnonymousInnerClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyAnonymousInnerClassDeclarationContext() *AnonymousInnerClassDeclarationContext {
	var p = new(AnonymousInnerClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_anonymousInnerClassDeclaration
	return p
}

func (*AnonymousInnerClassDeclarationContext) IsAnonymousInnerClassDeclarationContext() {}

func NewAnonymousInnerClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *AnonymousInnerClassDeclarationContext {
	var p = new(AnonymousInnerClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_anonymousInnerClassDeclaration

	p.t = t

	return p
}

func (s *AnonymousInnerClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousInnerClassDeclarationContext) GetT() int { return s.t }

func (s *AnonymousInnerClassDeclarationContext) SetT(v int) { s.t = v }

func (s *AnonymousInnerClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *AnonymousInnerClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousInnerClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousInnerClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAnonymousInnerClassDeclaration(s)
	}
}

func (s *AnonymousInnerClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAnonymousInnerClassDeclaration(s)
	}
}

func (p *GroovyParser) AnonymousInnerClassDeclaration(t int) (localctx IAnonymousInnerClassDeclarationContext) {
	this := p
	_ = this

	localctx = NewAnonymousInnerClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 268, GroovyParserRULE_anonymousInnerClassDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1594)
		p.ClassBody(0)
	}

	return localctx
}

// ICreatedNameContext is an interface to support dynamic dispatch.
type ICreatedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreatedNameContext differentiates from other interfaces.
	IsCreatedNameContext()
}

type CreatedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatedNameContext() *CreatedNameContext {
	var p = new(CreatedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_createdName
	return p
}

func (*CreatedNameContext) IsCreatedNameContext() {}

func NewCreatedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatedNameContext {
	var p = new(CreatedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_createdName

	return p
}

func (s *CreatedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatedNameContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *CreatedNameContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *CreatedNameContext) QualifiedClassName() IQualifiedClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *CreatedNameContext) TypeArgumentsOrDiamond() ITypeArgumentsOrDiamondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsOrDiamondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsOrDiamondContext)
}

func (s *CreatedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCreatedName(s)
	}
}

func (s *CreatedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCreatedName(s)
	}
}

func (p *GroovyParser) CreatedName() (localctx ICreatedNameContext) {
	this := p
	_ = this

	localctx = NewCreatedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, GroovyParserRULE_createdName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1596)
		p.AnnotationsOpt()
	}
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserBuiltInPrimitiveType:
		{
			p.SetState(1597)
			p.PrimitiveType()
		}

	case GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserSTATIC, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		{
			p.SetState(1598)
			p.QualifiedClassName()
		}
		p.SetState(1600)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1599)
				p.TypeArgumentsOrDiamond()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INonWildcardTypeArgumentsContext is an interface to support dynamic dispatch.
type INonWildcardTypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonWildcardTypeArgumentsContext differentiates from other interfaces.
	IsNonWildcardTypeArgumentsContext()
}

type NonWildcardTypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonWildcardTypeArgumentsContext() *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_nonWildcardTypeArguments
	return p
}

func (*NonWildcardTypeArgumentsContext) IsNonWildcardTypeArgumentsContext() {}

func NewNonWildcardTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_nonWildcardTypeArguments

	return p
}

func (s *NonWildcardTypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *NonWildcardTypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *NonWildcardTypeArgumentsContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *NonWildcardTypeArgumentsContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *NonWildcardTypeArgumentsContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *NonWildcardTypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *NonWildcardTypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonWildcardTypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonWildcardTypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNonWildcardTypeArguments(s)
	}
}

func (s *NonWildcardTypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNonWildcardTypeArguments(s)
	}
}

func (p *GroovyParser) NonWildcardTypeArguments() (localctx INonWildcardTypeArgumentsContext) {
	this := p
	_ = this

	localctx = NewNonWildcardTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, GroovyParserRULE_nonWildcardTypeArguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1604)
		p.Match(GroovyParserLT)
	}
	{
		p.SetState(1605)
		p.Nls()
	}
	{
		p.SetState(1606)
		p.TypeList()
	}
	{
		p.SetState(1607)
		p.Nls()
	}
	{
		p.SetState(1608)
		p.Match(GroovyParserGT)
	}

	return localctx
}

// ITypeArgumentsOrDiamondContext is an interface to support dynamic dispatch.
type ITypeArgumentsOrDiamondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsOrDiamondContext differentiates from other interfaces.
	IsTypeArgumentsOrDiamondContext()
}

type TypeArgumentsOrDiamondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsOrDiamondContext() *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeArgumentsOrDiamond
	return p
}

func (*TypeArgumentsOrDiamondContext) IsTypeArgumentsOrDiamondContext() {}

func NewTypeArgumentsOrDiamondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeArgumentsOrDiamond

	return p
}

func (s *TypeArgumentsOrDiamondContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsOrDiamondContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *TypeArgumentsOrDiamondContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *TypeArgumentsOrDiamondContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *TypeArgumentsOrDiamondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsOrDiamondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsOrDiamondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeArgumentsOrDiamond(s)
	}
}

func (s *TypeArgumentsOrDiamondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeArgumentsOrDiamond(s)
	}
}

func (p *GroovyParser) TypeArgumentsOrDiamond() (localctx ITypeArgumentsOrDiamondContext) {
	this := p
	_ = this

	localctx = NewTypeArgumentsOrDiamondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, GroovyParserRULE_typeArgumentsOrDiamond)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1613)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1610)
			p.Match(GroovyParserLT)
		}
		{
			p.SetState(1611)
			p.Match(GroovyParserGT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1612)
			p.TypeArguments()
		}

	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ArgumentsContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ArgumentsContext) EnhancedArgumentList() IEnhancedArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedArgumentListContext)
}

func (s *ArgumentsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *GroovyParser) Arguments() (localctx IArgumentsContext) {
	this := p
	_ = this

	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, GroovyParserRULE_arguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		p.Match(GroovyParserLPAREN)
	}
	p.SetState(1617)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1616)
			p.EnhancedArgumentList()
		}

	}
	p.SetState(1620)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1619)
			p.Match(GroovyParserCOMMA)
		}

	}
	{
		p.SetState(1622)
		p.Rparen()
	}

	return localctx
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_argumentList
	return p
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllArgumentListElement() []IArgumentListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentListElementContext); ok {
			len++
		}
	}

	tst := make([]IArgumentListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentListElementContext); ok {
			tst[i] = t.(IArgumentListElementContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) ArgumentListElement(i int) IArgumentListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListElementContext)
}

func (s *ArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ArgumentListContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *GroovyParser) ArgumentList() (localctx IArgumentListContext) {
	this := p
	_ = this

	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, GroovyParserRULE_argumentList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1624)
		p.ArgumentListElement()
	}
	p.SetState(1631)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1625)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(1626)
				p.Nls()
			}
			{
				p.SetState(1627)
				p.ArgumentListElement()
			}

		}
		p.SetState(1633)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext())
	}

	return localctx
}

// IEnhancedArgumentListContext is an interface to support dynamic dispatch.
type IEnhancedArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedArgumentListContext differentiates from other interfaces.
	IsEnhancedArgumentListContext()
}

type EnhancedArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedArgumentListContext() *EnhancedArgumentListContext {
	var p = new(EnhancedArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enhancedArgumentList
	return p
}

func (*EnhancedArgumentListContext) IsEnhancedArgumentListContext() {}

func NewEnhancedArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedArgumentListContext {
	var p = new(EnhancedArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedArgumentList

	return p
}

func (s *EnhancedArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedArgumentListContext) AllEnhancedArgumentListElement() []IEnhancedArgumentListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnhancedArgumentListElementContext); ok {
			len++
		}
	}

	tst := make([]IEnhancedArgumentListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnhancedArgumentListElementContext); ok {
			tst[i] = t.(IEnhancedArgumentListElementContext)
			i++
		}
	}

	return tst
}

func (s *EnhancedArgumentListContext) EnhancedArgumentListElement(i int) IEnhancedArgumentListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedArgumentListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedArgumentListElementContext)
}

func (s *EnhancedArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *EnhancedArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *EnhancedArgumentListContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *EnhancedArgumentListContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *EnhancedArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnhancedArgumentList(s)
	}
}

func (s *EnhancedArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnhancedArgumentList(s)
	}
}

func (p *GroovyParser) EnhancedArgumentList() (localctx IEnhancedArgumentListContext) {
	this := p
	_ = this

	localctx = NewEnhancedArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, GroovyParserRULE_enhancedArgumentList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1634)
		p.EnhancedArgumentListElement()
	}
	p.SetState(1641)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1635)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(1636)
				p.Nls()
			}
			{
				p.SetState(1637)
				p.EnhancedArgumentListElement()
			}

		}
		p.SetState(1643)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext())
	}

	return localctx
}

// IArgumentListElementContext is an interface to support dynamic dispatch.
type IArgumentListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentListElementContext differentiates from other interfaces.
	IsArgumentListElementContext()
}

type ArgumentListElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListElementContext() *ArgumentListElementContext {
	var p = new(ArgumentListElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_argumentListElement
	return p
}

func (*ArgumentListElementContext) IsArgumentListElementContext() {}

func NewArgumentListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListElementContext {
	var p = new(ArgumentListElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_argumentListElement

	return p
}

func (s *ArgumentListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListElementContext) ExpressionListElement() IExpressionListElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListElementContext)
}

func (s *ArgumentListElementContext) MapEntry() IMapEntryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapEntryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapEntryContext)
}

func (s *ArgumentListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterArgumentListElement(s)
	}
}

func (s *ArgumentListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitArgumentListElement(s)
	}
}

func (p *GroovyParser) ArgumentListElement() (localctx IArgumentListElementContext) {
	this := p
	_ = this

	localctx = NewArgumentListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, GroovyParserRULE_argumentListElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1646)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1644)
			p.ExpressionListElement(true)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1645)
			p.MapEntry()
		}

	}

	return localctx
}

// IEnhancedArgumentListElementContext is an interface to support dynamic dispatch.
type IEnhancedArgumentListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedArgumentListElementContext differentiates from other interfaces.
	IsEnhancedArgumentListElementContext()
}

type EnhancedArgumentListElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedArgumentListElementContext() *EnhancedArgumentListElementContext {
	var p = new(EnhancedArgumentListElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enhancedArgumentListElement
	return p
}

func (*EnhancedArgumentListElementContext) IsEnhancedArgumentListElementContext() {}

func NewEnhancedArgumentListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedArgumentListElementContext {
	var p = new(EnhancedArgumentListElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedArgumentListElement

	return p
}

func (s *EnhancedArgumentListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedArgumentListElementContext) ExpressionListElement() IExpressionListElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListElementContext)
}

func (s *EnhancedArgumentListElementContext) StandardLambdaExpression() IStandardLambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardLambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardLambdaExpressionContext)
}

func (s *EnhancedArgumentListElementContext) MapEntry() IMapEntryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapEntryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapEntryContext)
}

func (s *EnhancedArgumentListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedArgumentListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedArgumentListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnhancedArgumentListElement(s)
	}
}

func (s *EnhancedArgumentListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnhancedArgumentListElement(s)
	}
}

func (p *GroovyParser) EnhancedArgumentListElement() (localctx IEnhancedArgumentListElementContext) {
	this := p
	_ = this

	localctx = NewEnhancedArgumentListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, GroovyParserRULE_enhancedArgumentListElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1651)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1648)
			p.ExpressionListElement(true)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1649)
			p.StandardLambdaExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1650)
			p.MapEntry()
		}

	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserStringLiteral, 0)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *GroovyParser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, GroovyParserRULE_stringLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1653)
		p.Match(GroovyParserStringLiteral)
	}

	return localctx
}

// IClassNameContext is an interface to support dynamic dispatch.
type IClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassNameContext differentiates from other interfaces.
	IsClassNameContext()
}

type ClassNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNameContext() *ClassNameContext {
	var p = new(ClassNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_className
	return p
}

func (*ClassNameContext) IsClassNameContext() {}

func NewClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNameContext {
	var p = new(ClassNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_className

	return p
}

func (s *ClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNameContext) CapitalizedIdentifier() antlr.TerminalNode {
	return s.GetToken(GroovyParserCapitalizedIdentifier, 0)
}

func (s *ClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassName(s)
	}
}

func (s *ClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassName(s)
	}
}

func (p *GroovyParser) ClassName() (localctx IClassNameContext) {
	this := p
	_ = this

	localctx = NewClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, GroovyParserRULE_className)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1655)
		p.Match(GroovyParserCapitalizedIdentifier)
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(GroovyParserIdentifier, 0)
}

func (s *IdentifierContext) CapitalizedIdentifier() antlr.TerminalNode {
	return s.GetToken(GroovyParserCapitalizedIdentifier, 0)
}

func (s *IdentifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *IdentifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *IdentifierContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *IdentifierContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *IdentifierContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *GroovyParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, GroovyParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1657)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8796093027968) != 0 || _la == GroovyParserCapitalizedIdentifier || _la == GroovyParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBuiltInTypeContext is an interface to support dynamic dispatch.
type IBuiltInTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBuiltInTypeContext differentiates from other interfaces.
	IsBuiltInTypeContext()
}

type BuiltInTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuiltInTypeContext() *BuiltInTypeContext {
	var p = new(BuiltInTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_builtInType
	return p
}

func (*BuiltInTypeContext) IsBuiltInTypeContext() {}

func NewBuiltInTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuiltInTypeContext {
	var p = new(BuiltInTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_builtInType

	return p
}

func (s *BuiltInTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BuiltInTypeContext) BuiltInPrimitiveType() antlr.TerminalNode {
	return s.GetToken(GroovyParserBuiltInPrimitiveType, 0)
}

func (s *BuiltInTypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *BuiltInTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltInTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuiltInTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBuiltInType(s)
	}
}

func (s *BuiltInTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBuiltInType(s)
	}
}

func (p *GroovyParser) BuiltInType() (localctx IBuiltInTypeContext) {
	this := p
	_ = this

	localctx = NewBuiltInTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, GroovyParserRULE_builtInType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1659)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GroovyParserBuiltInPrimitiveType || _la == GroovyParserVOID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IKeywordsContext is an interface to support dynamic dispatch.
type IKeywordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordsContext differentiates from other interfaces.
	IsKeywordsContext()
}

type KeywordsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordsContext() *KeywordsContext {
	var p = new(KeywordsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_keywords
	return p
}

func (*KeywordsContext) IsKeywordsContext() {}

func NewKeywordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordsContext {
	var p = new(KeywordsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_keywords

	return p
}

func (s *KeywordsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordsContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(GroovyParserABSTRACT, 0)
}

func (s *KeywordsContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *KeywordsContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSERT, 0)
}

func (s *KeywordsContext) BREAK() antlr.TerminalNode {
	return s.GetToken(GroovyParserBREAK, 0)
}

func (s *KeywordsContext) CASE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCASE, 0)
}

func (s *KeywordsContext) CATCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserCATCH, 0)
}

func (s *KeywordsContext) CLASS() antlr.TerminalNode {
	return s.GetToken(GroovyParserCLASS, 0)
}

func (s *KeywordsContext) CONST() antlr.TerminalNode {
	return s.GetToken(GroovyParserCONST, 0)
}

func (s *KeywordsContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCONTINUE, 0)
}

func (s *KeywordsContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *KeywordsContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *KeywordsContext) DO() antlr.TerminalNode {
	return s.GetToken(GroovyParserDO, 0)
}

func (s *KeywordsContext) ELSE() antlr.TerminalNode {
	return s.GetToken(GroovyParserELSE, 0)
}

func (s *KeywordsContext) ENUM() antlr.TerminalNode {
	return s.GetToken(GroovyParserENUM, 0)
}

func (s *KeywordsContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *KeywordsContext) FINAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINAL, 0)
}

func (s *KeywordsContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINALLY, 0)
}

func (s *KeywordsContext) FOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserFOR, 0)
}

func (s *KeywordsContext) GOTO() antlr.TerminalNode {
	return s.GetToken(GroovyParserGOTO, 0)
}

func (s *KeywordsContext) IF() antlr.TerminalNode {
	return s.GetToken(GroovyParserIF, 0)
}

func (s *KeywordsContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPLEMENTS, 0)
}

func (s *KeywordsContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPORT, 0)
}

func (s *KeywordsContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *KeywordsContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserINSTANCEOF, 0)
}

func (s *KeywordsContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserINTERFACE, 0)
}

func (s *KeywordsContext) NATIVE() antlr.TerminalNode {
	return s.GetToken(GroovyParserNATIVE, 0)
}

func (s *KeywordsContext) NEW() antlr.TerminalNode {
	return s.GetToken(GroovyParserNEW, 0)
}

func (s *KeywordsContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPACKAGE, 0)
}

func (s *KeywordsContext) RETURN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRETURN, 0)
}

func (s *KeywordsContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *KeywordsContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTRICTFP, 0)
}

func (s *KeywordsContext) SUPER() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUPER, 0)
}

func (s *KeywordsContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserSWITCH, 0)
}

func (s *KeywordsContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSYNCHRONIZED, 0)
}

func (s *KeywordsContext) THIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHIS, 0)
}

func (s *KeywordsContext) THROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROW, 0)
}

func (s *KeywordsContext) THROWS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROWS, 0)
}

func (s *KeywordsContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRANSIENT, 0)
}

func (s *KeywordsContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *KeywordsContext) THREADSAFE() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHREADSAFE, 0)
}

func (s *KeywordsContext) TRY() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRY, 0)
}

func (s *KeywordsContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *KeywordsContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOLATILE, 0)
}

func (s *KeywordsContext) WHILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserWHILE, 0)
}

func (s *KeywordsContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserNullLiteral, 0)
}

func (s *KeywordsContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserBooleanLiteral, 0)
}

func (s *KeywordsContext) BuiltInPrimitiveType() antlr.TerminalNode {
	return s.GetToken(GroovyParserBuiltInPrimitiveType, 0)
}

func (s *KeywordsContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *KeywordsContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserPUBLIC, 0)
}

func (s *KeywordsContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(GroovyParserPROTECTED, 0)
}

func (s *KeywordsContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPRIVATE, 0)
}

func (s *KeywordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterKeywords(s)
	}
}

func (s *KeywordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitKeywords(s)
	}
}

func (p *GroovyParser) Keywords() (localctx IKeywordsContext) {
	this := p
	_ = this

	localctx = NewKeywordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, GroovyParserRULE_keywords)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1661)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&936748722493063040) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRparenContext is an interface to support dynamic dispatch.
type IRparenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRparenContext differentiates from other interfaces.
	IsRparenContext()
}

type RparenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRparenContext() *RparenContext {
	var p = new(RparenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_rparen
	return p
}

func (*RparenContext) IsRparenContext() {}

func NewRparenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RparenContext {
	var p = new(RparenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_rparen

	return p
}

func (s *RparenContext) GetParser() antlr.Parser { return s.parser }

func (s *RparenContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRPAREN, 0)
}

func (s *RparenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RparenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RparenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterRparen(s)
	}
}

func (s *RparenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitRparen(s)
	}
}

func (p *GroovyParser) Rparen() (localctx IRparenContext) {
	this := p
	_ = this

	localctx = NewRparenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, GroovyParserRULE_rparen)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1665)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1663)
			p.Match(GroovyParserRPAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	}

	return localctx
}

// INlsContext is an interface to support dynamic dispatch.
type INlsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNlsContext differentiates from other interfaces.
	IsNlsContext()
}

type NlsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNlsContext() *NlsContext {
	var p = new(NlsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_nls
	return p
}

func (*NlsContext) IsNlsContext() {}

func NewNlsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NlsContext {
	var p = new(NlsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_nls

	return p
}

func (s *NlsContext) GetParser() antlr.Parser { return s.parser }

func (s *NlsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserNL)
}

func (s *NlsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserNL, i)
}

func (s *NlsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NlsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NlsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNls(s)
	}
}

func (s *NlsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNls(s)
	}
}

func (p *GroovyParser) Nls() (localctx INlsContext) {
	this := p
	_ = this

	localctx = NewNlsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, GroovyParserRULE_nls)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1670)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1667)
				p.Match(GroovyParserNL)
			}

		}
		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext())
	}

	return localctx
}

// ISepContext is an interface to support dynamic dispatch.
type ISepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSepContext differentiates from other interfaces.
	IsSepContext()
}

type SepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySepContext() *SepContext {
	var p = new(SepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_sep
	return p
}

func (*SepContext) IsSepContext() {}

func NewSepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SepContext {
	var p = new(SepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_sep

	return p
}

func (s *SepContext) GetParser() antlr.Parser { return s.parser }

func (s *SepContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserNL)
}

func (s *SepContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserNL, i)
}

func (s *SepContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserSEMI)
}

func (s *SepContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserSEMI, i)
}

func (s *SepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSep(s)
	}
}

func (s *SepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSep(s)
	}
}

func (p *GroovyParser) Sep() (localctx ISepContext) {
	this := p
	_ = this

	localctx = NewSepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, GroovyParserRULE_sep)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1674)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1673)
				_la = p.GetTokenStream().LA(1)

				if !(_la == GroovyParserSEMI || _la == GroovyParserNL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1676)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext())
	}

	return localctx
}

func (p *GroovyParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 19:
		var t *ClassDeclarationContext = nil
		if localctx != nil {
			t = localctx.(*ClassDeclarationContext)
		}
		return p.ClassDeclaration_Sempred(t, predIndex)

	case 20:
		var t *ClassBodyContext = nil
		if localctx != nil {
			t = localctx.(*ClassBodyContext)
		}
		return p.ClassBody_Sempred(t, predIndex)

	case 25:
		var t *MethodDeclarationContext = nil
		if localctx != nil {
			t = localctx.(*MethodDeclarationContext)
		}
		return p.MethodDeclaration_Sempred(t, predIndex)

	case 27:
		var t *ReturnTypeContext = nil
		if localctx != nil {
			t = localctx.(*ReturnTypeContext)
		}
		return p.ReturnType_Sempred(t, predIndex)

	case 81:
		var t *ClassifiedModifiersContext = nil
		if localctx != nil {
			t = localctx.(*ClassifiedModifiersContext)
		}
		return p.ClassifiedModifiers_Sempred(t, predIndex)

	case 116:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 132:
		var t *CreatorContext = nil
		if localctx != nil {
			t = localctx.(*CreatorContext)
		}
		return p.Creator_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *GroovyParser) ClassDeclaration_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return 3 != localctx.(*ClassDeclarationContext).t

	case 1:
		return 2 != localctx.(*ClassDeclarationContext).t

	case 2:
		return 1 == localctx.(*ClassDeclarationContext).t

	case 3:
		return 1 != localctx.(*ClassDeclarationContext).t

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) ClassBody_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 4:
		return 2 == localctx.(*ClassBodyContext).t

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) MethodDeclaration_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 5:
		return 3 == localctx.(*MethodDeclarationContext).ct

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) ReturnType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 6:
		return 3 != localctx.(*ReturnTypeContext).ct

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) ClassifiedModifiers_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 7:
		return 0 == localctx.(*ClassifiedModifiersContext).t

	case 8:
		return 1 == localctx.(*ClassifiedModifiersContext).t

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) Creator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 24:
		return 0 == localctx.(*CreatorContext).t || 1 == localctx.(*CreatorContext).t

	case 25:
		return 0 == localctx.(*CreatorContext).t

	case 26:
		return 0 == localctx.(*CreatorContext).t

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
