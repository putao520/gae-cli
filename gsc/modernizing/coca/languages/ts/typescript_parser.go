// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package parser // TypeScriptParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type TypeScriptParser struct {
	TypeScriptBaseParser
}

var typescriptparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func typescriptparserParserInit() {
	staticData := &typescriptparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "", "", "'['", "']'", "'('", "')'", "'{'", "'}'", "';'",
		"','", "'='", "'?'", "':'", "'...'", "'.'", "'++'", "'--'", "'+'", "'-'",
		"'~'", "'!'", "'*'", "'_'", "'$'", "'/'", "'%'", "'**'", "'??'", "'#'",
		"'>>'", "'<<'", "'>>>'", "'<'", "'>'", "'<='", "'>='", "'=='", "'!='",
		"'==='", "'!=='", "'&'", "'^'", "'|'", "'&&'", "'||'", "'*='", "'/='",
		"'%='", "'+='", "'-='", "'<<='", "'>>='", "'>>>='", "'&='", "'^='",
		"'|='", "'=>'", "'**='", "'null'", "", "", "", "", "", "", "'break'",
		"'do'", "'instanceof'", "'typeof'", "'case'", "'else'", "'new'", "'var'",
		"'catch'", "'finally'", "'return'", "'void'", "'continue'", "'for'",
		"'switch'", "'while'", "'debugger'", "'function'", "'this'", "'with'",
		"'default'", "'if'", "'throw'", "'delete'", "'in'", "'try'", "'as'",
		"'from'", "'readonly'", "'async'", "'class'", "'enum'", "'extends'",
		"'super'", "'const'", "'export'", "'import'", "'await'", "'implements'",
		"'let'", "'private'", "'public'", "'interface'", "'package'", "'protected'",
		"'static'", "'yield'", "'any'", "'number'", "'boolean'", "'string'",
		"'symbol'", "'type'", "'get '", "'set '", "'constructor'", "'namespace'",
		"'require'", "'module'", "'declare'", "'abstract'", "'is'", "'@'",
	}
	staticData.symbolicNames = []string{
		"", "HashBangLine", "MultiLineComment", "SingleLineComment", "RegularExpressionLiteral",
		"OpenBracket", "CloseBracket", "OpenParen", "CloseParen", "OpenBrace",
		"CloseBrace", "SemiColon", "Comma", "Assign", "QuestionMark", "Colon",
		"Ellipsis", "Dot", "PlusPlus", "MinusMinus", "Plus", "Minus", "BitNot",
		"Not", "Multiply", "Lodash", "Dollar", "Divide", "Modulus", "Power",
		"NullCoalesce", "Hashtag", "RightShiftArithmetic", "LeftShiftArithmetic",
		"RightShiftLogical", "LessThan", "MoreThan", "LessThanEquals", "GreaterThanEquals",
		"Equals_", "NotEquals", "IdentityEquals", "IdentityNotEquals", "BitAnd",
		"BitXOr", "BitOr", "And", "Or", "MultiplyAssign", "DivideAssign", "ModulusAssign",
		"PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign", "RightShiftArithmeticAssign",
		"RightShiftLogicalAssign", "BitAndAssign", "BitXorAssign", "BitOrAssign",
		"ARROW", "PowerAssign", "NullLiteral", "BooleanLiteral", "DecimalLiteral",
		"HexIntegerLiteral", "OctalIntegerLiteral", "OctalIntegerLiteral2",
		"BinaryIntegerLiteral", "Break", "Do", "Instanceof", "Typeof", "Case",
		"Else", "New", "Var", "Catch", "Finally", "Return", "Void", "Continue",
		"For", "Switch", "While", "Debugger", "Function", "This", "With", "Default",
		"If", "Throw", "Delete", "In", "Try", "As", "From", "ReadOnly", "Async",
		"Class", "Enum", "Extends", "Super", "Const", "Export", "Import", "Await",
		"Implements", "Let", "Private", "Public", "Interface", "Package", "Protected",
		"Static", "Yield", "ANY", "NUMBER", "BOOLEAN", "STRING", "SYMBOL", "Type",
		"Get", "Set", "Constructor", "Namespace", "Require", "Module", "Declare",
		"Abstract", "Is", "At", "Identifier", "StringLiteral", "TemplateStringLiteral",
		"WhiteSpaces", "LineTerminator", "HtmlComment", "CDataComment", "UnexpectedCharacter",
	}
	staticData.ruleNames = []string{
		"initializer", "bindingPattern", "typeParameters", "typeParameterList",
		"typeParameter", "constraint", "typeArguments", "typeArgumentList",
		"typeArgument", "type_", "unionOrIntersectionOrPrimaryType", "primaryType",
		"predefinedType", "typeReference", "typeGeneric", "typeIncludeGeneric",
		"typeName", "objectType", "typeBody", "typeMemberList", "typeMember",
		"arrayType", "tupleType", "tupleElementTypes", "functionType", "constructorType",
		"typeQuery", "typeQueryExpression", "propertySignature", "typeAnnotation",
		"callSignature", "parameterList", "requiredParameterList", "requiredParameter",
		"accessibilityModifier", "identifierOrPattern", "optionalParameterList",
		"optionalParameter", "restParameter", "constructSignature", "indexSignature",
		"methodSignature", "typeAliasDeclaration", "constructorDeclaration",
		"interfaceDeclaration", "interfaceExtendsClause", "classOrInterfaceTypeList",
		"enumDeclaration", "enumBody", "enumMemberList", "enumMember", "namespaceDeclaration",
		"namespaceName", "importAliasDeclaration", "importAll", "decoratorList",
		"decorator", "decoratorMemberExpression", "decoratorCallExpression",
		"program", "sourceElement", "statement", "block", "statementList", "abstractDeclaration",
		"importStatement", "importFromBlock", "multipleImportStatement", "exportStatement",
		"variableStatement", "variableDeclarationList", "variableDeclaration",
		"emptyStatement_", "expressionStatement", "ifStatement", "iterationStatement",
		"varModifier", "continueStatement", "breakStatement", "returnStatement",
		"yieldStatement", "withStatement", "switchStatement", "caseBlock", "caseClauses",
		"caseClause", "defaultClause", "labelledStatement", "throwStatement",
		"tryStatement", "catchProduction", "assignable", "finallyProduction",
		"debuggerStatement", "functionDeclaration", "classDeclaration", "classHeritage",
		"classTail", "classExtendsClause", "implementsClause", "classElement",
		"propertyMemberDeclaration", "propertyMemberBase", "indexMemberDeclaration",
		"generatorMethod", "generatorFunctionDeclaration", "generatorBlock",
		"generatorDefinition", "iteratorBlock", "iteratorDefinition", "formalParameterList",
		"formalParameterArg", "lastFormalParameterArg", "functionBody", "sourceElements",
		"arrayLiteral", "elementList", "lastElement", "objectLiteral", "propertyAssignment",
		"getAccessor", "setAccessor", "propertyName", "arguments", "lastArgument",
		"expressionSequence", "functionExpressionDeclaration", "singleExpression",
		"arrowFunctionDeclaration", "arrowFunctionParameters", "arrowFunctionBody",
		"assignmentOperator", "literal", "numericLiteral", "identifierName",
		"reservedWord", "keyword", "getter", "setter", "eos",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 138, 1721, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 1,
		0, 1, 0, 1, 0, 1, 1, 1, 1, 3, 1, 286, 8, 1, 1, 2, 1, 2, 3, 2, 290, 8, 2,
		1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 5, 3, 297, 8, 3, 10, 3, 12, 3, 300, 9, 3,
		1, 4, 1, 4, 3, 4, 304, 8, 4, 1, 4, 3, 4, 307, 8, 4, 1, 5, 1, 5, 1, 5, 1,
		6, 1, 6, 3, 6, 314, 8, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 5, 7, 321, 8, 7,
		10, 7, 12, 7, 324, 9, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		333, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		5, 10, 344, 8, 10, 10, 10, 12, 10, 347, 9, 10, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 367, 8, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 5, 11, 373, 8, 11, 10, 11, 12, 11, 376, 9, 11, 1, 12, 1, 12, 1, 13,
		1, 13, 1, 13, 3, 13, 383, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 398, 8, 15,
		1, 16, 1, 16, 3, 16, 402, 8, 16, 1, 17, 1, 17, 3, 17, 406, 8, 17, 1, 17,
		1, 17, 1, 18, 1, 18, 3, 18, 412, 8, 18, 1, 19, 1, 19, 1, 19, 5, 19, 417,
		8, 19, 10, 19, 12, 19, 420, 9, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1,
		20, 1, 20, 3, 20, 429, 8, 20, 3, 20, 431, 8, 20, 1, 21, 1, 21, 1, 21, 1,
		21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 5, 23, 445,
		8, 23, 10, 23, 12, 23, 448, 9, 23, 1, 24, 3, 24, 451, 8, 24, 1, 24, 1,
		24, 3, 24, 455, 8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 3, 25,
		463, 8, 25, 1, 25, 1, 25, 3, 25, 467, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 4, 27, 480, 8, 27, 11,
		27, 12, 27, 481, 1, 27, 1, 27, 3, 27, 486, 8, 27, 1, 28, 3, 28, 489, 8,
		28, 1, 28, 1, 28, 3, 28, 493, 8, 28, 1, 28, 3, 28, 496, 8, 28, 1, 28, 1,
		28, 3, 28, 500, 8, 28, 1, 29, 1, 29, 1, 29, 1, 30, 3, 30, 506, 8, 30, 1,
		30, 1, 30, 3, 30, 510, 8, 30, 1, 30, 1, 30, 3, 30, 514, 8, 30, 1, 31, 1,
		31, 1, 31, 1, 31, 5, 31, 520, 8, 31, 10, 31, 12, 31, 523, 9, 31, 1, 31,
		1, 31, 1, 31, 3, 31, 528, 8, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3,
		31, 535, 8, 31, 1, 31, 3, 31, 538, 8, 31, 3, 31, 540, 8, 31, 3, 31, 542,
		8, 31, 1, 32, 1, 32, 1, 32, 5, 32, 547, 8, 32, 10, 32, 12, 32, 550, 9,
		32, 1, 33, 3, 33, 553, 8, 33, 1, 33, 3, 33, 556, 8, 33, 1, 33, 1, 33, 3,
		33, 560, 8, 33, 1, 34, 1, 34, 1, 35, 1, 35, 3, 35, 566, 8, 35, 1, 36, 1,
		36, 1, 36, 5, 36, 571, 8, 36, 10, 36, 12, 36, 574, 9, 36, 1, 37, 3, 37,
		577, 8, 37, 1, 37, 3, 37, 580, 8, 37, 1, 37, 1, 37, 1, 37, 3, 37, 585,
		8, 37, 1, 37, 3, 37, 588, 8, 37, 1, 37, 3, 37, 591, 8, 37, 1, 38, 1, 38,
		1, 38, 1, 38, 3, 38, 597, 8, 38, 1, 39, 1, 39, 3, 39, 601, 8, 39, 1, 39,
		1, 39, 3, 39, 605, 8, 39, 1, 39, 1, 39, 3, 39, 609, 8, 39, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 3, 41, 620, 8, 41, 1,
		41, 1, 41, 1, 42, 1, 42, 1, 42, 3, 42, 627, 8, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 43, 3, 43, 634, 8, 43, 1, 43, 1, 43, 1, 43, 3, 43, 639, 8, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 647, 8, 43, 1, 44, 3,
		44, 650, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 655, 8, 44, 1, 44, 3, 44, 658,
		8, 44, 1, 44, 1, 44, 3, 44, 662, 8, 44, 1, 45, 1, 45, 1, 45, 1, 46, 1,
		46, 1, 46, 5, 46, 670, 8, 46, 10, 46, 12, 46, 673, 9, 46, 1, 47, 3, 47,
		676, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 682, 8, 47, 1, 47, 1, 47,
		1, 48, 1, 48, 3, 48, 688, 8, 48, 1, 49, 1, 49, 1, 49, 5, 49, 693, 8, 49,
		10, 49, 12, 49, 696, 9, 49, 1, 50, 1, 50, 1, 50, 3, 50, 701, 8, 50, 1,
		51, 1, 51, 1, 51, 1, 51, 3, 51, 707, 8, 51, 1, 51, 1, 51, 1, 52, 1, 52,
		4, 52, 713, 8, 52, 11, 52, 12, 52, 714, 1, 52, 5, 52, 718, 8, 52, 10, 52,
		12, 52, 721, 9, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 735, 8, 53, 1, 54, 1, 54, 1, 55,
		4, 55, 740, 8, 55, 11, 55, 12, 55, 741, 1, 56, 1, 56, 1, 56, 3, 56, 747,
		8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 755, 8, 57, 1,
		57, 1, 57, 1, 57, 5, 57, 760, 8, 57, 10, 57, 12, 57, 763, 9, 57, 1, 58,
		1, 58, 1, 58, 1, 59, 3, 59, 769, 8, 59, 1, 59, 1, 59, 1, 60, 3, 60, 774,
		8, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1,
		61, 3, 61, 807, 8, 61, 1, 62, 1, 62, 3, 62, 811, 8, 62, 1, 62, 1, 62, 1,
		63, 4, 63, 816, 8, 63, 11, 63, 12, 63, 817, 1, 64, 1, 64, 1, 64, 1, 64,
		3, 64, 824, 8, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 832,
		8, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 841, 8,
		66, 1, 66, 1, 66, 3, 66, 845, 8, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1, 67,
		1, 67, 3, 67, 853, 8, 67, 1, 67, 1, 67, 1, 67, 1, 67, 5, 67, 859, 8, 67,
		10, 67, 12, 67, 862, 9, 67, 1, 67, 1, 67, 1, 68, 1, 68, 3, 68, 868, 8,
		68, 1, 68, 1, 68, 3, 68, 872, 8, 68, 1, 69, 1, 69, 3, 69, 876, 8, 69, 1,
		69, 1, 69, 3, 69, 880, 8, 69, 1, 69, 3, 69, 883, 8, 69, 1, 69, 3, 69, 886,
		8, 69, 1, 69, 3, 69, 889, 8, 69, 1, 69, 1, 69, 3, 69, 893, 8, 69, 3, 69,
		895, 8, 69, 1, 70, 1, 70, 1, 70, 5, 70, 900, 8, 70, 10, 70, 12, 70, 903,
		9, 70, 1, 71, 1, 71, 3, 71, 907, 8, 71, 1, 71, 3, 71, 910, 8, 71, 1, 71,
		1, 71, 3, 71, 914, 8, 71, 1, 71, 3, 71, 917, 8, 71, 1, 72, 1, 72, 1, 73,
		1, 73, 1, 73, 3, 73, 924, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 3, 74, 933, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 3, 75, 952, 8, 75, 1, 75, 1, 75, 3, 75, 956, 8, 75, 1, 75, 1, 75, 3,
		75, 960, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		3, 75, 970, 8, 75, 1, 75, 1, 75, 3, 75, 974, 8, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 1, 75, 3, 75, 981, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3,
		75, 988, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 996, 8,
		75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 1004, 8, 75, 1, 75,
		1, 75, 1, 75, 1, 75, 3, 75, 1010, 8, 75, 1, 76, 1, 76, 1, 77, 1, 77, 1,
		77, 3, 77, 1017, 8, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 3, 78, 1024,
		8, 78, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 3, 79, 1031, 8, 79, 1, 79, 1,
		79, 1, 80, 1, 80, 1, 80, 3, 80, 1038, 8, 80, 1, 80, 1, 80, 1, 81, 1, 81,
		1, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1,
		83, 1, 83, 3, 83, 1056, 8, 83, 1, 83, 1, 83, 3, 83, 1060, 8, 83, 3, 83,
		1062, 8, 83, 1, 83, 1, 83, 1, 84, 4, 84, 1067, 8, 84, 11, 84, 12, 84, 1068,
		1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1075, 8, 85, 1, 86, 1, 86, 1, 86, 3,
		86, 1080, 8, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88,
		1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 1095, 8, 89, 1, 89, 3, 89, 1098,
		8, 89, 1, 90, 1, 90, 1, 90, 3, 90, 1103, 8, 90, 1, 90, 3, 90, 1106, 8,
		90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 3, 91, 1113, 8, 91, 1, 92, 1, 92,
		1, 92, 1, 93, 1, 93, 1, 93, 1, 94, 3, 94, 1122, 8, 94, 1, 94, 1, 94, 3,
		94, 1126, 8, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94,
		1135, 8, 94, 1, 95, 3, 95, 1138, 8, 95, 1, 95, 1, 95, 1, 95, 3, 95, 1143,
		8, 95, 1, 95, 1, 95, 1, 95, 1, 96, 3, 96, 1149, 8, 96, 1, 96, 3, 96, 1152,
		8, 96, 1, 97, 1, 97, 5, 97, 1156, 8, 97, 10, 97, 12, 97, 1159, 9, 97, 1,
		97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1,
		100, 1, 100, 3, 100, 1173, 8, 100, 1, 101, 1, 101, 3, 101, 1177, 8, 101,
		1, 101, 3, 101, 1180, 8, 101, 1, 101, 1, 101, 3, 101, 1184, 8, 101, 1,
		101, 3, 101, 1187, 8, 101, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1193,
		8, 101, 1, 101, 3, 101, 1196, 8, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 3, 101, 1205, 8, 101, 1, 101, 1, 101, 3, 101, 1209,
		8, 101, 1, 101, 3, 101, 1212, 8, 101, 1, 101, 1, 101, 3, 101, 1216, 8,
		101, 1, 101, 3, 101, 1219, 8, 101, 1, 102, 3, 102, 1222, 8, 102, 1, 102,
		3, 102, 1225, 8, 102, 1, 102, 3, 102, 1228, 8, 102, 1, 102, 3, 102, 1231,
		8, 102, 1, 103, 1, 103, 1, 103, 1, 104, 3, 104, 1237, 8, 104, 1, 104, 1,
		104, 1, 104, 3, 104, 1242, 8, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104,
		1, 105, 1, 105, 1, 105, 3, 105, 1252, 8, 105, 1, 105, 1, 105, 3, 105, 1256,
		8, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1, 106,
		1, 106, 5, 106, 1267, 8, 106, 10, 106, 12, 106, 1270, 9, 106, 1, 106, 3,
		106, 1273, 8, 106, 1, 106, 1, 106, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108,
		1, 108, 1, 108, 5, 108, 1284, 8, 108, 10, 108, 12, 108, 1287, 9, 108, 1,
		108, 3, 108, 1290, 8, 108, 1, 108, 1, 108, 1, 109, 1, 109, 1, 109, 1, 109,
		1, 109, 3, 109, 1299, 8, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1,
		110, 1, 110, 1, 110, 5, 110, 1309, 8, 110, 10, 110, 12, 110, 1312, 9, 110,
		1, 110, 1, 110, 3, 110, 1316, 8, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1,
		110, 3, 110, 1323, 8, 110, 3, 110, 1325, 8, 110, 1, 111, 3, 111, 1328,
		8, 111, 1, 111, 1, 111, 3, 111, 1332, 8, 111, 1, 111, 1, 111, 3, 111, 1336,
		8, 111, 1, 112, 1, 112, 1, 112, 1, 113, 3, 113, 1342, 8, 113, 1, 114, 4,
		114, 1345, 8, 114, 11, 114, 12, 114, 1346, 1, 115, 1, 115, 3, 115, 1351,
		8, 115, 1, 115, 1, 115, 1, 116, 1, 116, 4, 116, 1357, 8, 116, 11, 116,
		12, 116, 1358, 1, 116, 5, 116, 1362, 8, 116, 10, 116, 12, 116, 1365, 9,
		116, 1, 116, 4, 116, 1368, 8, 116, 11, 116, 12, 116, 1369, 1, 116, 3, 116,
		1373, 8, 116, 1, 116, 3, 116, 1376, 8, 116, 1, 117, 1, 117, 1, 117, 3,
		117, 1381, 8, 117, 1, 118, 1, 118, 1, 118, 1, 118, 5, 118, 1387, 8, 118,
		10, 118, 12, 118, 1390, 9, 118, 3, 118, 1392, 8, 118, 1, 118, 3, 118, 1395,
		8, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119, 1410, 8, 119, 1, 119, 3,
		119, 1413, 8, 119, 1, 119, 1, 119, 1, 119, 3, 119, 1418, 8, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		3, 119, 1430, 8, 119, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 1436, 8,
		120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 121, 1, 121, 1, 121, 1, 121, 3,
		121, 1446, 8, 121, 1, 121, 3, 121, 1449, 8, 121, 1, 121, 1, 121, 1, 121,
		1, 121, 1, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122,
		3, 122, 1463, 8, 122, 1, 123, 1, 123, 1, 123, 1, 123, 5, 123, 1469, 8,
		123, 10, 123, 12, 123, 1472, 9, 123, 1, 123, 1, 123, 3, 123, 1476, 8, 123,
		1, 123, 3, 123, 1479, 8, 123, 1, 123, 1, 123, 1, 124, 1, 124, 1, 124, 1,
		125, 1, 125, 1, 125, 5, 125, 1489, 8, 125, 10, 125, 12, 125, 1492, 9, 125,
		1, 125, 3, 125, 1495, 8, 125, 1, 126, 3, 126, 1498, 8, 126, 1, 126, 1,
		126, 3, 126, 1502, 8, 126, 1, 126, 1, 126, 3, 126, 1506, 8, 126, 1, 126,
		1, 126, 3, 126, 1510, 8, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 3, 127, 1521, 8, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 3, 127, 1527, 8, 127, 1, 127, 3, 127, 1530, 8, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 3, 127, 1559,
		8, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 3, 127, 1571, 8, 127, 3, 127, 1573, 8, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 3, 127, 1637, 8, 127,
		1, 127, 1, 127, 3, 127, 1641, 8, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 5, 127, 1654, 8, 127,
		10, 127, 12, 127, 1657, 9, 127, 1, 128, 3, 128, 1660, 8, 128, 1, 128, 1,
		128, 3, 128, 1664, 8, 128, 1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129,
		3, 129, 1672, 8, 129, 1, 129, 3, 129, 1675, 8, 129, 1, 130, 1, 130, 1,
		130, 1, 130, 1, 130, 3, 130, 1682, 8, 130, 1, 131, 1, 131, 1, 132, 1, 132,
		1, 132, 1, 132, 1, 132, 1, 132, 3, 132, 1692, 8, 132, 1, 133, 1, 133, 1,
		134, 1, 134, 3, 134, 1698, 8, 134, 1, 135, 1, 135, 1, 135, 3, 135, 1703,
		8, 135, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1, 138, 1, 138,
		1, 138, 1, 138, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 1719, 8, 139, 1,
		139, 0, 4, 20, 22, 114, 254, 140, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,
		22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56,
		58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92,
		94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122,
		124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152,
		154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182,
		184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212,
		214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242,
		244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272,
		274, 276, 278, 0, 14, 2, 0, 79, 79, 115, 119, 1, 0, 11, 12, 2, 0, 108,
		109, 112, 112, 2, 0, 116, 116, 118, 118, 3, 0, 75, 75, 102, 102, 107, 107,
		2, 0, 13, 13, 15, 15, 2, 0, 24, 24, 27, 28, 1, 0, 20, 21, 1, 0, 32, 34,
		1, 0, 35, 38, 1, 0, 39, 42, 2, 0, 48, 58, 60, 60, 1, 0, 63, 67, 1, 0, 68,
		114, 1916, 0, 280, 1, 0, 0, 0, 2, 285, 1, 0, 0, 0, 4, 287, 1, 0, 0, 0,
		6, 293, 1, 0, 0, 0, 8, 306, 1, 0, 0, 0, 10, 308, 1, 0, 0, 0, 12, 311, 1,
		0, 0, 0, 14, 317, 1, 0, 0, 0, 16, 325, 1, 0, 0, 0, 18, 332, 1, 0, 0, 0,
		20, 334, 1, 0, 0, 0, 22, 366, 1, 0, 0, 0, 24, 377, 1, 0, 0, 0, 26, 379,
		1, 0, 0, 0, 28, 384, 1, 0, 0, 0, 30, 388, 1, 0, 0, 0, 32, 401, 1, 0, 0,
		0, 34, 403, 1, 0, 0, 0, 36, 409, 1, 0, 0, 0, 38, 413, 1, 0, 0, 0, 40, 430,
		1, 0, 0, 0, 42, 432, 1, 0, 0, 0, 44, 437, 1, 0, 0, 0, 46, 441, 1, 0, 0,
		0, 48, 450, 1, 0, 0, 0, 50, 460, 1, 0, 0, 0, 52, 472, 1, 0, 0, 0, 54, 485,
		1, 0, 0, 0, 56, 488, 1, 0, 0, 0, 58, 501, 1, 0, 0, 0, 60, 505, 1, 0, 0,
		0, 62, 541, 1, 0, 0, 0, 64, 543, 1, 0, 0, 0, 66, 552, 1, 0, 0, 0, 68, 561,
		1, 0, 0, 0, 70, 565, 1, 0, 0, 0, 72, 567, 1, 0, 0, 0, 74, 576, 1, 0, 0,
		0, 76, 596, 1, 0, 0, 0, 78, 598, 1, 0, 0, 0, 80, 610, 1, 0, 0, 0, 82, 617,
		1, 0, 0, 0, 84, 623, 1, 0, 0, 0, 86, 633, 1, 0, 0, 0, 88, 649, 1, 0, 0,
		0, 90, 663, 1, 0, 0, 0, 92, 666, 1, 0, 0, 0, 94, 675, 1, 0, 0, 0, 96, 685,
		1, 0, 0, 0, 98, 689, 1, 0, 0, 0, 100, 697, 1, 0, 0, 0, 102, 702, 1, 0,
		0, 0, 104, 710, 1, 0, 0, 0, 106, 734, 1, 0, 0, 0, 108, 736, 1, 0, 0, 0,
		110, 739, 1, 0, 0, 0, 112, 743, 1, 0, 0, 0, 114, 754, 1, 0, 0, 0, 116,
		764, 1, 0, 0, 0, 118, 768, 1, 0, 0, 0, 120, 773, 1, 0, 0, 0, 122, 806,
		1, 0, 0, 0, 124, 808, 1, 0, 0, 0, 126, 815, 1, 0, 0, 0, 128, 819, 1, 0,
		0, 0, 130, 827, 1, 0, 0, 0, 132, 840, 1, 0, 0, 0, 134, 852, 1, 0, 0, 0,
		136, 865, 1, 0, 0, 0, 138, 894, 1, 0, 0, 0, 140, 896, 1, 0, 0, 0, 142,
		904, 1, 0, 0, 0, 144, 918, 1, 0, 0, 0, 146, 920, 1, 0, 0, 0, 148, 925,
		1, 0, 0, 0, 150, 1009, 1, 0, 0, 0, 152, 1011, 1, 0, 0, 0, 154, 1013, 1,
		0, 0, 0, 156, 1020, 1, 0, 0, 0, 158, 1027, 1, 0, 0, 0, 160, 1034, 1, 0,
		0, 0, 162, 1041, 1, 0, 0, 0, 164, 1047, 1, 0, 0, 0, 166, 1053, 1, 0, 0,
		0, 168, 1066, 1, 0, 0, 0, 170, 1070, 1, 0, 0, 0, 172, 1076, 1, 0, 0, 0,
		174, 1081, 1, 0, 0, 0, 176, 1085, 1, 0, 0, 0, 178, 1090, 1, 0, 0, 0, 180,
		1099, 1, 0, 0, 0, 182, 1112, 1, 0, 0, 0, 184, 1114, 1, 0, 0, 0, 186, 1117,
		1, 0, 0, 0, 188, 1121, 1, 0, 0, 0, 190, 1137, 1, 0, 0, 0, 192, 1148, 1,
		0, 0, 0, 194, 1153, 1, 0, 0, 0, 196, 1162, 1, 0, 0, 0, 198, 1165, 1, 0,
		0, 0, 200, 1172, 1, 0, 0, 0, 202, 1218, 1, 0, 0, 0, 204, 1221, 1, 0, 0,
		0, 206, 1232, 1, 0, 0, 0, 208, 1236, 1, 0, 0, 0, 210, 1248, 1, 0, 0, 0,
		212, 1262, 1, 0, 0, 0, 214, 1276, 1, 0, 0, 0, 216, 1279, 1, 0, 0, 0, 218,
		1293, 1, 0, 0, 0, 220, 1324, 1, 0, 0, 0, 222, 1327, 1, 0, 0, 0, 224, 1337,
		1, 0, 0, 0, 226, 1341, 1, 0, 0, 0, 228, 1344, 1, 0, 0, 0, 230, 1348, 1,
		0, 0, 0, 232, 1375, 1, 0, 0, 0, 234, 1377, 1, 0, 0, 0, 236, 1382, 1, 0,
		0, 0, 238, 1429, 1, 0, 0, 0, 240, 1431, 1, 0, 0, 0, 242, 1441, 1, 0, 0,
		0, 244, 1462, 1, 0, 0, 0, 246, 1464, 1, 0, 0, 0, 248, 1482, 1, 0, 0, 0,
		250, 1485, 1, 0, 0, 0, 252, 1497, 1, 0, 0, 0, 254, 1572, 1, 0, 0, 0, 256,
		1659, 1, 0, 0, 0, 258, 1674, 1, 0, 0, 0, 260, 1681, 1, 0, 0, 0, 262, 1683,
		1, 0, 0, 0, 264, 1691, 1, 0, 0, 0, 266, 1693, 1, 0, 0, 0, 268, 1697, 1,
		0, 0, 0, 270, 1702, 1, 0, 0, 0, 272, 1704, 1, 0, 0, 0, 274, 1706, 1, 0,
		0, 0, 276, 1710, 1, 0, 0, 0, 278, 1718, 1, 0, 0, 0, 280, 281, 5, 13, 0,
		0, 281, 282, 3, 254, 127, 0, 282, 1, 1, 0, 0, 0, 283, 286, 3, 230, 115,
		0, 284, 286, 3, 236, 118, 0, 285, 283, 1, 0, 0, 0, 285, 284, 1, 0, 0, 0,
		286, 3, 1, 0, 0, 0, 287, 289, 5, 35, 0, 0, 288, 290, 3, 6, 3, 0, 289, 288,
		1, 0, 0, 0, 289, 290, 1, 0, 0, 0, 290, 291, 1, 0, 0, 0, 291, 292, 5, 36,
		0, 0, 292, 5, 1, 0, 0, 0, 293, 298, 3, 8, 4, 0, 294, 295, 5, 12, 0, 0,
		295, 297, 3, 8, 4, 0, 296, 294, 1, 0, 0, 0, 297, 300, 1, 0, 0, 0, 298,
		296, 1, 0, 0, 0, 298, 299, 1, 0, 0, 0, 299, 7, 1, 0, 0, 0, 300, 298, 1,
		0, 0, 0, 301, 303, 5, 131, 0, 0, 302, 304, 3, 10, 5, 0, 303, 302, 1, 0,
		0, 0, 303, 304, 1, 0, 0, 0, 304, 307, 1, 0, 0, 0, 305, 307, 3, 4, 2, 0,
		306, 301, 1, 0, 0, 0, 306, 305, 1, 0, 0, 0, 307, 9, 1, 0, 0, 0, 308, 309,
		5, 100, 0, 0, 309, 310, 3, 18, 9, 0, 310, 11, 1, 0, 0, 0, 311, 313, 5,
		35, 0, 0, 312, 314, 3, 14, 7, 0, 313, 312, 1, 0, 0, 0, 313, 314, 1, 0,
		0, 0, 314, 315, 1, 0, 0, 0, 315, 316, 5, 36, 0, 0, 316, 13, 1, 0, 0, 0,
		317, 322, 3, 16, 8, 0, 318, 319, 5, 12, 0, 0, 319, 321, 3, 16, 8, 0, 320,
		318, 1, 0, 0, 0, 321, 324, 1, 0, 0, 0, 322, 320, 1, 0, 0, 0, 322, 323,
		1, 0, 0, 0, 323, 15, 1, 0, 0, 0, 324, 322, 1, 0, 0, 0, 325, 326, 3, 18,
		9, 0, 326, 17, 1, 0, 0, 0, 327, 333, 3, 20, 10, 0, 328, 333, 3, 48, 24,
		0, 329, 333, 3, 50, 25, 0, 330, 333, 3, 28, 14, 0, 331, 333, 5, 132, 0,
		0, 332, 327, 1, 0, 0, 0, 332, 328, 1, 0, 0, 0, 332, 329, 1, 0, 0, 0, 332,
		330, 1, 0, 0, 0, 332, 331, 1, 0, 0, 0, 333, 19, 1, 0, 0, 0, 334, 335, 6,
		10, -1, 0, 335, 336, 3, 22, 11, 0, 336, 345, 1, 0, 0, 0, 337, 338, 10,
		3, 0, 0, 338, 339, 5, 45, 0, 0, 339, 344, 3, 20, 10, 4, 340, 341, 10, 2,
		0, 0, 341, 342, 5, 43, 0, 0, 342, 344, 3, 20, 10, 3, 343, 337, 1, 0, 0,
		0, 343, 340, 1, 0, 0, 0, 344, 347, 1, 0, 0, 0, 345, 343, 1, 0, 0, 0, 345,
		346, 1, 0, 0, 0, 346, 21, 1, 0, 0, 0, 347, 345, 1, 0, 0, 0, 348, 349, 6,
		11, -1, 0, 349, 350, 5, 7, 0, 0, 350, 351, 3, 18, 9, 0, 351, 352, 5, 8,
		0, 0, 352, 367, 1, 0, 0, 0, 353, 367, 3, 24, 12, 0, 354, 367, 3, 26, 13,
		0, 355, 367, 3, 34, 17, 0, 356, 357, 5, 5, 0, 0, 357, 358, 3, 46, 23, 0,
		358, 359, 5, 6, 0, 0, 359, 367, 1, 0, 0, 0, 360, 367, 3, 52, 26, 0, 361,
		367, 5, 86, 0, 0, 362, 363, 3, 26, 13, 0, 363, 364, 5, 129, 0, 0, 364,
		365, 3, 22, 11, 1, 365, 367, 1, 0, 0, 0, 366, 348, 1, 0, 0, 0, 366, 353,
		1, 0, 0, 0, 366, 354, 1, 0, 0, 0, 366, 355, 1, 0, 0, 0, 366, 356, 1, 0,
		0, 0, 366, 360, 1, 0, 0, 0, 366, 361, 1, 0, 0, 0, 366, 362, 1, 0, 0, 0,
		367, 374, 1, 0, 0, 0, 368, 369, 10, 5, 0, 0, 369, 370, 4, 11, 3, 0, 370,
		371, 5, 5, 0, 0, 371, 373, 5, 6, 0, 0, 372, 368, 1, 0, 0, 0, 373, 376,
		1, 0, 0, 0, 374, 372, 1, 0, 0, 0, 374, 375, 1, 0, 0, 0, 375, 23, 1, 0,
		0, 0, 376, 374, 1, 0, 0, 0, 377, 378, 7, 0, 0, 0, 378, 25, 1, 0, 0, 0,
		379, 382, 3, 32, 16, 0, 380, 383, 3, 30, 15, 0, 381, 383, 3, 28, 14, 0,
		382, 380, 1, 0, 0, 0, 382, 381, 1, 0, 0, 0, 382, 383, 1, 0, 0, 0, 383,
		27, 1, 0, 0, 0, 384, 385, 5, 35, 0, 0, 385, 386, 3, 14, 7, 0, 386, 387,
		5, 36, 0, 0, 387, 29, 1, 0, 0, 0, 388, 389, 5, 35, 0, 0, 389, 390, 3, 14,
		7, 0, 390, 391, 5, 35, 0, 0, 391, 397, 3, 14, 7, 0, 392, 393, 5, 36, 0,
		0, 393, 394, 3, 2, 1, 0, 394, 395, 5, 36, 0, 0, 395, 398, 1, 0, 0, 0, 396,
		398, 5, 32, 0, 0, 397, 392, 1, 0, 0, 0, 397, 396, 1, 0, 0, 0, 398, 31,
		1, 0, 0, 0, 399, 402, 5, 131, 0, 0, 400, 402, 3, 104, 52, 0, 401, 399,
		1, 0, 0, 0, 401, 400, 1, 0, 0, 0, 402, 33, 1, 0, 0, 0, 403, 405, 5, 9,
		0, 0, 404, 406, 3, 36, 18, 0, 405, 404, 1, 0, 0, 0, 405, 406, 1, 0, 0,
		0, 406, 407, 1, 0, 0, 0, 407, 408, 5, 10, 0, 0, 408, 35, 1, 0, 0, 0, 409,
		411, 3, 38, 19, 0, 410, 412, 7, 1, 0, 0, 411, 410, 1, 0, 0, 0, 411, 412,
		1, 0, 0, 0, 412, 37, 1, 0, 0, 0, 413, 418, 3, 40, 20, 0, 414, 415, 7, 1,
		0, 0, 415, 417, 3, 40, 20, 0, 416, 414, 1, 0, 0, 0, 417, 420, 1, 0, 0,
		0, 418, 416, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419, 39, 1, 0, 0, 0, 420,
		418, 1, 0, 0, 0, 421, 431, 3, 56, 28, 0, 422, 431, 3, 60, 30, 0, 423, 431,
		3, 78, 39, 0, 424, 431, 3, 80, 40, 0, 425, 428, 3, 82, 41, 0, 426, 427,
		5, 59, 0, 0, 427, 429, 3, 18, 9, 0, 428, 426, 1, 0, 0, 0, 428, 429, 1,
		0, 0, 0, 429, 431, 1, 0, 0, 0, 430, 421, 1, 0, 0, 0, 430, 422, 1, 0, 0,
		0, 430, 423, 1, 0, 0, 0, 430, 424, 1, 0, 0, 0, 430, 425, 1, 0, 0, 0, 431,
		41, 1, 0, 0, 0, 432, 433, 3, 22, 11, 0, 433, 434, 4, 21, 4, 0, 434, 435,
		5, 5, 0, 0, 435, 436, 5, 6, 0, 0, 436, 43, 1, 0, 0, 0, 437, 438, 5, 5,
		0, 0, 438, 439, 3, 46, 23, 0, 439, 440, 5, 6, 0, 0, 440, 45, 1, 0, 0, 0,
		441, 446, 3, 18, 9, 0, 442, 443, 5, 12, 0, 0, 443, 445, 3, 18, 9, 0, 444,
		442, 1, 0, 0, 0, 445, 448, 1, 0, 0, 0, 446, 444, 1, 0, 0, 0, 446, 447,
		1, 0, 0, 0, 447, 47, 1, 0, 0, 0, 448, 446, 1, 0, 0, 0, 449, 451, 3, 4,
		2, 0, 450, 449, 1, 0, 0, 0, 450, 451, 1, 0, 0, 0, 451, 452, 1, 0, 0, 0,
		452, 454, 5, 7, 0, 0, 453, 455, 3, 62, 31, 0, 454, 453, 1, 0, 0, 0, 454,
		455, 1, 0, 0, 0, 455, 456, 1, 0, 0, 0, 456, 457, 5, 8, 0, 0, 457, 458,
		5, 59, 0, 0, 458, 459, 3, 18, 9, 0, 459, 49, 1, 0, 0, 0, 460, 462, 5, 74,
		0, 0, 461, 463, 3, 4, 2, 0, 462, 461, 1, 0, 0, 0, 462, 463, 1, 0, 0, 0,
		463, 464, 1, 0, 0, 0, 464, 466, 5, 7, 0, 0, 465, 467, 3, 62, 31, 0, 466,
		465, 1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 469,
		5, 8, 0, 0, 469, 470, 5, 59, 0, 0, 470, 471, 3, 18, 9, 0, 471, 51, 1, 0,
		0, 0, 472, 473, 5, 71, 0, 0, 473, 474, 3, 54, 27, 0, 474, 53, 1, 0, 0,
		0, 475, 486, 5, 131, 0, 0, 476, 477, 3, 268, 134, 0, 477, 478, 5, 17, 0,
		0, 478, 480, 1, 0, 0, 0, 479, 476, 1, 0, 0, 0, 480, 481, 1, 0, 0, 0, 481,
		479, 1, 0, 0, 0, 481, 482, 1, 0, 0, 0, 482, 483, 1, 0, 0, 0, 483, 484,
		3, 268, 134, 0, 484, 486, 1, 0, 0, 0, 485, 475, 1, 0, 0, 0, 485, 479, 1,
		0, 0, 0, 486, 55, 1, 0, 0, 0, 487, 489, 5, 96, 0, 0, 488, 487, 1, 0, 0,
		0, 488, 489, 1, 0, 0, 0, 489, 490, 1, 0, 0, 0, 490, 492, 3, 244, 122, 0,
		491, 493, 5, 14, 0, 0, 492, 491, 1, 0, 0, 0, 492, 493, 1, 0, 0, 0, 493,
		495, 1, 0, 0, 0, 494, 496, 3, 58, 29, 0, 495, 494, 1, 0, 0, 0, 495, 496,
		1, 0, 0, 0, 496, 499, 1, 0, 0, 0, 497, 498, 5, 59, 0, 0, 498, 500, 3, 18,
		9, 0, 499, 497, 1, 0, 0, 0, 499, 500, 1, 0, 0, 0, 500, 57, 1, 0, 0, 0,
		501, 502, 5, 15, 0, 0, 502, 503, 3, 18, 9, 0, 503, 59, 1, 0, 0, 0, 504,
		506, 3, 4, 2, 0, 505, 504, 1, 0, 0, 0, 505, 506, 1, 0, 0, 0, 506, 507,
		1, 0, 0, 0, 507, 509, 5, 7, 0, 0, 508, 510, 3, 62, 31, 0, 509, 508, 1,
		0, 0, 0, 509, 510, 1, 0, 0, 0, 510, 511, 1, 0, 0, 0, 511, 513, 5, 8, 0,
		0, 512, 514, 3, 58, 29, 0, 513, 512, 1, 0, 0, 0, 513, 514, 1, 0, 0, 0,
		514, 61, 1, 0, 0, 0, 515, 542, 3, 76, 38, 0, 516, 521, 3, 24, 12, 0, 517,
		518, 5, 12, 0, 0, 518, 520, 3, 24, 12, 0, 519, 517, 1, 0, 0, 0, 520, 523,
		1, 0, 0, 0, 521, 519, 1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522, 542, 1, 0,
		0, 0, 523, 521, 1, 0, 0, 0, 524, 527, 3, 72, 36, 0, 525, 526, 5, 12, 0,
		0, 526, 528, 3, 76, 38, 0, 527, 525, 1, 0, 0, 0, 527, 528, 1, 0, 0, 0,
		528, 542, 1, 0, 0, 0, 529, 539, 3, 64, 32, 0, 530, 537, 5, 12, 0, 0, 531,
		534, 3, 72, 36, 0, 532, 533, 5, 12, 0, 0, 533, 535, 3, 76, 38, 0, 534,
		532, 1, 0, 0, 0, 534, 535, 1, 0, 0, 0, 535, 538, 1, 0, 0, 0, 536, 538,
		3, 76, 38, 0, 537, 531, 1, 0, 0, 0, 537, 536, 1, 0, 0, 0, 538, 540, 1,
		0, 0, 0, 539, 530, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 542, 1, 0, 0,
		0, 541, 515, 1, 0, 0, 0, 541, 516, 1, 0, 0, 0, 541, 524, 1, 0, 0, 0, 541,
		529, 1, 0, 0, 0, 542, 63, 1, 0, 0, 0, 543, 548, 3, 66, 33, 0, 544, 545,
		5, 12, 0, 0, 545, 547, 3, 66, 33, 0, 546, 544, 1, 0, 0, 0, 547, 550, 1,
		0, 0, 0, 548, 546, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549, 65, 1, 0, 0,
		0, 550, 548, 1, 0, 0, 0, 551, 553, 3, 110, 55, 0, 552, 551, 1, 0, 0, 0,
		552, 553, 1, 0, 0, 0, 553, 555, 1, 0, 0, 0, 554, 556, 3, 68, 34, 0, 555,
		554, 1, 0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 559,
		3, 70, 35, 0, 558, 560, 3, 58, 29, 0, 559, 558, 1, 0, 0, 0, 559, 560, 1,
		0, 0, 0, 560, 67, 1, 0, 0, 0, 561, 562, 7, 2, 0, 0, 562, 69, 1, 0, 0, 0,
		563, 566, 3, 268, 134, 0, 564, 566, 3, 2, 1, 0, 565, 563, 1, 0, 0, 0, 565,
		564, 1, 0, 0, 0, 566, 71, 1, 0, 0, 0, 567, 572, 3, 74, 37, 0, 568, 569,
		5, 12, 0, 0, 569, 571, 3, 74, 37, 0, 570, 568, 1, 0, 0, 0, 571, 574, 1,
		0, 0, 0, 572, 570, 1, 0, 0, 0, 572, 573, 1, 0, 0, 0, 573, 73, 1, 0, 0,
		0, 574, 572, 1, 0, 0, 0, 575, 577, 3, 110, 55, 0, 576, 575, 1, 0, 0, 0,
		576, 577, 1, 0, 0, 0, 577, 579, 1, 0, 0, 0, 578, 580, 3, 68, 34, 0, 579,
		578, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 581, 1, 0, 0, 0, 581, 590,
		3, 70, 35, 0, 582, 584, 5, 14, 0, 0, 583, 585, 3, 58, 29, 0, 584, 583,
		1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 591, 1, 0, 0, 0, 586, 588, 3, 58,
		29, 0, 587, 586, 1, 0, 0, 0, 587, 588, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0,
		589, 591, 3, 0, 0, 0, 590, 582, 1, 0, 0, 0, 590, 587, 1, 0, 0, 0, 591,
		75, 1, 0, 0, 0, 592, 593, 5, 16, 0, 0, 593, 597, 3, 66, 33, 0, 594, 595,
		5, 16, 0, 0, 595, 597, 3, 254, 127, 0, 596, 592, 1, 0, 0, 0, 596, 594,
		1, 0, 0, 0, 597, 77, 1, 0, 0, 0, 598, 600, 5, 74, 0, 0, 599, 601, 3, 4,
		2, 0, 600, 599, 1, 0, 0, 0, 600, 601, 1, 0, 0, 0, 601, 602, 1, 0, 0, 0,
		602, 604, 5, 7, 0, 0, 603, 605, 3, 62, 31, 0, 604, 603, 1, 0, 0, 0, 604,
		605, 1, 0, 0, 0, 605, 606, 1, 0, 0, 0, 606, 608, 5, 8, 0, 0, 607, 609,
		3, 58, 29, 0, 608, 607, 1, 0, 0, 0, 608, 609, 1, 0, 0, 0, 609, 79, 1, 0,
		0, 0, 610, 611, 5, 5, 0, 0, 611, 612, 5, 131, 0, 0, 612, 613, 5, 15, 0,
		0, 613, 614, 7, 3, 0, 0, 614, 615, 5, 6, 0, 0, 615, 616, 3, 58, 29, 0,
		616, 81, 1, 0, 0, 0, 617, 619, 3, 244, 122, 0, 618, 620, 5, 14, 0, 0, 619,
		618, 1, 0, 0, 0, 619, 620, 1, 0, 0, 0, 620, 621, 1, 0, 0, 0, 621, 622,
		3, 60, 30, 0, 622, 83, 1, 0, 0, 0, 623, 624, 5, 120, 0, 0, 624, 626, 5,
		131, 0, 0, 625, 627, 3, 4, 2, 0, 626, 625, 1, 0, 0, 0, 626, 627, 1, 0,
		0, 0, 627, 628, 1, 0, 0, 0, 628, 629, 5, 13, 0, 0, 629, 630, 3, 18, 9,
		0, 630, 631, 5, 11, 0, 0, 631, 85, 1, 0, 0, 0, 632, 634, 3, 68, 34, 0,
		633, 632, 1, 0, 0, 0, 633, 634, 1, 0, 0, 0, 634, 635, 1, 0, 0, 0, 635,
		636, 5, 123, 0, 0, 636, 638, 5, 7, 0, 0, 637, 639, 3, 220, 110, 0, 638,
		637, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 640, 1, 0, 0, 0, 640, 646,
		5, 8, 0, 0, 641, 642, 5, 9, 0, 0, 642, 643, 3, 226, 113, 0, 643, 644, 5,
		10, 0, 0, 644, 647, 1, 0, 0, 0, 645, 647, 5, 11, 0, 0, 646, 641, 1, 0,
		0, 0, 646, 645, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 87, 1, 0, 0, 0,
		648, 650, 5, 103, 0, 0, 649, 648, 1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650,
		651, 1, 0, 0, 0, 651, 652, 5, 110, 0, 0, 652, 654, 5, 131, 0, 0, 653, 655,
		3, 4, 2, 0, 654, 653, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 657, 1, 0,
		0, 0, 656, 658, 3, 90, 45, 0, 657, 656, 1, 0, 0, 0, 657, 658, 1, 0, 0,
		0, 658, 659, 1, 0, 0, 0, 659, 661, 3, 34, 17, 0, 660, 662, 5, 11, 0, 0,
		661, 660, 1, 0, 0, 0, 661, 662, 1, 0, 0, 0, 662, 89, 1, 0, 0, 0, 663, 664,
		5, 100, 0, 0, 664, 665, 3, 92, 46, 0, 665, 91, 1, 0, 0, 0, 666, 671, 3,
		26, 13, 0, 667, 668, 5, 12, 0, 0, 668, 670, 3, 26, 13, 0, 669, 667, 1,
		0, 0, 0, 670, 673, 1, 0, 0, 0, 671, 669, 1, 0, 0, 0, 671, 672, 1, 0, 0,
		0, 672, 93, 1, 0, 0, 0, 673, 671, 1, 0, 0, 0, 674, 676, 5, 102, 0, 0, 675,
		674, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676, 677, 1, 0, 0, 0, 677, 678,
		5, 99, 0, 0, 678, 679, 5, 131, 0, 0, 679, 681, 5, 9, 0, 0, 680, 682, 3,
		96, 48, 0, 681, 680, 1, 0, 0, 0, 681, 682, 1, 0, 0, 0, 682, 683, 1, 0,
		0, 0, 683, 684, 5, 10, 0, 0, 684, 95, 1, 0, 0, 0, 685, 687, 3, 98, 49,
		0, 686, 688, 5, 12, 0, 0, 687, 686, 1, 0, 0, 0, 687, 688, 1, 0, 0, 0, 688,
		97, 1, 0, 0, 0, 689, 694, 3, 100, 50, 0, 690, 691, 5, 12, 0, 0, 691, 693,
		3, 100, 50, 0, 692, 690, 1, 0, 0, 0, 693, 696, 1, 0, 0, 0, 694, 692, 1,
		0, 0, 0, 694, 695, 1, 0, 0, 0, 695, 99, 1, 0, 0, 0, 696, 694, 1, 0, 0,
		0, 697, 700, 3, 244, 122, 0, 698, 699, 5, 13, 0, 0, 699, 701, 3, 254, 127,
		0, 700, 698, 1, 0, 0, 0, 700, 701, 1, 0, 0, 0, 701, 101, 1, 0, 0, 0, 702,
		703, 5, 124, 0, 0, 703, 704, 3, 104, 52, 0, 704, 706, 5, 9, 0, 0, 705,
		707, 3, 126, 63, 0, 706, 705, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707, 708,
		1, 0, 0, 0, 708, 709, 5, 10, 0, 0, 709, 103, 1, 0, 0, 0, 710, 719, 5, 131,
		0, 0, 711, 713, 5, 17, 0, 0, 712, 711, 1, 0, 0, 0, 713, 714, 1, 0, 0, 0,
		714, 712, 1, 0, 0, 0, 714, 715, 1, 0, 0, 0, 715, 716, 1, 0, 0, 0, 716,
		718, 5, 131, 0, 0, 717, 712, 1, 0, 0, 0, 718, 721, 1, 0, 0, 0, 719, 717,
		1, 0, 0, 0, 719, 720, 1, 0, 0, 0, 720, 105, 1, 0, 0, 0, 721, 719, 1, 0,
		0, 0, 722, 723, 5, 131, 0, 0, 723, 724, 5, 13, 0, 0, 724, 725, 3, 104,
		52, 0, 725, 726, 5, 11, 0, 0, 726, 735, 1, 0, 0, 0, 727, 728, 5, 131, 0,
		0, 728, 729, 5, 13, 0, 0, 729, 730, 5, 125, 0, 0, 730, 731, 5, 7, 0, 0,
		731, 732, 5, 132, 0, 0, 732, 733, 5, 8, 0, 0, 733, 735, 5, 11, 0, 0, 734,
		722, 1, 0, 0, 0, 734, 727, 1, 0, 0, 0, 735, 107, 1, 0, 0, 0, 736, 737,
		5, 132, 0, 0, 737, 109, 1, 0, 0, 0, 738, 740, 3, 112, 56, 0, 739, 738,
		1, 0, 0, 0, 740, 741, 1, 0, 0, 0, 741, 739, 1, 0, 0, 0, 741, 742, 1, 0,
		0, 0, 742, 111, 1, 0, 0, 0, 743, 746, 5, 130, 0, 0, 744, 747, 3, 114, 57,
		0, 745, 747, 3, 116, 58, 0, 746, 744, 1, 0, 0, 0, 746, 745, 1, 0, 0, 0,
		747, 113, 1, 0, 0, 0, 748, 749, 6, 57, -1, 0, 749, 755, 5, 131, 0, 0, 750,
		751, 5, 7, 0, 0, 751, 752, 3, 254, 127, 0, 752, 753, 5, 8, 0, 0, 753, 755,
		1, 0, 0, 0, 754, 748, 1, 0, 0, 0, 754, 750, 1, 0, 0, 0, 755, 761, 1, 0,
		0, 0, 756, 757, 10, 2, 0, 0, 757, 758, 5, 17, 0, 0, 758, 760, 3, 268, 134,
		0, 759, 756, 1, 0, 0, 0, 760, 763, 1, 0, 0, 0, 761, 759, 1, 0, 0, 0, 761,
		762, 1, 0, 0, 0, 762, 115, 1, 0, 0, 0, 763, 761, 1, 0, 0, 0, 764, 765,
		3, 114, 57, 0, 765, 766, 3, 246, 123, 0, 766, 117, 1, 0, 0, 0, 767, 769,
		3, 228, 114, 0, 768, 767, 1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769, 770, 1,
		0, 0, 0, 770, 771, 5, 0, 0, 1, 771, 119, 1, 0, 0, 0, 772, 774, 5, 103,
		0, 0, 773, 772, 1, 0, 0, 0, 773, 774, 1, 0, 0, 0, 774, 775, 1, 0, 0, 0,
		775, 776, 3, 122, 61, 0, 776, 121, 1, 0, 0, 0, 777, 807, 3, 124, 62, 0,
		778, 807, 3, 138, 69, 0, 779, 807, 3, 130, 65, 0, 780, 807, 3, 136, 68,
		0, 781, 807, 3, 144, 72, 0, 782, 807, 3, 128, 64, 0, 783, 807, 3, 190,
		95, 0, 784, 807, 3, 88, 44, 0, 785, 807, 3, 102, 51, 0, 786, 807, 3, 148,
		74, 0, 787, 807, 3, 150, 75, 0, 788, 807, 3, 154, 77, 0, 789, 807, 3, 156,
		78, 0, 790, 807, 3, 158, 79, 0, 791, 807, 3, 160, 80, 0, 792, 807, 3, 162,
		81, 0, 793, 807, 3, 174, 87, 0, 794, 807, 3, 164, 82, 0, 795, 807, 3, 176,
		88, 0, 796, 807, 3, 178, 89, 0, 797, 807, 3, 186, 93, 0, 798, 807, 3, 188,
		94, 0, 799, 807, 3, 256, 128, 0, 800, 807, 3, 210, 105, 0, 801, 807, 3,
		84, 42, 0, 802, 807, 3, 94, 47, 0, 803, 807, 3, 146, 73, 0, 804, 805, 5,
		103, 0, 0, 805, 807, 3, 122, 61, 0, 806, 777, 1, 0, 0, 0, 806, 778, 1,
		0, 0, 0, 806, 779, 1, 0, 0, 0, 806, 780, 1, 0, 0, 0, 806, 781, 1, 0, 0,
		0, 806, 782, 1, 0, 0, 0, 806, 783, 1, 0, 0, 0, 806, 784, 1, 0, 0, 0, 806,
		785, 1, 0, 0, 0, 806, 786, 1, 0, 0, 0, 806, 787, 1, 0, 0, 0, 806, 788,
		1, 0, 0, 0, 806, 789, 1, 0, 0, 0, 806, 790, 1, 0, 0, 0, 806, 791, 1, 0,
		0, 0, 806, 792, 1, 0, 0, 0, 806, 793, 1, 0, 0, 0, 806, 794, 1, 0, 0, 0,
		806, 795, 1, 0, 0, 0, 806, 796, 1, 0, 0, 0, 806, 797, 1, 0, 0, 0, 806,
		798, 1, 0, 0, 0, 806, 799, 1, 0, 0, 0, 806, 800, 1, 0, 0, 0, 806, 801,
		1, 0, 0, 0, 806, 802, 1, 0, 0, 0, 806, 803, 1, 0, 0, 0, 806, 804, 1, 0,
		0, 0, 807, 123, 1, 0, 0, 0, 808, 810, 5, 9, 0, 0, 809, 811, 3, 126, 63,
		0, 810, 809, 1, 0, 0, 0, 810, 811, 1, 0, 0, 0, 811, 812, 1, 0, 0, 0, 812,
		813, 5, 10, 0, 0, 813, 125, 1, 0, 0, 0, 814, 816, 3, 122, 61, 0, 815, 814,
		1, 0, 0, 0, 816, 817, 1, 0, 0, 0, 817, 815, 1, 0, 0, 0, 817, 818, 1, 0,
		0, 0, 818, 127, 1, 0, 0, 0, 819, 823, 5, 128, 0, 0, 820, 821, 5, 131, 0,
		0, 821, 824, 3, 60, 30, 0, 822, 824, 3, 138, 69, 0, 823, 820, 1, 0, 0,
		0, 823, 822, 1, 0, 0, 0, 824, 825, 1, 0, 0, 0, 825, 826, 3, 278, 139, 0,
		826, 129, 1, 0, 0, 0, 827, 831, 5, 104, 0, 0, 828, 832, 3, 132, 66, 0,
		829, 832, 3, 106, 53, 0, 830, 832, 3, 108, 54, 0, 831, 828, 1, 0, 0, 0,
		831, 829, 1, 0, 0, 0, 831, 830, 1, 0, 0, 0, 832, 833, 1, 0, 0, 0, 833,
		834, 3, 278, 139, 0, 834, 131, 1, 0, 0, 0, 835, 841, 5, 26, 0, 0, 836,
		841, 5, 25, 0, 0, 837, 841, 5, 24, 0, 0, 838, 841, 3, 134, 67, 0, 839,
		841, 3, 268, 134, 0, 840, 835, 1, 0, 0, 0, 840, 836, 1, 0, 0, 0, 840, 837,
		1, 0, 0, 0, 840, 838, 1, 0, 0, 0, 840, 839, 1, 0, 0, 0, 841, 844, 1, 0,
		0, 0, 842, 843, 5, 94, 0, 0, 843, 845, 3, 268, 134, 0, 844, 842, 1, 0,
		0, 0, 844, 845, 1, 0, 0, 0, 845, 846, 1, 0, 0, 0, 846, 847, 5, 95, 0, 0,
		847, 848, 5, 132, 0, 0, 848, 133, 1, 0, 0, 0, 849, 850, 3, 268, 134, 0,
		850, 851, 5, 12, 0, 0, 851, 853, 1, 0, 0, 0, 852, 849, 1, 0, 0, 0, 852,
		853, 1, 0, 0, 0, 853, 854, 1, 0, 0, 0, 854, 855, 5, 9, 0, 0, 855, 860,
		3, 268, 134, 0, 856, 857, 5, 12, 0, 0, 857, 859, 3, 268, 134, 0, 858, 856,
		1, 0, 0, 0, 859, 862, 1, 0, 0, 0, 860, 858, 1, 0, 0, 0, 860, 861, 1, 0,
		0, 0, 861, 863, 1, 0, 0, 0, 862, 860, 1, 0, 0, 0, 863, 864, 5, 10, 0, 0,
		864, 135, 1, 0, 0, 0, 865, 867, 5, 103, 0, 0, 866, 868, 5, 88, 0, 0, 867,
		866, 1, 0, 0, 0, 867, 868, 1, 0, 0, 0, 868, 871, 1, 0, 0, 0, 869, 872,
		3, 132, 66, 0, 870, 872, 3, 122, 61, 0, 871, 869, 1, 0, 0, 0, 871, 870,
		1, 0, 0, 0, 872, 137, 1, 0, 0, 0, 873, 875, 3, 2, 1, 0, 874, 876, 3, 58,
		29, 0, 875, 874, 1, 0, 0, 0, 875, 876, 1, 0, 0, 0, 876, 877, 1, 0, 0, 0,
		877, 879, 3, 0, 0, 0, 878, 880, 5, 11, 0, 0, 879, 878, 1, 0, 0, 0, 879,
		880, 1, 0, 0, 0, 880, 895, 1, 0, 0, 0, 881, 883, 3, 68, 34, 0, 882, 881,
		1, 0, 0, 0, 882, 883, 1, 0, 0, 0, 883, 885, 1, 0, 0, 0, 884, 886, 3, 152,
		76, 0, 885, 884, 1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886, 888, 1, 0, 0, 0,
		887, 889, 5, 96, 0, 0, 888, 887, 1, 0, 0, 0, 888, 889, 1, 0, 0, 0, 889,
		890, 1, 0, 0, 0, 890, 892, 3, 140, 70, 0, 891, 893, 5, 11, 0, 0, 892, 891,
		1, 0, 0, 0, 892, 893, 1, 0, 0, 0, 893, 895, 1, 0, 0, 0, 894, 873, 1, 0,
		0, 0, 894, 882, 1, 0, 0, 0, 895, 139, 1, 0, 0, 0, 896, 901, 3, 142, 71,
		0, 897, 898, 5, 12, 0, 0, 898, 900, 3, 142, 71, 0, 899, 897, 1, 0, 0, 0,
		900, 903, 1, 0, 0, 0, 901, 899, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0, 902,
		141, 1, 0, 0, 0, 903, 901, 1, 0, 0, 0, 904, 906, 3, 182, 91, 0, 905, 907,
		3, 58, 29, 0, 906, 905, 1, 0, 0, 0, 906, 907, 1, 0, 0, 0, 907, 909, 1,
		0, 0, 0, 908, 910, 3, 254, 127, 0, 909, 908, 1, 0, 0, 0, 909, 910, 1, 0,
		0, 0, 910, 916, 1, 0, 0, 0, 911, 913, 5, 13, 0, 0, 912, 914, 3, 4, 2, 0,
		913, 912, 1, 0, 0, 0, 913, 914, 1, 0, 0, 0, 914, 915, 1, 0, 0, 0, 915,
		917, 3, 254, 127, 0, 916, 911, 1, 0, 0, 0, 916, 917, 1, 0, 0, 0, 917, 143,
		1, 0, 0, 0, 918, 919, 5, 11, 0, 0, 919, 145, 1, 0, 0, 0, 920, 921, 4, 73,
		6, 0, 921, 923, 3, 250, 125, 0, 922, 924, 5, 11, 0, 0, 923, 922, 1, 0,
		0, 0, 923, 924, 1, 0, 0, 0, 924, 147, 1, 0, 0, 0, 925, 926, 5, 89, 0, 0,
		926, 927, 5, 7, 0, 0, 927, 928, 3, 250, 125, 0, 928, 929, 5, 8, 0, 0, 929,
		932, 3, 122, 61, 0, 930, 931, 5, 73, 0, 0, 931, 933, 3, 122, 61, 0, 932,
		930, 1, 0, 0, 0, 932, 933, 1, 0, 0, 0, 933, 149, 1, 0, 0, 0, 934, 935,
		5, 69, 0, 0, 935, 936, 3, 122, 61, 0, 936, 937, 5, 83, 0, 0, 937, 938,
		5, 7, 0, 0, 938, 939, 3, 250, 125, 0, 939, 940, 5, 8, 0, 0, 940, 941, 3,
		278, 139, 0, 941, 1010, 1, 0, 0, 0, 942, 943, 5, 83, 0, 0, 943, 944, 5,
		7, 0, 0, 944, 945, 3, 250, 125, 0, 945, 946, 5, 8, 0, 0, 946, 947, 3, 122,
		61, 0, 947, 1010, 1, 0, 0, 0, 948, 949, 5, 81, 0, 0, 949, 951, 5, 7, 0,
		0, 950, 952, 3, 250, 125, 0, 951, 950, 1, 0, 0, 0, 951, 952, 1, 0, 0, 0,
		952, 953, 1, 0, 0, 0, 953, 955, 5, 11, 0, 0, 954, 956, 3, 250, 125, 0,
		955, 954, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 957, 1, 0, 0, 0, 957,
		959, 5, 11, 0, 0, 958, 960, 3, 250, 125, 0, 959, 958, 1, 0, 0, 0, 959,
		960, 1, 0, 0, 0, 960, 961, 1, 0, 0, 0, 961, 962, 5, 8, 0, 0, 962, 1010,
		3, 122, 61, 0, 963, 964, 5, 81, 0, 0, 964, 965, 5, 7, 0, 0, 965, 966, 3,
		152, 76, 0, 966, 967, 3, 140, 70, 0, 967, 969, 5, 11, 0, 0, 968, 970, 3,
		250, 125, 0, 969, 968, 1, 0, 0, 0, 969, 970, 1, 0, 0, 0, 970, 971, 1, 0,
		0, 0, 971, 973, 5, 11, 0, 0, 972, 974, 3, 250, 125, 0, 973, 972, 1, 0,
		0, 0, 973, 974, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 976, 5, 8, 0, 0,
		976, 977, 3, 122, 61, 0, 977, 1010, 1, 0, 0, 0, 978, 980, 5, 81, 0, 0,
		979, 981, 5, 105, 0, 0, 980, 979, 1, 0, 0, 0, 980, 981, 1, 0, 0, 0, 981,
		982, 1, 0, 0, 0, 982, 983, 5, 7, 0, 0, 983, 987, 3, 254, 127, 0, 984, 988,
		5, 92, 0, 0, 985, 986, 5, 131, 0, 0, 986, 988, 4, 75, 7, 0, 987, 984, 1,
		0, 0, 0, 987, 985, 1, 0, 0, 0, 988, 989, 1, 0, 0, 0, 989, 990, 3, 250,
		125, 0, 990, 991, 5, 8, 0, 0, 991, 992, 3, 122, 61, 0, 992, 1010, 1, 0,
		0, 0, 993, 995, 5, 81, 0, 0, 994, 996, 5, 105, 0, 0, 995, 994, 1, 0, 0,
		0, 995, 996, 1, 0, 0, 0, 996, 997, 1, 0, 0, 0, 997, 998, 5, 7, 0, 0, 998,
		999, 3, 152, 76, 0, 999, 1003, 3, 142, 71, 0, 1000, 1004, 5, 92, 0, 0,
		1001, 1002, 5, 131, 0, 0, 1002, 1004, 4, 75, 8, 0, 1003, 1000, 1, 0, 0,
		0, 1003, 1001, 1, 0, 0, 0, 1004, 1005, 1, 0, 0, 0, 1005, 1006, 3, 250,
		125, 0, 1006, 1007, 5, 8, 0, 0, 1007, 1008, 3, 122, 61, 0, 1008, 1010,
		1, 0, 0, 0, 1009, 934, 1, 0, 0, 0, 1009, 942, 1, 0, 0, 0, 1009, 948, 1,
		0, 0, 0, 1009, 963, 1, 0, 0, 0, 1009, 978, 1, 0, 0, 0, 1009, 993, 1, 0,
		0, 0, 1010, 151, 1, 0, 0, 0, 1011, 1012, 7, 4, 0, 0, 1012, 153, 1, 0, 0,
		0, 1013, 1016, 5, 80, 0, 0, 1014, 1015, 4, 77, 9, 0, 1015, 1017, 5, 131,
		0, 0, 1016, 1014, 1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018, 1, 0,
		0, 0, 1018, 1019, 3, 278, 139, 0, 1019, 155, 1, 0, 0, 0, 1020, 1023, 5,
		68, 0, 0, 1021, 1022, 4, 78, 10, 0, 1022, 1024, 5, 131, 0, 0, 1023, 1021,
		1, 0, 0, 0, 1023, 1024, 1, 0, 0, 0, 1024, 1025, 1, 0, 0, 0, 1025, 1026,
		3, 278, 139, 0, 1026, 157, 1, 0, 0, 0, 1027, 1030, 5, 78, 0, 0, 1028, 1029,
		4, 79, 11, 0, 1029, 1031, 3, 250, 125, 0, 1030, 1028, 1, 0, 0, 0, 1030,
		1031, 1, 0, 0, 0, 1031, 1032, 1, 0, 0, 0, 1032, 1033, 3, 278, 139, 0, 1033,
		159, 1, 0, 0, 0, 1034, 1037, 5, 114, 0, 0, 1035, 1036, 4, 80, 12, 0, 1036,
		1038, 3, 250, 125, 0, 1037, 1035, 1, 0, 0, 0, 1037, 1038, 1, 0, 0, 0, 1038,
		1039, 1, 0, 0, 0, 1039, 1040, 3, 278, 139, 0, 1040, 161, 1, 0, 0, 0, 1041,
		1042, 5, 87, 0, 0, 1042, 1043, 5, 7, 0, 0, 1043, 1044, 3, 250, 125, 0,
		1044, 1045, 5, 8, 0, 0, 1045, 1046, 3, 122, 61, 0, 1046, 163, 1, 0, 0,
		0, 1047, 1048, 5, 82, 0, 0, 1048, 1049, 5, 7, 0, 0, 1049, 1050, 3, 250,
		125, 0, 1050, 1051, 5, 8, 0, 0, 1051, 1052, 3, 166, 83, 0, 1052, 165, 1,
		0, 0, 0, 1053, 1055, 5, 9, 0, 0, 1054, 1056, 3, 168, 84, 0, 1055, 1054,
		1, 0, 0, 0, 1055, 1056, 1, 0, 0, 0, 1056, 1061, 1, 0, 0, 0, 1057, 1059,
		3, 172, 86, 0, 1058, 1060, 3, 168, 84, 0, 1059, 1058, 1, 0, 0, 0, 1059,
		1060, 1, 0, 0, 0, 1060, 1062, 1, 0, 0, 0, 1061, 1057, 1, 0, 0, 0, 1061,
		1062, 1, 0, 0, 0, 1062, 1063, 1, 0, 0, 0, 1063, 1064, 5, 10, 0, 0, 1064,
		167, 1, 0, 0, 0, 1065, 1067, 3, 170, 85, 0, 1066, 1065, 1, 0, 0, 0, 1067,
		1068, 1, 0, 0, 0, 1068, 1066, 1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069,
		169, 1, 0, 0, 0, 1070, 1071, 5, 72, 0, 0, 1071, 1072, 3, 250, 125, 0, 1072,
		1074, 5, 15, 0, 0, 1073, 1075, 3, 126, 63, 0, 1074, 1073, 1, 0, 0, 0, 1074,
		1075, 1, 0, 0, 0, 1075, 171, 1, 0, 0, 0, 1076, 1077, 5, 88, 0, 0, 1077,
		1079, 5, 15, 0, 0, 1078, 1080, 3, 126, 63, 0, 1079, 1078, 1, 0, 0, 0, 1079,
		1080, 1, 0, 0, 0, 1080, 173, 1, 0, 0, 0, 1081, 1082, 5, 131, 0, 0, 1082,
		1083, 5, 15, 0, 0, 1083, 1084, 3, 122, 61, 0, 1084, 175, 1, 0, 0, 0, 1085,
		1086, 5, 90, 0, 0, 1086, 1087, 4, 88, 13, 0, 1087, 1088, 3, 250, 125, 0,
		1088, 1089, 3, 278, 139, 0, 1089, 177, 1, 0, 0, 0, 1090, 1091, 5, 93, 0,
		0, 1091, 1097, 3, 124, 62, 0, 1092, 1094, 3, 180, 90, 0, 1093, 1095, 3,
		184, 92, 0, 1094, 1093, 1, 0, 0, 0, 1094, 1095, 1, 0, 0, 0, 1095, 1098,
		1, 0, 0, 0, 1096, 1098, 3, 184, 92, 0, 1097, 1092, 1, 0, 0, 0, 1097, 1096,
		1, 0, 0, 0, 1098, 179, 1, 0, 0, 0, 1099, 1105, 5, 76, 0, 0, 1100, 1102,
		5, 7, 0, 0, 1101, 1103, 3, 182, 91, 0, 1102, 1101, 1, 0, 0, 0, 1102, 1103,
		1, 0, 0, 0, 1103, 1104, 1, 0, 0, 0, 1104, 1106, 5, 8, 0, 0, 1105, 1100,
		1, 0, 0, 0, 1105, 1106, 1, 0, 0, 0, 1106, 1107, 1, 0, 0, 0, 1107, 1108,
		3, 124, 62, 0, 1108, 181, 1, 0, 0, 0, 1109, 1113, 5, 131, 0, 0, 1110, 1113,
		3, 230, 115, 0, 1111, 1113, 3, 236, 118, 0, 1112, 1109, 1, 0, 0, 0, 1112,
		1110, 1, 0, 0, 0, 1112, 1111, 1, 0, 0, 0, 1113, 183, 1, 0, 0, 0, 1114,
		1115, 5, 77, 0, 0, 1115, 1116, 3, 124, 62, 0, 1116, 185, 1, 0, 0, 0, 1117,
		1118, 5, 84, 0, 0, 1118, 1119, 3, 278, 139, 0, 1119, 187, 1, 0, 0, 0, 1120,
		1122, 5, 97, 0, 0, 1121, 1120, 1, 0, 0, 0, 1121, 1122, 1, 0, 0, 0, 1122,
		1123, 1, 0, 0, 0, 1123, 1125, 5, 85, 0, 0, 1124, 1126, 5, 24, 0, 0, 1125,
		1124, 1, 0, 0, 0, 1125, 1126, 1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127,
		1128, 5, 131, 0, 0, 1128, 1134, 3, 60, 30, 0, 1129, 1130, 5, 9, 0, 0, 1130,
		1131, 3, 226, 113, 0, 1131, 1132, 5, 10, 0, 0, 1132, 1135, 1, 0, 0, 0,
		1133, 1135, 5, 11, 0, 0, 1134, 1129, 1, 0, 0, 0, 1134, 1133, 1, 0, 0, 0,
		1135, 189, 1, 0, 0, 0, 1136, 1138, 5, 128, 0, 0, 1137, 1136, 1, 0, 0, 0,
		1137, 1138, 1, 0, 0, 0, 1138, 1139, 1, 0, 0, 0, 1139, 1140, 5, 98, 0, 0,
		1140, 1142, 5, 131, 0, 0, 1141, 1143, 3, 4, 2, 0, 1142, 1141, 1, 0, 0,
		0, 1142, 1143, 1, 0, 0, 0, 1143, 1144, 1, 0, 0, 0, 1144, 1145, 3, 192,
		96, 0, 1145, 1146, 3, 194, 97, 0, 1146, 191, 1, 0, 0, 0, 1147, 1149, 3,
		196, 98, 0, 1148, 1147, 1, 0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 1151,
		1, 0, 0, 0, 1150, 1152, 3, 198, 99, 0, 1151, 1150, 1, 0, 0, 0, 1151, 1152,
		1, 0, 0, 0, 1152, 193, 1, 0, 0, 0, 1153, 1157, 5, 9, 0, 0, 1154, 1156,
		3, 200, 100, 0, 1155, 1154, 1, 0, 0, 0, 1156, 1159, 1, 0, 0, 0, 1157, 1155,
		1, 0, 0, 0, 1157, 1158, 1, 0, 0, 0, 1158, 1160, 1, 0, 0, 0, 1159, 1157,
		1, 0, 0, 0, 1160, 1161, 5, 10, 0, 0, 1161, 195, 1, 0, 0, 0, 1162, 1163,
		5, 100, 0, 0, 1163, 1164, 3, 26, 13, 0, 1164, 197, 1, 0, 0, 0, 1165, 1166,
		5, 106, 0, 0, 1166, 1167, 3, 92, 46, 0, 1167, 199, 1, 0, 0, 0, 1168, 1173,
		3, 86, 43, 0, 1169, 1173, 3, 202, 101, 0, 1170, 1173, 3, 206, 103, 0, 1171,
		1173, 3, 122, 61, 0, 1172, 1168, 1, 0, 0, 0, 1172, 1169, 1, 0, 0, 0, 1172,
		1170, 1, 0, 0, 0, 1172, 1171, 1, 0, 0, 0, 1173, 201, 1, 0, 0, 0, 1174,
		1176, 3, 204, 102, 0, 1175, 1177, 5, 24, 0, 0, 1176, 1175, 1, 0, 0, 0,
		1176, 1177, 1, 0, 0, 0, 1177, 1179, 1, 0, 0, 0, 1178, 1180, 5, 31, 0, 0,
		1179, 1178, 1, 0, 0, 0, 1179, 1180, 1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0,
		1181, 1183, 3, 244, 122, 0, 1182, 1184, 3, 58, 29, 0, 1183, 1182, 1, 0,
		0, 0, 1183, 1184, 1, 0, 0, 0, 1184, 1186, 1, 0, 0, 0, 1185, 1187, 3, 0,
		0, 0, 1186, 1185, 1, 0, 0, 0, 1186, 1187, 1, 0, 0, 0, 1187, 1188, 1, 0,
		0, 0, 1188, 1189, 5, 11, 0, 0, 1189, 1219, 1, 0, 0, 0, 1190, 1192, 3, 204,
		102, 0, 1191, 1193, 5, 24, 0, 0, 1192, 1191, 1, 0, 0, 0, 1192, 1193, 1,
		0, 0, 0, 1193, 1195, 1, 0, 0, 0, 1194, 1196, 5, 31, 0, 0, 1195, 1194, 1,
		0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196, 1197, 1, 0, 0, 0, 1197, 1198, 3,
		244, 122, 0, 1198, 1204, 3, 60, 30, 0, 1199, 1200, 5, 9, 0, 0, 1200, 1201,
		3, 226, 113, 0, 1201, 1202, 5, 10, 0, 0, 1202, 1205, 1, 0, 0, 0, 1203,
		1205, 5, 11, 0, 0, 1204, 1199, 1, 0, 0, 0, 1204, 1203, 1, 0, 0, 0, 1205,
		1219, 1, 0, 0, 0, 1206, 1208, 3, 204, 102, 0, 1207, 1209, 5, 24, 0, 0,
		1208, 1207, 1, 0, 0, 0, 1208, 1209, 1, 0, 0, 0, 1209, 1211, 1, 0, 0, 0,
		1210, 1212, 5, 31, 0, 0, 1211, 1210, 1, 0, 0, 0, 1211, 1212, 1, 0, 0, 0,
		1212, 1215, 1, 0, 0, 0, 1213, 1216, 3, 240, 120, 0, 1214, 1216, 3, 242,
		121, 0, 1215, 1213, 1, 0, 0, 0, 1215, 1214, 1, 0, 0, 0, 1216, 1219, 1,
		0, 0, 0, 1217, 1219, 3, 128, 64, 0, 1218, 1174, 1, 0, 0, 0, 1218, 1190,
		1, 0, 0, 0, 1218, 1206, 1, 0, 0, 0, 1218, 1217, 1, 0, 0, 0, 1219, 203,
		1, 0, 0, 0, 1220, 1222, 5, 97, 0, 0, 1221, 1220, 1, 0, 0, 0, 1221, 1222,
		1, 0, 0, 0, 1222, 1224, 1, 0, 0, 0, 1223, 1225, 3, 68, 34, 0, 1224, 1223,
		1, 0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1227, 1, 0, 0, 0, 1226, 1228,
		5, 113, 0, 0, 1227, 1226, 1, 0, 0, 0, 1227, 1228, 1, 0, 0, 0, 1228, 1230,
		1, 0, 0, 0, 1229, 1231, 5, 96, 0, 0, 1230, 1229, 1, 0, 0, 0, 1230, 1231,
		1, 0, 0, 0, 1231, 205, 1, 0, 0, 0, 1232, 1233, 3, 80, 40, 0, 1233, 1234,
		5, 11, 0, 0, 1234, 207, 1, 0, 0, 0, 1235, 1237, 5, 24, 0, 0, 1236, 1235,
		1, 0, 0, 0, 1236, 1237, 1, 0, 0, 0, 1237, 1238, 1, 0, 0, 0, 1238, 1239,
		5, 131, 0, 0, 1239, 1241, 5, 7, 0, 0, 1240, 1242, 3, 220, 110, 0, 1241,
		1240, 1, 0, 0, 0, 1241, 1242, 1, 0, 0, 0, 1242, 1243, 1, 0, 0, 0, 1243,
		1244, 5, 8, 0, 0, 1244, 1245, 5, 9, 0, 0, 1245, 1246, 3, 226, 113, 0, 1246,
		1247, 5, 10, 0, 0, 1247, 209, 1, 0, 0, 0, 1248, 1249, 5, 85, 0, 0, 1249,
		1251, 5, 24, 0, 0, 1250, 1252, 5, 131, 0, 0, 1251, 1250, 1, 0, 0, 0, 1251,
		1252, 1, 0, 0, 0, 1252, 1253, 1, 0, 0, 0, 1253, 1255, 5, 7, 0, 0, 1254,
		1256, 3, 220, 110, 0, 1255, 1254, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256,
		1257, 1, 0, 0, 0, 1257, 1258, 5, 8, 0, 0, 1258, 1259, 5, 9, 0, 0, 1259,
		1260, 3, 226, 113, 0, 1260, 1261, 5, 10, 0, 0, 1261, 211, 1, 0, 0, 0, 1262,
		1263, 5, 9, 0, 0, 1263, 1268, 3, 214, 107, 0, 1264, 1265, 5, 12, 0, 0,
		1265, 1267, 3, 214, 107, 0, 1266, 1264, 1, 0, 0, 0, 1267, 1270, 1, 0, 0,
		0, 1268, 1266, 1, 0, 0, 0, 1268, 1269, 1, 0, 0, 0, 1269, 1272, 1, 0, 0,
		0, 1270, 1268, 1, 0, 0, 0, 1271, 1273, 5, 12, 0, 0, 1272, 1271, 1, 0, 0,
		0, 1272, 1273, 1, 0, 0, 0, 1273, 1274, 1, 0, 0, 0, 1274, 1275, 5, 10, 0,
		0, 1275, 213, 1, 0, 0, 0, 1276, 1277, 5, 24, 0, 0, 1277, 1278, 3, 218,
		109, 0, 1278, 215, 1, 0, 0, 0, 1279, 1280, 5, 9, 0, 0, 1280, 1285, 3, 218,
		109, 0, 1281, 1282, 5, 12, 0, 0, 1282, 1284, 3, 218, 109, 0, 1283, 1281,
		1, 0, 0, 0, 1284, 1287, 1, 0, 0, 0, 1285, 1283, 1, 0, 0, 0, 1285, 1286,
		1, 0, 0, 0, 1286, 1289, 1, 0, 0, 0, 1287, 1285, 1, 0, 0, 0, 1288, 1290,
		5, 12, 0, 0, 1289, 1288, 1, 0, 0, 0, 1289, 1290, 1, 0, 0, 0, 1290, 1291,
		1, 0, 0, 0, 1291, 1292, 5, 10, 0, 0, 1292, 217, 1, 0, 0, 0, 1293, 1294,
		5, 5, 0, 0, 1294, 1295, 3, 254, 127, 0, 1295, 1296, 5, 6, 0, 0, 1296, 1298,
		5, 7, 0, 0, 1297, 1299, 3, 220, 110, 0, 1298, 1297, 1, 0, 0, 0, 1298, 1299,
		1, 0, 0, 0, 1299, 1300, 1, 0, 0, 0, 1300, 1301, 5, 8, 0, 0, 1301, 1302,
		5, 9, 0, 0, 1302, 1303, 3, 226, 113, 0, 1303, 1304, 5, 10, 0, 0, 1304,
		219, 1, 0, 0, 0, 1305, 1310, 3, 222, 111, 0, 1306, 1307, 5, 12, 0, 0, 1307,
		1309, 3, 222, 111, 0, 1308, 1306, 1, 0, 0, 0, 1309, 1312, 1, 0, 0, 0, 1310,
		1308, 1, 0, 0, 0, 1310, 1311, 1, 0, 0, 0, 1311, 1315, 1, 0, 0, 0, 1312,
		1310, 1, 0, 0, 0, 1313, 1314, 5, 12, 0, 0, 1314, 1316, 3, 224, 112, 0,
		1315, 1313, 1, 0, 0, 0, 1315, 1316, 1, 0, 0, 0, 1316, 1325, 1, 0, 0, 0,
		1317, 1325, 3, 224, 112, 0, 1318, 1325, 3, 230, 115, 0, 1319, 1322, 3,
		236, 118, 0, 1320, 1321, 5, 15, 0, 0, 1321, 1323, 3, 220, 110, 0, 1322,
		1320, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1325, 1, 0, 0, 0, 1324,
		1305, 1, 0, 0, 0, 1324, 1317, 1, 0, 0, 0, 1324, 1318, 1, 0, 0, 0, 1324,
		1319, 1, 0, 0, 0, 1325, 221, 1, 0, 0, 0, 1326, 1328, 3, 68, 34, 0, 1327,
		1326, 1, 0, 0, 0, 1327, 1328, 1, 0, 0, 0, 1328, 1329, 1, 0, 0, 0, 1329,
		1331, 5, 131, 0, 0, 1330, 1332, 3, 58, 29, 0, 1331, 1330, 1, 0, 0, 0, 1331,
		1332, 1, 0, 0, 0, 1332, 1335, 1, 0, 0, 0, 1333, 1334, 5, 13, 0, 0, 1334,
		1336, 3, 254, 127, 0, 1335, 1333, 1, 0, 0, 0, 1335, 1336, 1, 0, 0, 0, 1336,
		223, 1, 0, 0, 0, 1337, 1338, 5, 16, 0, 0, 1338, 1339, 5, 131, 0, 0, 1339,
		225, 1, 0, 0, 0, 1340, 1342, 3, 228, 114, 0, 1341, 1340, 1, 0, 0, 0, 1341,
		1342, 1, 0, 0, 0, 1342, 227, 1, 0, 0, 0, 1343, 1345, 3, 120, 60, 0, 1344,
		1343, 1, 0, 0, 0, 1345, 1346, 1, 0, 0, 0, 1346, 1344, 1, 0, 0, 0, 1346,
		1347, 1, 0, 0, 0, 1347, 229, 1, 0, 0, 0, 1348, 1350, 5, 5, 0, 0, 1349,
		1351, 3, 232, 116, 0, 1350, 1349, 1, 0, 0, 0, 1350, 1351, 1, 0, 0, 0, 1351,
		1352, 1, 0, 0, 0, 1352, 1353, 5, 6, 0, 0, 1353, 231, 1, 0, 0, 0, 1354,
		1363, 3, 254, 127, 0, 1355, 1357, 5, 12, 0, 0, 1356, 1355, 1, 0, 0, 0,
		1357, 1358, 1, 0, 0, 0, 1358, 1356, 1, 0, 0, 0, 1358, 1359, 1, 0, 0, 0,
		1359, 1360, 1, 0, 0, 0, 1360, 1362, 3, 254, 127, 0, 1361, 1356, 1, 0, 0,
		0, 1362, 1365, 1, 0, 0, 0, 1363, 1361, 1, 0, 0, 0, 1363, 1364, 1, 0, 0,
		0, 1364, 1372, 1, 0, 0, 0, 1365, 1363, 1, 0, 0, 0, 1366, 1368, 5, 12, 0,
		0, 1367, 1366, 1, 0, 0, 0, 1368, 1369, 1, 0, 0, 0, 1369, 1367, 1, 0, 0,
		0, 1369, 1370, 1, 0, 0, 0, 1370, 1371, 1, 0, 0, 0, 1371, 1373, 3, 234,
		117, 0, 1372, 1367, 1, 0, 0, 0, 1372, 1373, 1, 0, 0, 0, 1373, 1376, 1,
		0, 0, 0, 1374, 1376, 3, 234, 117, 0, 1375, 1354, 1, 0, 0, 0, 1375, 1374,
		1, 0, 0, 0, 1376, 233, 1, 0, 0, 0, 1377, 1380, 5, 16, 0, 0, 1378, 1381,
		5, 131, 0, 0, 1379, 1381, 3, 254, 127, 0, 1380, 1378, 1, 0, 0, 0, 1380,
		1379, 1, 0, 0, 0, 1381, 235, 1, 0, 0, 0, 1382, 1391, 5, 9, 0, 0, 1383,
		1388, 3, 238, 119, 0, 1384, 1385, 5, 12, 0, 0, 1385, 1387, 3, 238, 119,
		0, 1386, 1384, 1, 0, 0, 0, 1387, 1390, 1, 0, 0, 0, 1388, 1386, 1, 0, 0,
		0, 1388, 1389, 1, 0, 0, 0, 1389, 1392, 1, 0, 0, 0, 1390, 1388, 1, 0, 0,
		0, 1391, 1383, 1, 0, 0, 0, 1391, 1392, 1, 0, 0, 0, 1392, 1394, 1, 0, 0,
		0, 1393, 1395, 5, 12, 0, 0, 1394, 1393, 1, 0, 0, 0, 1394, 1395, 1, 0, 0,
		0, 1395, 1396, 1, 0, 0, 0, 1396, 1397, 5, 10, 0, 0, 1397, 237, 1, 0, 0,
		0, 1398, 1399, 3, 244, 122, 0, 1399, 1400, 7, 5, 0, 0, 1400, 1401, 3, 254,
		127, 0, 1401, 1430, 1, 0, 0, 0, 1402, 1403, 5, 5, 0, 0, 1403, 1404, 3,
		254, 127, 0, 1404, 1405, 5, 6, 0, 0, 1405, 1406, 5, 15, 0, 0, 1406, 1407,
		3, 254, 127, 0, 1407, 1430, 1, 0, 0, 0, 1408, 1410, 5, 97, 0, 0, 1409,
		1408, 1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 1412, 1, 0, 0, 0, 1411,
		1413, 5, 24, 0, 0, 1412, 1411, 1, 0, 0, 0, 1412, 1413, 1, 0, 0, 0, 1413,
		1414, 1, 0, 0, 0, 1414, 1415, 3, 244, 122, 0, 1415, 1417, 5, 7, 0, 0, 1416,
		1418, 3, 220, 110, 0, 1417, 1416, 1, 0, 0, 0, 1417, 1418, 1, 0, 0, 0, 1418,
		1419, 1, 0, 0, 0, 1419, 1420, 5, 8, 0, 0, 1420, 1421, 5, 9, 0, 0, 1421,
		1422, 3, 226, 113, 0, 1422, 1423, 5, 10, 0, 0, 1423, 1430, 1, 0, 0, 0,
		1424, 1430, 3, 240, 120, 0, 1425, 1430, 3, 242, 121, 0, 1426, 1430, 3,
		208, 104, 0, 1427, 1430, 5, 131, 0, 0, 1428, 1430, 3, 76, 38, 0, 1429,
		1398, 1, 0, 0, 0, 1429, 1402, 1, 0, 0, 0, 1429, 1409, 1, 0, 0, 0, 1429,
		1424, 1, 0, 0, 0, 1429, 1425, 1, 0, 0, 0, 1429, 1426, 1, 0, 0, 0, 1429,
		1427, 1, 0, 0, 0, 1429, 1428, 1, 0, 0, 0, 1430, 239, 1, 0, 0, 0, 1431,
		1432, 3, 274, 137, 0, 1432, 1433, 5, 7, 0, 0, 1433, 1435, 5, 8, 0, 0, 1434,
		1436, 3, 58, 29, 0, 1435, 1434, 1, 0, 0, 0, 1435, 1436, 1, 0, 0, 0, 1436,
		1437, 1, 0, 0, 0, 1437, 1438, 5, 9, 0, 0, 1438, 1439, 3, 226, 113, 0, 1439,
		1440, 5, 10, 0, 0, 1440, 241, 1, 0, 0, 0, 1441, 1442, 3, 276, 138, 0, 1442,
		1445, 5, 7, 0, 0, 1443, 1446, 5, 131, 0, 0, 1444, 1446, 3, 2, 1, 0, 1445,
		1443, 1, 0, 0, 0, 1445, 1444, 1, 0, 0, 0, 1446, 1448, 1, 0, 0, 0, 1447,
		1449, 3, 58, 29, 0, 1448, 1447, 1, 0, 0, 0, 1448, 1449, 1, 0, 0, 0, 1449,
		1450, 1, 0, 0, 0, 1450, 1451, 5, 8, 0, 0, 1451, 1452, 5, 9, 0, 0, 1452,
		1453, 3, 226, 113, 0, 1453, 1454, 5, 10, 0, 0, 1454, 243, 1, 0, 0, 0, 1455,
		1463, 3, 268, 134, 0, 1456, 1463, 5, 132, 0, 0, 1457, 1463, 3, 266, 133,
		0, 1458, 1459, 5, 5, 0, 0, 1459, 1460, 3, 254, 127, 0, 1460, 1461, 5, 6,
		0, 0, 1461, 1463, 1, 0, 0, 0, 1462, 1455, 1, 0, 0, 0, 1462, 1456, 1, 0,
		0, 0, 1462, 1457, 1, 0, 0, 0, 1462, 1458, 1, 0, 0, 0, 1463, 245, 1, 0,
		0, 0, 1464, 1478, 5, 7, 0, 0, 1465, 1470, 3, 254, 127, 0, 1466, 1467, 5,
		12, 0, 0, 1467, 1469, 3, 254, 127, 0, 1468, 1466, 1, 0, 0, 0, 1469, 1472,
		1, 0, 0, 0, 1470, 1468, 1, 0, 0, 0, 1470, 1471, 1, 0, 0, 0, 1471, 1475,
		1, 0, 0, 0, 1472, 1470, 1, 0, 0, 0, 1473, 1474, 5, 12, 0, 0, 1474, 1476,
		3, 248, 124, 0, 1475, 1473, 1, 0, 0, 0, 1475, 1476, 1, 0, 0, 0, 1476, 1479,
		1, 0, 0, 0, 1477, 1479, 3, 248, 124, 0, 1478, 1465, 1, 0, 0, 0, 1478, 1477,
		1, 0, 0, 0, 1478, 1479, 1, 0, 0, 0, 1479, 1480, 1, 0, 0, 0, 1480, 1481,
		5, 8, 0, 0, 1481, 247, 1, 0, 0, 0, 1482, 1483, 5, 16, 0, 0, 1483, 1484,
		5, 131, 0, 0, 1484, 249, 1, 0, 0, 0, 1485, 1490, 3, 254, 127, 0, 1486,
		1487, 5, 12, 0, 0, 1487, 1489, 3, 254, 127, 0, 1488, 1486, 1, 0, 0, 0,
		1489, 1492, 1, 0, 0, 0, 1490, 1488, 1, 0, 0, 0, 1490, 1491, 1, 0, 0, 0,
		1491, 1494, 1, 0, 0, 0, 1492, 1490, 1, 0, 0, 0, 1493, 1495, 5, 12, 0, 0,
		1494, 1493, 1, 0, 0, 0, 1494, 1495, 1, 0, 0, 0, 1495, 251, 1, 0, 0, 0,
		1496, 1498, 5, 97, 0, 0, 1497, 1496, 1, 0, 0, 0, 1497, 1498, 1, 0, 0, 0,
		1498, 1499, 1, 0, 0, 0, 1499, 1501, 5, 85, 0, 0, 1500, 1502, 5, 131, 0,
		0, 1501, 1500, 1, 0, 0, 0, 1501, 1502, 1, 0, 0, 0, 1502, 1503, 1, 0, 0,
		0, 1503, 1505, 5, 7, 0, 0, 1504, 1506, 3, 220, 110, 0, 1505, 1504, 1, 0,
		0, 0, 1505, 1506, 1, 0, 0, 0, 1506, 1507, 1, 0, 0, 0, 1507, 1509, 5, 8,
		0, 0, 1508, 1510, 3, 58, 29, 0, 1509, 1508, 1, 0, 0, 0, 1509, 1510, 1,
		0, 0, 0, 1510, 1511, 1, 0, 0, 0, 1511, 1512, 5, 9, 0, 0, 1512, 1513, 3,
		226, 113, 0, 1513, 1514, 5, 10, 0, 0, 1514, 253, 1, 0, 0, 0, 1515, 1516,
		6, 127, -1, 0, 1516, 1573, 3, 252, 126, 0, 1517, 1573, 3, 256, 128, 0,
		1518, 1520, 5, 98, 0, 0, 1519, 1521, 5, 131, 0, 0, 1520, 1519, 1, 0, 0,
		0, 1520, 1521, 1, 0, 0, 0, 1521, 1522, 1, 0, 0, 0, 1522, 1573, 3, 194,
		97, 0, 1523, 1524, 5, 74, 0, 0, 1524, 1526, 3, 254, 127, 0, 1525, 1527,
		3, 12, 6, 0, 1526, 1525, 1, 0, 0, 0, 1526, 1527, 1, 0, 0, 0, 1527, 1529,
		1, 0, 0, 0, 1528, 1530, 3, 246, 123, 0, 1529, 1528, 1, 0, 0, 0, 1529, 1530,
		1, 0, 0, 0, 1530, 1573, 1, 0, 0, 0, 1531, 1532, 5, 91, 0, 0, 1532, 1573,
		3, 254, 127, 40, 1533, 1534, 5, 79, 0, 0, 1534, 1573, 3, 254, 127, 39,
		1535, 1536, 5, 71, 0, 0, 1536, 1573, 3, 254, 127, 38, 1537, 1538, 5, 18,
		0, 0, 1538, 1573, 3, 254, 127, 37, 1539, 1540, 5, 19, 0, 0, 1540, 1573,
		3, 254, 127, 36, 1541, 1542, 5, 20, 0, 0, 1542, 1573, 3, 254, 127, 35,
		1543, 1544, 5, 21, 0, 0, 1544, 1573, 3, 254, 127, 34, 1545, 1546, 5, 22,
		0, 0, 1546, 1573, 3, 254, 127, 33, 1547, 1548, 5, 23, 0, 0, 1548, 1573,
		3, 254, 127, 32, 1549, 1550, 5, 105, 0, 0, 1550, 1573, 3, 254, 127, 31,
		1551, 1573, 3, 216, 108, 0, 1552, 1573, 3, 212, 106, 0, 1553, 1573, 3,
		210, 105, 0, 1554, 1573, 3, 160, 80, 0, 1555, 1573, 5, 86, 0, 0, 1556,
		1558, 3, 268, 134, 0, 1557, 1559, 3, 254, 127, 0, 1558, 1557, 1, 0, 0,
		0, 1558, 1559, 1, 0, 0, 0, 1559, 1573, 1, 0, 0, 0, 1560, 1573, 5, 101,
		0, 0, 1561, 1573, 3, 264, 132, 0, 1562, 1573, 3, 230, 115, 0, 1563, 1573,
		3, 236, 118, 0, 1564, 1565, 5, 7, 0, 0, 1565, 1566, 3, 250, 125, 0, 1566,
		1567, 5, 8, 0, 0, 1567, 1573, 1, 0, 0, 0, 1568, 1570, 3, 12, 6, 0, 1569,
		1571, 3, 250, 125, 0, 1570, 1569, 1, 0, 0, 0, 1570, 1571, 1, 0, 0, 0, 1571,
		1573, 1, 0, 0, 0, 1572, 1515, 1, 0, 0, 0, 1572, 1517, 1, 0, 0, 0, 1572,
		1518, 1, 0, 0, 0, 1572, 1523, 1, 0, 0, 0, 1572, 1531, 1, 0, 0, 0, 1572,
		1533, 1, 0, 0, 0, 1572, 1535, 1, 0, 0, 0, 1572, 1537, 1, 0, 0, 0, 1572,
		1539, 1, 0, 0, 0, 1572, 1541, 1, 0, 0, 0, 1572, 1543, 1, 0, 0, 0, 1572,
		1545, 1, 0, 0, 0, 1572, 1547, 1, 0, 0, 0, 1572, 1549, 1, 0, 0, 0, 1572,
		1551, 1, 0, 0, 0, 1572, 1552, 1, 0, 0, 0, 1572, 1553, 1, 0, 0, 0, 1572,
		1554, 1, 0, 0, 0, 1572, 1555, 1, 0, 0, 0, 1572, 1556, 1, 0, 0, 0, 1572,
		1560, 1, 0, 0, 0, 1572, 1561, 1, 0, 0, 0, 1572, 1562, 1, 0, 0, 0, 1572,
		1563, 1, 0, 0, 0, 1572, 1564, 1, 0, 0, 0, 1572, 1568, 1, 0, 0, 0, 1573,
		1655, 1, 0, 0, 0, 1574, 1575, 10, 30, 0, 0, 1575, 1576, 5, 29, 0, 0, 1576,
		1654, 3, 254, 127, 30, 1577, 1578, 10, 29, 0, 0, 1578, 1579, 7, 6, 0, 0,
		1579, 1654, 3, 254, 127, 30, 1580, 1581, 10, 28, 0, 0, 1581, 1582, 7, 7,
		0, 0, 1582, 1654, 3, 254, 127, 29, 1583, 1584, 10, 27, 0, 0, 1584, 1585,
		7, 8, 0, 0, 1585, 1654, 3, 254, 127, 28, 1586, 1587, 10, 26, 0, 0, 1587,
		1588, 7, 9, 0, 0, 1588, 1654, 3, 254, 127, 27, 1589, 1590, 10, 25, 0, 0,
		1590, 1591, 5, 70, 0, 0, 1591, 1654, 3, 254, 127, 26, 1592, 1593, 10, 24,
		0, 0, 1593, 1594, 5, 92, 0, 0, 1594, 1654, 3, 254, 127, 25, 1595, 1596,
		10, 23, 0, 0, 1596, 1597, 7, 10, 0, 0, 1597, 1654, 3, 254, 127, 24, 1598,
		1599, 10, 22, 0, 0, 1599, 1600, 5, 43, 0, 0, 1600, 1654, 3, 254, 127, 23,
		1601, 1602, 10, 21, 0, 0, 1602, 1603, 5, 44, 0, 0, 1603, 1654, 3, 254,
		127, 22, 1604, 1605, 10, 20, 0, 0, 1605, 1606, 5, 45, 0, 0, 1606, 1654,
		3, 254, 127, 21, 1607, 1608, 10, 19, 0, 0, 1608, 1609, 5, 46, 0, 0, 1609,
		1654, 3, 254, 127, 20, 1610, 1611, 10, 18, 0, 0, 1611, 1612, 5, 47, 0,
		0, 1612, 1654, 3, 254, 127, 19, 1613, 1614, 10, 17, 0, 0, 1614, 1615, 5,
		14, 0, 0, 1615, 1616, 3, 254, 127, 0, 1616, 1617, 5, 15, 0, 0, 1617, 1618,
		3, 254, 127, 18, 1618, 1654, 1, 0, 0, 0, 1619, 1620, 10, 16, 0, 0, 1620,
		1621, 5, 30, 0, 0, 1621, 1654, 3, 254, 127, 17, 1622, 1623, 10, 15, 0,
		0, 1623, 1624, 5, 13, 0, 0, 1624, 1654, 3, 254, 127, 15, 1625, 1626, 10,
		14, 0, 0, 1626, 1627, 3, 262, 131, 0, 1627, 1628, 3, 254, 127, 14, 1628,
		1654, 1, 0, 0, 0, 1629, 1630, 10, 46, 0, 0, 1630, 1631, 5, 5, 0, 0, 1631,
		1632, 3, 250, 125, 0, 1632, 1633, 5, 6, 0, 0, 1633, 1654, 1, 0, 0, 0, 1634,
		1636, 10, 45, 0, 0, 1635, 1637, 5, 14, 0, 0, 1636, 1635, 1, 0, 0, 0, 1636,
		1637, 1, 0, 0, 0, 1637, 1638, 1, 0, 0, 0, 1638, 1640, 5, 17, 0, 0, 1639,
		1641, 5, 31, 0, 0, 1640, 1639, 1, 0, 0, 0, 1640, 1641, 1, 0, 0, 0, 1641,
		1642, 1, 0, 0, 0, 1642, 1654, 3, 268, 134, 0, 1643, 1644, 10, 44, 0, 0,
		1644, 1654, 3, 246, 123, 0, 1645, 1646, 10, 42, 0, 0, 1646, 1647, 4, 127,
		35, 0, 1647, 1654, 5, 18, 0, 0, 1648, 1649, 10, 41, 0, 0, 1649, 1650, 4,
		127, 37, 0, 1650, 1654, 5, 19, 0, 0, 1651, 1652, 10, 13, 0, 0, 1652, 1654,
		5, 133, 0, 0, 1653, 1574, 1, 0, 0, 0, 1653, 1577, 1, 0, 0, 0, 1653, 1580,
		1, 0, 0, 0, 1653, 1583, 1, 0, 0, 0, 1653, 1586, 1, 0, 0, 0, 1653, 1589,
		1, 0, 0, 0, 1653, 1592, 1, 0, 0, 0, 1653, 1595, 1, 0, 0, 0, 1653, 1598,
		1, 0, 0, 0, 1653, 1601, 1, 0, 0, 0, 1653, 1604, 1, 0, 0, 0, 1653, 1607,
		1, 0, 0, 0, 1653, 1610, 1, 0, 0, 0, 1653, 1613, 1, 0, 0, 0, 1653, 1619,
		1, 0, 0, 0, 1653, 1622, 1, 0, 0, 0, 1653, 1625, 1, 0, 0, 0, 1653, 1629,
		1, 0, 0, 0, 1653, 1634, 1, 0, 0, 0, 1653, 1643, 1, 0, 0, 0, 1653, 1645,
		1, 0, 0, 0, 1653, 1648, 1, 0, 0, 0, 1653, 1651, 1, 0, 0, 0, 1654, 1657,
		1, 0, 0, 0, 1655, 1653, 1, 0, 0, 0, 1655, 1656, 1, 0, 0, 0, 1656, 255,
		1, 0, 0, 0, 1657, 1655, 1, 0, 0, 0, 1658, 1660, 5, 97, 0, 0, 1659, 1658,
		1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661, 1663,
		3, 258, 129, 0, 1662, 1664, 3, 58, 29, 0, 1663, 1662, 1, 0, 0, 0, 1663,
		1664, 1, 0, 0, 0, 1664, 1665, 1, 0, 0, 0, 1665, 1666, 5, 59, 0, 0, 1666,
		1667, 3, 260, 130, 0, 1667, 257, 1, 0, 0, 0, 1668, 1675, 5, 131, 0, 0,
		1669, 1671, 5, 7, 0, 0, 1670, 1672, 3, 220, 110, 0, 1671, 1670, 1, 0, 0,
		0, 1671, 1672, 1, 0, 0, 0, 1672, 1673, 1, 0, 0, 0, 1673, 1675, 5, 8, 0,
		0, 1674, 1668, 1, 0, 0, 0, 1674, 1669, 1, 0, 0, 0, 1675, 259, 1, 0, 0,
		0, 1676, 1682, 3, 254, 127, 0, 1677, 1678, 5, 9, 0, 0, 1678, 1679, 3, 226,
		113, 0, 1679, 1680, 5, 10, 0, 0, 1680, 1682, 1, 0, 0, 0, 1681, 1676, 1,
		0, 0, 0, 1681, 1677, 1, 0, 0, 0, 1682, 261, 1, 0, 0, 0, 1683, 1684, 7,
		11, 0, 0, 1684, 263, 1, 0, 0, 0, 1685, 1692, 5, 61, 0, 0, 1686, 1692, 5,
		62, 0, 0, 1687, 1692, 5, 132, 0, 0, 1688, 1692, 5, 133, 0, 0, 1689, 1692,
		5, 4, 0, 0, 1690, 1692, 3, 266, 133, 0, 1691, 1685, 1, 0, 0, 0, 1691, 1686,
		1, 0, 0, 0, 1691, 1687, 1, 0, 0, 0, 1691, 1688, 1, 0, 0, 0, 1691, 1689,
		1, 0, 0, 0, 1691, 1690, 1, 0, 0, 0, 1692, 265, 1, 0, 0, 0, 1693, 1694,
		7, 12, 0, 0, 1694, 267, 1, 0, 0, 0, 1695, 1698, 5, 131, 0, 0, 1696, 1698,
		3, 270, 135, 0, 1697, 1695, 1, 0, 0, 0, 1697, 1696, 1, 0, 0, 0, 1698, 269,
		1, 0, 0, 0, 1699, 1703, 3, 272, 136, 0, 1700, 1703, 5, 61, 0, 0, 1701,
		1703, 5, 62, 0, 0, 1702, 1699, 1, 0, 0, 0, 1702, 1700, 1, 0, 0, 0, 1702,
		1701, 1, 0, 0, 0, 1703, 271, 1, 0, 0, 0, 1704, 1705, 7, 13, 0, 0, 1705,
		273, 1, 0, 0, 0, 1706, 1707, 5, 131, 0, 0, 1707, 1708, 4, 137, 39, 0, 1708,
		1709, 3, 244, 122, 0, 1709, 275, 1, 0, 0, 0, 1710, 1711, 5, 131, 0, 0,
		1711, 1712, 4, 138, 40, 0, 1712, 1713, 3, 244, 122, 0, 1713, 277, 1, 0,
		0, 0, 1714, 1719, 5, 11, 0, 0, 1715, 1719, 5, 0, 0, 1, 1716, 1719, 4, 139,
		41, 0, 1717, 1719, 4, 139, 42, 0, 1718, 1714, 1, 0, 0, 0, 1718, 1715, 1,
		0, 0, 0, 1718, 1716, 1, 0, 0, 0, 1718, 1717, 1, 0, 0, 0, 1719, 279, 1,
		0, 0, 0, 218, 285, 289, 298, 303, 306, 313, 322, 332, 343, 345, 366, 374,
		382, 397, 401, 405, 411, 418, 428, 430, 446, 450, 454, 462, 466, 481, 485,
		488, 492, 495, 499, 505, 509, 513, 521, 527, 534, 537, 539, 541, 548, 552,
		555, 559, 565, 572, 576, 579, 584, 587, 590, 596, 600, 604, 608, 619, 626,
		633, 638, 646, 649, 654, 657, 661, 671, 675, 681, 687, 694, 700, 706, 714,
		719, 734, 741, 746, 754, 761, 768, 773, 806, 810, 817, 823, 831, 840, 844,
		852, 860, 867, 871, 875, 879, 882, 885, 888, 892, 894, 901, 906, 909, 913,
		916, 923, 932, 951, 955, 959, 969, 973, 980, 987, 995, 1003, 1009, 1016,
		1023, 1030, 1037, 1055, 1059, 1061, 1068, 1074, 1079, 1094, 1097, 1102,
		1105, 1112, 1121, 1125, 1134, 1137, 1142, 1148, 1151, 1157, 1172, 1176,
		1179, 1183, 1186, 1192, 1195, 1204, 1208, 1211, 1215, 1218, 1221, 1224,
		1227, 1230, 1236, 1241, 1251, 1255, 1268, 1272, 1285, 1289, 1298, 1310,
		1315, 1322, 1324, 1327, 1331, 1335, 1341, 1346, 1350, 1358, 1363, 1369,
		1372, 1375, 1380, 1388, 1391, 1394, 1409, 1412, 1417, 1429, 1435, 1445,
		1448, 1462, 1470, 1475, 1478, 1490, 1494, 1497, 1501, 1505, 1509, 1520,
		1526, 1529, 1558, 1570, 1572, 1636, 1640, 1653, 1655, 1659, 1663, 1671,
		1674, 1681, 1691, 1697, 1702, 1718,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// TypeScriptParserInit initializes any static state used to implement TypeScriptParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewTypeScriptParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func TypeScriptParserInit() {
	staticData := &typescriptparserParserStaticData
	staticData.once.Do(typescriptparserParserInit)
}

// NewTypeScriptParser produces a new parser instance for the optional input antlr.TokenStream.
func NewTypeScriptParser(input antlr.TokenStream) *TypeScriptParser {
	TypeScriptParserInit()
	this := new(TypeScriptParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &typescriptparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// TypeScriptParser tokens.
const (
	TypeScriptParserEOF                        = antlr.TokenEOF
	TypeScriptParserHashBangLine               = 1
	TypeScriptParserMultiLineComment           = 2
	TypeScriptParserSingleLineComment          = 3
	TypeScriptParserRegularExpressionLiteral   = 4
	TypeScriptParserOpenBracket                = 5
	TypeScriptParserCloseBracket               = 6
	TypeScriptParserOpenParen                  = 7
	TypeScriptParserCloseParen                 = 8
	TypeScriptParserOpenBrace                  = 9
	TypeScriptParserCloseBrace                 = 10
	TypeScriptParserSemiColon                  = 11
	TypeScriptParserComma                      = 12
	TypeScriptParserAssign                     = 13
	TypeScriptParserQuestionMark               = 14
	TypeScriptParserColon                      = 15
	TypeScriptParserEllipsis                   = 16
	TypeScriptParserDot                        = 17
	TypeScriptParserPlusPlus                   = 18
	TypeScriptParserMinusMinus                 = 19
	TypeScriptParserPlus                       = 20
	TypeScriptParserMinus                      = 21
	TypeScriptParserBitNot                     = 22
	TypeScriptParserNot                        = 23
	TypeScriptParserMultiply                   = 24
	TypeScriptParserLodash                     = 25
	TypeScriptParserDollar                     = 26
	TypeScriptParserDivide                     = 27
	TypeScriptParserModulus                    = 28
	TypeScriptParserPower                      = 29
	TypeScriptParserNullCoalesce               = 30
	TypeScriptParserHashtag                    = 31
	TypeScriptParserRightShiftArithmetic       = 32
	TypeScriptParserLeftShiftArithmetic        = 33
	TypeScriptParserRightShiftLogical          = 34
	TypeScriptParserLessThan                   = 35
	TypeScriptParserMoreThan                   = 36
	TypeScriptParserLessThanEquals             = 37
	TypeScriptParserGreaterThanEquals          = 38
	TypeScriptParserEquals_                    = 39
	TypeScriptParserNotEquals                  = 40
	TypeScriptParserIdentityEquals             = 41
	TypeScriptParserIdentityNotEquals          = 42
	TypeScriptParserBitAnd                     = 43
	TypeScriptParserBitXOr                     = 44
	TypeScriptParserBitOr                      = 45
	TypeScriptParserAnd                        = 46
	TypeScriptParserOr                         = 47
	TypeScriptParserMultiplyAssign             = 48
	TypeScriptParserDivideAssign               = 49
	TypeScriptParserModulusAssign              = 50
	TypeScriptParserPlusAssign                 = 51
	TypeScriptParserMinusAssign                = 52
	TypeScriptParserLeftShiftArithmeticAssign  = 53
	TypeScriptParserRightShiftArithmeticAssign = 54
	TypeScriptParserRightShiftLogicalAssign    = 55
	TypeScriptParserBitAndAssign               = 56
	TypeScriptParserBitXorAssign               = 57
	TypeScriptParserBitOrAssign                = 58
	TypeScriptParserARROW                      = 59
	TypeScriptParserPowerAssign                = 60
	TypeScriptParserNullLiteral                = 61
	TypeScriptParserBooleanLiteral             = 62
	TypeScriptParserDecimalLiteral             = 63
	TypeScriptParserHexIntegerLiteral          = 64
	TypeScriptParserOctalIntegerLiteral        = 65
	TypeScriptParserOctalIntegerLiteral2       = 66
	TypeScriptParserBinaryIntegerLiteral       = 67
	TypeScriptParserBreak                      = 68
	TypeScriptParserDo                         = 69
	TypeScriptParserInstanceof                 = 70
	TypeScriptParserTypeof                     = 71
	TypeScriptParserCase                       = 72
	TypeScriptParserElse                       = 73
	TypeScriptParserNew                        = 74
	TypeScriptParserVar                        = 75
	TypeScriptParserCatch                      = 76
	TypeScriptParserFinally                    = 77
	TypeScriptParserReturn                     = 78
	TypeScriptParserVoid                       = 79
	TypeScriptParserContinue                   = 80
	TypeScriptParserFor                        = 81
	TypeScriptParserSwitch                     = 82
	TypeScriptParserWhile                      = 83
	TypeScriptParserDebugger                   = 84
	TypeScriptParserFunction                   = 85
	TypeScriptParserThis                       = 86
	TypeScriptParserWith                       = 87
	TypeScriptParserDefault                    = 88
	TypeScriptParserIf                         = 89
	TypeScriptParserThrow                      = 90
	TypeScriptParserDelete                     = 91
	TypeScriptParserIn                         = 92
	TypeScriptParserTry                        = 93
	TypeScriptParserAs                         = 94
	TypeScriptParserFrom                       = 95
	TypeScriptParserReadOnly                   = 96
	TypeScriptParserAsync                      = 97
	TypeScriptParserClass                      = 98
	TypeScriptParserEnum                       = 99
	TypeScriptParserExtends                    = 100
	TypeScriptParserSuper                      = 101
	TypeScriptParserConst                      = 102
	TypeScriptParserExport                     = 103
	TypeScriptParserImport                     = 104
	TypeScriptParserAwait                      = 105
	TypeScriptParserImplements                 = 106
	TypeScriptParserLet                        = 107
	TypeScriptParserPrivate                    = 108
	TypeScriptParserPublic                     = 109
	TypeScriptParserInterface                  = 110
	TypeScriptParserPackage                    = 111
	TypeScriptParserProtected                  = 112
	TypeScriptParserStatic                     = 113
	TypeScriptParserYield                      = 114
	TypeScriptParserANY                        = 115
	TypeScriptParserNUMBER                     = 116
	TypeScriptParserBOOLEAN                    = 117
	TypeScriptParserSTRING                     = 118
	TypeScriptParserSYMBOL                     = 119
	TypeScriptParserType                       = 120
	TypeScriptParserGet                        = 121
	TypeScriptParserSet                        = 122
	TypeScriptParserConstructor                = 123
	TypeScriptParserNamespace                  = 124
	TypeScriptParserRequire                    = 125
	TypeScriptParserModule                     = 126
	TypeScriptParserDeclare                    = 127
	TypeScriptParserAbstract                   = 128
	TypeScriptParserIs                         = 129
	TypeScriptParserAt                         = 130
	TypeScriptParserIdentifier                 = 131
	TypeScriptParserStringLiteral              = 132
	TypeScriptParserTemplateStringLiteral      = 133
	TypeScriptParserWhiteSpaces                = 134
	TypeScriptParserLineTerminator             = 135
	TypeScriptParserHtmlComment                = 136
	TypeScriptParserCDataComment               = 137
	TypeScriptParserUnexpectedCharacter        = 138
)

// TypeScriptParser rules.
const (
	TypeScriptParserRULE_initializer                      = 0
	TypeScriptParserRULE_bindingPattern                   = 1
	TypeScriptParserRULE_typeParameters                   = 2
	TypeScriptParserRULE_typeParameterList                = 3
	TypeScriptParserRULE_typeParameter                    = 4
	TypeScriptParserRULE_constraint                       = 5
	TypeScriptParserRULE_typeArguments                    = 6
	TypeScriptParserRULE_typeArgumentList                 = 7
	TypeScriptParserRULE_typeArgument                     = 8
	TypeScriptParserRULE_type_                            = 9
	TypeScriptParserRULE_unionOrIntersectionOrPrimaryType = 10
	TypeScriptParserRULE_primaryType                      = 11
	TypeScriptParserRULE_predefinedType                   = 12
	TypeScriptParserRULE_typeReference                    = 13
	TypeScriptParserRULE_typeGeneric                      = 14
	TypeScriptParserRULE_typeIncludeGeneric               = 15
	TypeScriptParserRULE_typeName                         = 16
	TypeScriptParserRULE_objectType                       = 17
	TypeScriptParserRULE_typeBody                         = 18
	TypeScriptParserRULE_typeMemberList                   = 19
	TypeScriptParserRULE_typeMember                       = 20
	TypeScriptParserRULE_arrayType                        = 21
	TypeScriptParserRULE_tupleType                        = 22
	TypeScriptParserRULE_tupleElementTypes                = 23
	TypeScriptParserRULE_functionType                     = 24
	TypeScriptParserRULE_constructorType                  = 25
	TypeScriptParserRULE_typeQuery                        = 26
	TypeScriptParserRULE_typeQueryExpression              = 27
	TypeScriptParserRULE_propertySignature                = 28
	TypeScriptParserRULE_typeAnnotation                   = 29
	TypeScriptParserRULE_callSignature                    = 30
	TypeScriptParserRULE_parameterList                    = 31
	TypeScriptParserRULE_requiredParameterList            = 32
	TypeScriptParserRULE_requiredParameter                = 33
	TypeScriptParserRULE_accessibilityModifier            = 34
	TypeScriptParserRULE_identifierOrPattern              = 35
	TypeScriptParserRULE_optionalParameterList            = 36
	TypeScriptParserRULE_optionalParameter                = 37
	TypeScriptParserRULE_restParameter                    = 38
	TypeScriptParserRULE_constructSignature               = 39
	TypeScriptParserRULE_indexSignature                   = 40
	TypeScriptParserRULE_methodSignature                  = 41
	TypeScriptParserRULE_typeAliasDeclaration             = 42
	TypeScriptParserRULE_constructorDeclaration           = 43
	TypeScriptParserRULE_interfaceDeclaration             = 44
	TypeScriptParserRULE_interfaceExtendsClause           = 45
	TypeScriptParserRULE_classOrInterfaceTypeList         = 46
	TypeScriptParserRULE_enumDeclaration                  = 47
	TypeScriptParserRULE_enumBody                         = 48
	TypeScriptParserRULE_enumMemberList                   = 49
	TypeScriptParserRULE_enumMember                       = 50
	TypeScriptParserRULE_namespaceDeclaration             = 51
	TypeScriptParserRULE_namespaceName                    = 52
	TypeScriptParserRULE_importAliasDeclaration           = 53
	TypeScriptParserRULE_importAll                        = 54
	TypeScriptParserRULE_decoratorList                    = 55
	TypeScriptParserRULE_decorator                        = 56
	TypeScriptParserRULE_decoratorMemberExpression        = 57
	TypeScriptParserRULE_decoratorCallExpression          = 58
	TypeScriptParserRULE_program                          = 59
	TypeScriptParserRULE_sourceElement                    = 60
	TypeScriptParserRULE_statement                        = 61
	TypeScriptParserRULE_block                            = 62
	TypeScriptParserRULE_statementList                    = 63
	TypeScriptParserRULE_abstractDeclaration              = 64
	TypeScriptParserRULE_importStatement                  = 65
	TypeScriptParserRULE_importFromBlock                  = 66
	TypeScriptParserRULE_multipleImportStatement          = 67
	TypeScriptParserRULE_exportStatement                  = 68
	TypeScriptParserRULE_variableStatement                = 69
	TypeScriptParserRULE_variableDeclarationList          = 70
	TypeScriptParserRULE_variableDeclaration              = 71
	TypeScriptParserRULE_emptyStatement_                  = 72
	TypeScriptParserRULE_expressionStatement              = 73
	TypeScriptParserRULE_ifStatement                      = 74
	TypeScriptParserRULE_iterationStatement               = 75
	TypeScriptParserRULE_varModifier                      = 76
	TypeScriptParserRULE_continueStatement                = 77
	TypeScriptParserRULE_breakStatement                   = 78
	TypeScriptParserRULE_returnStatement                  = 79
	TypeScriptParserRULE_yieldStatement                   = 80
	TypeScriptParserRULE_withStatement                    = 81
	TypeScriptParserRULE_switchStatement                  = 82
	TypeScriptParserRULE_caseBlock                        = 83
	TypeScriptParserRULE_caseClauses                      = 84
	TypeScriptParserRULE_caseClause                       = 85
	TypeScriptParserRULE_defaultClause                    = 86
	TypeScriptParserRULE_labelledStatement                = 87
	TypeScriptParserRULE_throwStatement                   = 88
	TypeScriptParserRULE_tryStatement                     = 89
	TypeScriptParserRULE_catchProduction                  = 90
	TypeScriptParserRULE_assignable                       = 91
	TypeScriptParserRULE_finallyProduction                = 92
	TypeScriptParserRULE_debuggerStatement                = 93
	TypeScriptParserRULE_functionDeclaration              = 94
	TypeScriptParserRULE_classDeclaration                 = 95
	TypeScriptParserRULE_classHeritage                    = 96
	TypeScriptParserRULE_classTail                        = 97
	TypeScriptParserRULE_classExtendsClause               = 98
	TypeScriptParserRULE_implementsClause                 = 99
	TypeScriptParserRULE_classElement                     = 100
	TypeScriptParserRULE_propertyMemberDeclaration        = 101
	TypeScriptParserRULE_propertyMemberBase               = 102
	TypeScriptParserRULE_indexMemberDeclaration           = 103
	TypeScriptParserRULE_generatorMethod                  = 104
	TypeScriptParserRULE_generatorFunctionDeclaration     = 105
	TypeScriptParserRULE_generatorBlock                   = 106
	TypeScriptParserRULE_generatorDefinition              = 107
	TypeScriptParserRULE_iteratorBlock                    = 108
	TypeScriptParserRULE_iteratorDefinition               = 109
	TypeScriptParserRULE_formalParameterList              = 110
	TypeScriptParserRULE_formalParameterArg               = 111
	TypeScriptParserRULE_lastFormalParameterArg           = 112
	TypeScriptParserRULE_functionBody                     = 113
	TypeScriptParserRULE_sourceElements                   = 114
	TypeScriptParserRULE_arrayLiteral                     = 115
	TypeScriptParserRULE_elementList                      = 116
	TypeScriptParserRULE_lastElement                      = 117
	TypeScriptParserRULE_objectLiteral                    = 118
	TypeScriptParserRULE_propertyAssignment               = 119
	TypeScriptParserRULE_getAccessor                      = 120
	TypeScriptParserRULE_setAccessor                      = 121
	TypeScriptParserRULE_propertyName                     = 122
	TypeScriptParserRULE_arguments                        = 123
	TypeScriptParserRULE_lastArgument                     = 124
	TypeScriptParserRULE_expressionSequence               = 125
	TypeScriptParserRULE_functionExpressionDeclaration    = 126
	TypeScriptParserRULE_singleExpression                 = 127
	TypeScriptParserRULE_arrowFunctionDeclaration         = 128
	TypeScriptParserRULE_arrowFunctionParameters          = 129
	TypeScriptParserRULE_arrowFunctionBody                = 130
	TypeScriptParserRULE_assignmentOperator               = 131
	TypeScriptParserRULE_literal                          = 132
	TypeScriptParserRULE_numericLiteral                   = 133
	TypeScriptParserRULE_identifierName                   = 134
	TypeScriptParserRULE_reservedWord                     = 135
	TypeScriptParserRULE_keyword                          = 136
	TypeScriptParserRULE_getter                           = 137
	TypeScriptParserRULE_setter                           = 138
	TypeScriptParserRULE_eos                              = 139
)

// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_initializer
	return p
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *InitializerContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterInitializer(s)
	}
}

func (s *InitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitInitializer(s)
	}
}

func (p *TypeScriptParser) Initializer() (localctx IInitializerContext) {
	this := p
	_ = this

	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, TypeScriptParserRULE_initializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(280)
		p.Match(TypeScriptParserAssign)
	}
	{
		p.SetState(281)
		p.singleExpression(0)
	}

	return localctx
}

// IBindingPatternContext is an interface to support dynamic dispatch.
type IBindingPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBindingPatternContext differentiates from other interfaces.
	IsBindingPatternContext()
}

type BindingPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingPatternContext() *BindingPatternContext {
	var p = new(BindingPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_bindingPattern
	return p
}

func (*BindingPatternContext) IsBindingPatternContext() {}

func NewBindingPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingPatternContext {
	var p = new(BindingPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_bindingPattern

	return p
}

func (s *BindingPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingPatternContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *BindingPatternContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *BindingPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBindingPattern(s)
	}
}

func (s *BindingPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBindingPattern(s)
	}
}

func (p *TypeScriptParser) BindingPattern() (localctx IBindingPatternContext) {
	this := p
	_ = this

	localctx = NewBindingPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, TypeScriptParserRULE_bindingPattern)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(285)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserOpenBracket:
		{
			p.SetState(283)
			p.ArrayLiteral()
		}

	case TypeScriptParserOpenBrace:
		{
			p.SetState(284)
			p.ObjectLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeParameters
	return p
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LessThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThan, 0)
}

func (s *TypeParametersContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMoreThan, 0)
}

func (s *TypeParametersContext) TypeParameterList() ITypeParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListContext)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (p *TypeScriptParser) TypeParameters() (localctx ITypeParametersContext) {
	this := p
	_ = this

	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, TypeScriptParserRULE_typeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(287)
		p.Match(TypeScriptParserLessThan)
	}
	p.SetState(289)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan || _la == TypeScriptParserIdentifier {
		{
			p.SetState(288)
			p.TypeParameterList()
		}

	}
	{
		p.SetState(291)
		p.Match(TypeScriptParserMoreThan)
	}

	return localctx
}

// ITypeParameterListContext is an interface to support dynamic dispatch.
type ITypeParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterListContext differentiates from other interfaces.
	IsTypeParameterListContext()
}

type TypeParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterListContext() *TypeParameterListContext {
	var p = new(TypeParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeParameterList
	return p
}

func (*TypeParameterListContext) IsTypeParameterListContext() {}

func NewTypeParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterListContext {
	var p = new(TypeParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeParameterList

	return p
}

func (s *TypeParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterListContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterListContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *TypeParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *TypeParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeParameterList(s)
	}
}

func (s *TypeParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeParameterList(s)
	}
}

func (p *TypeScriptParser) TypeParameterList() (localctx ITypeParameterListContext) {
	this := p
	_ = this

	localctx = NewTypeParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, TypeScriptParserRULE_typeParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(293)
		p.TypeParameter()
	}
	p.SetState(298)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		{
			p.SetState(294)
			p.Match(TypeScriptParserComma)
		}
		{
			p.SetState(295)
			p.TypeParameter()
		}

		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *TypeParameterContext) Constraint() IConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *TypeParameterContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *TypeScriptParser) TypeParameter() (localctx ITypeParameterContext) {
	this := p
	_ = this

	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, TypeScriptParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(306)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(301)
			p.Match(TypeScriptParserIdentifier)
		}
		p.SetState(303)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserExtends {
			{
				p.SetState(302)
				p.Constraint()
			}

		}

	case TypeScriptParserLessThan:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(305)
			p.TypeParameters()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constraint
	return p
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) Extends() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExtends, 0)
}

func (s *ConstraintContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterConstraint(s)
	}
}

func (s *ConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitConstraint(s)
	}
}

func (p *TypeScriptParser) Constraint() (localctx IConstraintContext) {
	this := p
	_ = this

	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, TypeScriptParserRULE_constraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(308)
		p.Match(TypeScriptParserExtends)
	}
	{
		p.SetState(309)
		p.Type_()
	}

	return localctx
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeArguments
	return p
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LessThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThan, 0)
}

func (s *TypeArgumentsContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMoreThan, 0)
}

func (s *TypeArgumentsContext) TypeArgumentList() ITypeArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentListContext)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (p *TypeScriptParser) TypeArguments() (localctx ITypeArgumentsContext) {
	this := p
	_ = this

	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, TypeScriptParserRULE_typeArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(311)
		p.Match(TypeScriptParserLessThan)
	}
	p.SetState(313)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&34359739040) != 0 || (int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&3459309871587950857) != 0 {
		{
			p.SetState(312)
			p.TypeArgumentList()
		}

	}
	{
		p.SetState(315)
		p.Match(TypeScriptParserMoreThan)
	}

	return localctx
}

// ITypeArgumentListContext is an interface to support dynamic dispatch.
type ITypeArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentListContext differentiates from other interfaces.
	IsTypeArgumentListContext()
}

type TypeArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentListContext() *TypeArgumentListContext {
	var p = new(TypeArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeArgumentList
	return p
}

func (*TypeArgumentListContext) IsTypeArgumentListContext() {}

func NewTypeArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentListContext {
	var p = new(TypeArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeArgumentList

	return p
}

func (s *TypeArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentListContext) AllTypeArgument() []ITypeArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentContext); ok {
			tst[i] = t.(ITypeArgumentContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentListContext) TypeArgument(i int) ITypeArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentContext)
}

func (s *TypeArgumentListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *TypeArgumentListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *TypeArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeArgumentList(s)
	}
}

func (s *TypeArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeArgumentList(s)
	}
}

func (p *TypeScriptParser) TypeArgumentList() (localctx ITypeArgumentListContext) {
	this := p
	_ = this

	localctx = NewTypeArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, TypeScriptParserRULE_typeArgumentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(317)
		p.TypeArgument()
	}
	p.SetState(322)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		{
			p.SetState(318)
			p.Match(TypeScriptParserComma)
		}
		{
			p.SetState(319)
			p.TypeArgument()
		}

		p.SetState(324)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeArgumentContext is an interface to support dynamic dispatch.
type ITypeArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentContext differentiates from other interfaces.
	IsTypeArgumentContext()
}

type TypeArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentContext() *TypeArgumentContext {
	var p = new(TypeArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeArgument
	return p
}

func (*TypeArgumentContext) IsTypeArgumentContext() {}

func NewTypeArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentContext {
	var p = new(TypeArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeArgument

	return p
}

func (s *TypeArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeArgument(s)
	}
}

func (s *TypeArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeArgument(s)
	}
}

func (p *TypeScriptParser) TypeArgument() (localctx ITypeArgumentContext) {
	this := p
	_ = this

	localctx = NewTypeArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, TypeScriptParserRULE_typeArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(325)
		p.Type_()
	}

	return localctx
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_type_
	return p
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) UnionOrIntersectionOrPrimaryType() IUnionOrIntersectionOrPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionOrIntersectionOrPrimaryTypeContext)
}

func (s *Type_Context) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *Type_Context) ConstructorType() IConstructorTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorTypeContext)
}

func (s *Type_Context) TypeGeneric() ITypeGenericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeGenericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeGenericContext)
}

func (s *Type_Context) StringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStringLiteral, 0)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitType_(s)
	}
}

func (p *TypeScriptParser) Type_() (localctx IType_Context) {
	this := p
	_ = this

	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, TypeScriptParserRULE_type_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(327)
			p.unionOrIntersectionOrPrimaryType(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(328)
			p.FunctionType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(329)
			p.ConstructorType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(330)
			p.TypeGeneric()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(331)
			p.Match(TypeScriptParserStringLiteral)
		}

	}

	return localctx
}

// IUnionOrIntersectionOrPrimaryTypeContext is an interface to support dynamic dispatch.
type IUnionOrIntersectionOrPrimaryTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionOrIntersectionOrPrimaryTypeContext differentiates from other interfaces.
	IsUnionOrIntersectionOrPrimaryTypeContext()
}

type UnionOrIntersectionOrPrimaryTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionOrIntersectionOrPrimaryTypeContext() *UnionOrIntersectionOrPrimaryTypeContext {
	var p = new(UnionOrIntersectionOrPrimaryTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_unionOrIntersectionOrPrimaryType
	return p
}

func (*UnionOrIntersectionOrPrimaryTypeContext) IsUnionOrIntersectionOrPrimaryTypeContext() {}

func NewUnionOrIntersectionOrPrimaryTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionOrIntersectionOrPrimaryTypeContext {
	var p = new(UnionOrIntersectionOrPrimaryTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_unionOrIntersectionOrPrimaryType

	return p
}

func (s *UnionOrIntersectionOrPrimaryTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionOrIntersectionOrPrimaryTypeContext) CopyFrom(ctx *UnionOrIntersectionOrPrimaryTypeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *UnionOrIntersectionOrPrimaryTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionOrIntersectionOrPrimaryTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IntersectionContext struct {
	*UnionOrIntersectionOrPrimaryTypeContext
}

func NewIntersectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntersectionContext {
	var p = new(IntersectionContext)

	p.UnionOrIntersectionOrPrimaryTypeContext = NewEmptyUnionOrIntersectionOrPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*UnionOrIntersectionOrPrimaryTypeContext))

	return p
}

func (s *IntersectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionContext) AllUnionOrIntersectionOrPrimaryType() []IUnionOrIntersectionOrPrimaryTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			len++
		}
	}

	tst := make([]IUnionOrIntersectionOrPrimaryTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			tst[i] = t.(IUnionOrIntersectionOrPrimaryTypeContext)
			i++
		}
	}

	return tst
}

func (s *IntersectionContext) UnionOrIntersectionOrPrimaryType(i int) IUnionOrIntersectionOrPrimaryTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionOrIntersectionOrPrimaryTypeContext)
}

func (s *IntersectionContext) BitAnd() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitAnd, 0)
}

func (s *IntersectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIntersection(s)
	}
}

func (s *IntersectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIntersection(s)
	}
}

type PrimaryContext struct {
	*UnionOrIntersectionOrPrimaryTypeContext
}

func NewPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryContext {
	var p = new(PrimaryContext)

	p.UnionOrIntersectionOrPrimaryTypeContext = NewEmptyUnionOrIntersectionOrPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*UnionOrIntersectionOrPrimaryTypeContext))

	return p
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPrimary(s)
	}
}

type UnionContext struct {
	*UnionOrIntersectionOrPrimaryTypeContext
}

func NewUnionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionContext {
	var p = new(UnionContext)

	p.UnionOrIntersectionOrPrimaryTypeContext = NewEmptyUnionOrIntersectionOrPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*UnionOrIntersectionOrPrimaryTypeContext))

	return p
}

func (s *UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionContext) AllUnionOrIntersectionOrPrimaryType() []IUnionOrIntersectionOrPrimaryTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			len++
		}
	}

	tst := make([]IUnionOrIntersectionOrPrimaryTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			tst[i] = t.(IUnionOrIntersectionOrPrimaryTypeContext)
			i++
		}
	}

	return tst
}

func (s *UnionContext) UnionOrIntersectionOrPrimaryType(i int) IUnionOrIntersectionOrPrimaryTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionOrIntersectionOrPrimaryTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionOrIntersectionOrPrimaryTypeContext)
}

func (s *UnionContext) BitOr() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitOr, 0)
}

func (s *UnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterUnion(s)
	}
}

func (s *UnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitUnion(s)
	}
}

func (p *TypeScriptParser) UnionOrIntersectionOrPrimaryType() (localctx IUnionOrIntersectionOrPrimaryTypeContext) {
	return p.unionOrIntersectionOrPrimaryType(0)
}

func (p *TypeScriptParser) unionOrIntersectionOrPrimaryType(_p int) (localctx IUnionOrIntersectionOrPrimaryTypeContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewUnionOrIntersectionOrPrimaryTypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IUnionOrIntersectionOrPrimaryTypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 20
	p.EnterRecursionRule(localctx, 20, TypeScriptParserRULE_unionOrIntersectionOrPrimaryType, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewPrimaryContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(335)
		p.primaryType(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(345)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(343)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
			case 1:
				localctx = NewUnionContext(p, NewUnionOrIntersectionOrPrimaryTypeContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_unionOrIntersectionOrPrimaryType)
				p.SetState(337)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(338)
					p.Match(TypeScriptParserBitOr)
				}
				{
					p.SetState(339)
					p.unionOrIntersectionOrPrimaryType(4)
				}

			case 2:
				localctx = NewIntersectionContext(p, NewUnionOrIntersectionOrPrimaryTypeContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_unionOrIntersectionOrPrimaryType)
				p.SetState(340)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(341)
					p.Match(TypeScriptParserBitAnd)
				}
				{
					p.SetState(342)
					p.unionOrIntersectionOrPrimaryType(3)
				}

			}

		}
		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryTypeContext is an interface to support dynamic dispatch.
type IPrimaryTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryTypeContext differentiates from other interfaces.
	IsPrimaryTypeContext()
}

type PrimaryTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryTypeContext() *PrimaryTypeContext {
	var p = new(PrimaryTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_primaryType
	return p
}

func (*PrimaryTypeContext) IsPrimaryTypeContext() {}

func NewPrimaryTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryTypeContext {
	var p = new(PrimaryTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_primaryType

	return p
}

func (s *PrimaryTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryTypeContext) CopyFrom(ctx *PrimaryTypeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrimaryTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RedefinitionOfTypeContext struct {
	*PrimaryTypeContext
}

func NewRedefinitionOfTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RedefinitionOfTypeContext {
	var p = new(RedefinitionOfTypeContext)

	p.PrimaryTypeContext = NewEmptyPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryTypeContext))

	return p
}

func (s *RedefinitionOfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RedefinitionOfTypeContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *RedefinitionOfTypeContext) Is() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIs, 0)
}

func (s *RedefinitionOfTypeContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *RedefinitionOfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRedefinitionOfType(s)
	}
}

func (s *RedefinitionOfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRedefinitionOfType(s)
	}
}

type PredefinedPrimTypeContext struct {
	*PrimaryTypeContext
}

func NewPredefinedPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredefinedPrimTypeContext {
	var p = new(PredefinedPrimTypeContext)

	p.PrimaryTypeContext = NewEmptyPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryTypeContext))

	return p
}

func (s *PredefinedPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefinedPrimTypeContext) PredefinedType() IPredefinedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredefinedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredefinedTypeContext)
}

func (s *PredefinedPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPredefinedPrimType(s)
	}
}

func (s *PredefinedPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPredefinedPrimType(s)
	}
}

type ArrayPrimTypeContext struct {
	*PrimaryTypeContext
}

func NewArrayPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayPrimTypeContext {
	var p = new(ArrayPrimTypeContext)

	p.PrimaryTypeContext = NewEmptyPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryTypeContext))

	return p
}

func (s *ArrayPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayPrimTypeContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *ArrayPrimTypeContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *ArrayPrimTypeContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *ArrayPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrayPrimType(s)
	}
}

func (s *ArrayPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrayPrimType(s)
	}
}

type ParenthesizedPrimTypeContext struct {
	*PrimaryTypeContext
}

func NewParenthesizedPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedPrimTypeContext {
	var p = new(ParenthesizedPrimTypeContext)

	p.PrimaryTypeContext = NewEmptyPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryTypeContext))

	return p
}

func (s *ParenthesizedPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedPrimTypeContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ParenthesizedPrimTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ParenthesizedPrimTypeContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ParenthesizedPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterParenthesizedPrimType(s)
	}
}

func (s *ParenthesizedPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitParenthesizedPrimType(s)
	}
}

type ThisPrimTypeContext struct {
	*PrimaryTypeContext
}

func NewThisPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisPrimTypeContext {
	var p = new(ThisPrimTypeContext)

	p.PrimaryTypeContext = NewEmptyPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryTypeContext))

	return p
}

func (s *ThisPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisPrimTypeContext) This() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserThis, 0)
}

func (s *ThisPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterThisPrimType(s)
	}
}

func (s *ThisPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitThisPrimType(s)
	}
}

type TuplePrimTypeContext struct {
	*PrimaryTypeContext
}

func NewTuplePrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TuplePrimTypeContext {
	var p = new(TuplePrimTypeContext)

	p.PrimaryTypeContext = NewEmptyPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryTypeContext))

	return p
}

func (s *TuplePrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TuplePrimTypeContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *TuplePrimTypeContext) TupleElementTypes() ITupleElementTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleElementTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleElementTypesContext)
}

func (s *TuplePrimTypeContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *TuplePrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTuplePrimType(s)
	}
}

func (s *TuplePrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTuplePrimType(s)
	}
}

type ObjectPrimTypeContext struct {
	*PrimaryTypeContext
}

func NewObjectPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectPrimTypeContext {
	var p = new(ObjectPrimTypeContext)

	p.PrimaryTypeContext = NewEmptyPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryTypeContext))

	return p
}

func (s *ObjectPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectPrimTypeContext) ObjectType() IObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectTypeContext)
}

func (s *ObjectPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterObjectPrimType(s)
	}
}

func (s *ObjectPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitObjectPrimType(s)
	}
}

type ReferencePrimTypeContext struct {
	*PrimaryTypeContext
}

func NewReferencePrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReferencePrimTypeContext {
	var p = new(ReferencePrimTypeContext)

	p.PrimaryTypeContext = NewEmptyPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryTypeContext))

	return p
}

func (s *ReferencePrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferencePrimTypeContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *ReferencePrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterReferencePrimType(s)
	}
}

func (s *ReferencePrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitReferencePrimType(s)
	}
}

type QueryPrimTypeContext struct {
	*PrimaryTypeContext
}

func NewQueryPrimTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimTypeContext {
	var p = new(QueryPrimTypeContext)

	p.PrimaryTypeContext = NewEmptyPrimaryTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryTypeContext))

	return p
}

func (s *QueryPrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimTypeContext) TypeQuery() ITypeQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQueryContext)
}

func (s *QueryPrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterQueryPrimType(s)
	}
}

func (s *QueryPrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitQueryPrimType(s)
	}
}

func (p *TypeScriptParser) PrimaryType() (localctx IPrimaryTypeContext) {
	return p.primaryType(0)
}

func (p *TypeScriptParser) primaryType(_p int) (localctx IPrimaryTypeContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimaryTypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryTypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 22
	p.EnterRecursionRule(localctx, 22, TypeScriptParserRULE_primaryType, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParenthesizedPrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(349)
			p.Match(TypeScriptParserOpenParen)
		}
		{
			p.SetState(350)
			p.Type_()
		}
		{
			p.SetState(351)
			p.Match(TypeScriptParserCloseParen)
		}

	case 2:
		localctx = NewPredefinedPrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(353)
			p.PredefinedType()
		}

	case 3:
		localctx = NewReferencePrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(354)
			p.TypeReference()
		}

	case 4:
		localctx = NewObjectPrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(355)
			p.ObjectType()
		}

	case 5:
		localctx = NewTuplePrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(356)
			p.Match(TypeScriptParserOpenBracket)
		}
		{
			p.SetState(357)
			p.TupleElementTypes()
		}
		{
			p.SetState(358)
			p.Match(TypeScriptParserCloseBracket)
		}

	case 6:
		localctx = NewQueryPrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(360)
			p.TypeQuery()
		}

	case 7:
		localctx = NewThisPrimTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(361)
			p.Match(TypeScriptParserThis)
		}

	case 8:
		localctx = NewRedefinitionOfTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(362)
			p.TypeReference()
		}
		{
			p.SetState(363)
			p.Match(TypeScriptParserIs)
		}
		{
			p.SetState(364)
			p.primaryType(1)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(374)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewArrayPrimTypeContext(p, NewPrimaryTypeContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_primaryType)
			p.SetState(368)

			if !(p.Precpred(p.GetParserRuleContext(), 5)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
			}
			p.SetState(369)

			if !(p.notLineTerminator()) {
				panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
			}
			{
				p.SetState(370)
				p.Match(TypeScriptParserOpenBracket)
			}
			{
				p.SetState(371)
				p.Match(TypeScriptParserCloseBracket)
			}

		}
		p.SetState(376)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())
	}

	return localctx
}

// IPredefinedTypeContext is an interface to support dynamic dispatch.
type IPredefinedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredefinedTypeContext differentiates from other interfaces.
	IsPredefinedTypeContext()
}

type PredefinedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredefinedTypeContext() *PredefinedTypeContext {
	var p = new(PredefinedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_predefinedType
	return p
}

func (*PredefinedTypeContext) IsPredefinedTypeContext() {}

func NewPredefinedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredefinedTypeContext {
	var p = new(PredefinedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_predefinedType

	return p
}

func (s *PredefinedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PredefinedTypeContext) ANY() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserANY, 0)
}

func (s *PredefinedTypeContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNUMBER, 0)
}

func (s *PredefinedTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBOOLEAN, 0)
}

func (s *PredefinedTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSTRING, 0)
}

func (s *PredefinedTypeContext) SYMBOL() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSYMBOL, 0)
}

func (s *PredefinedTypeContext) Void() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserVoid, 0)
}

func (s *PredefinedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefinedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredefinedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPredefinedType(s)
	}
}

func (s *PredefinedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPredefinedType(s)
	}
}

func (p *TypeScriptParser) PredefinedType() (localctx IPredefinedTypeContext) {
	this := p
	_ = this

	localctx = NewPredefinedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, TypeScriptParserRULE_predefinedType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(377)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&2130303778817) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeReferenceContext is an interface to support dynamic dispatch.
type ITypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeReferenceContext differentiates from other interfaces.
	IsTypeReferenceContext()
}

type TypeReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeReferenceContext() *TypeReferenceContext {
	var p = new(TypeReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeReference
	return p
}

func (*TypeReferenceContext) IsTypeReferenceContext() {}

func NewTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeReferenceContext {
	var p = new(TypeReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeReference

	return p
}

func (s *TypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeReferenceContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeReferenceContext) TypeIncludeGeneric() ITypeIncludeGenericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIncludeGenericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIncludeGenericContext)
}

func (s *TypeReferenceContext) TypeGeneric() ITypeGenericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeGenericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeGenericContext)
}

func (s *TypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeReference(s)
	}
}

func (s *TypeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeReference(s)
	}
}

func (p *TypeScriptParser) TypeReference() (localctx ITypeReferenceContext) {
	this := p
	_ = this

	localctx = NewTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, TypeScriptParserRULE_typeReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.TypeName()
	}
	p.SetState(382)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(380)
			p.TypeIncludeGeneric()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(381)
			p.TypeGeneric()
		}

	}

	return localctx
}

// ITypeGenericContext is an interface to support dynamic dispatch.
type ITypeGenericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeGenericContext differentiates from other interfaces.
	IsTypeGenericContext()
}

type TypeGenericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeGenericContext() *TypeGenericContext {
	var p = new(TypeGenericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeGeneric
	return p
}

func (*TypeGenericContext) IsTypeGenericContext() {}

func NewTypeGenericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeGenericContext {
	var p = new(TypeGenericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeGeneric

	return p
}

func (s *TypeGenericContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeGenericContext) LessThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThan, 0)
}

func (s *TypeGenericContext) TypeArgumentList() ITypeArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentListContext)
}

func (s *TypeGenericContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMoreThan, 0)
}

func (s *TypeGenericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeGenericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeGenericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeGeneric(s)
	}
}

func (s *TypeGenericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeGeneric(s)
	}
}

func (p *TypeScriptParser) TypeGeneric() (localctx ITypeGenericContext) {
	this := p
	_ = this

	localctx = NewTypeGenericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, TypeScriptParserRULE_typeGeneric)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Match(TypeScriptParserLessThan)
	}
	{
		p.SetState(385)
		p.TypeArgumentList()
	}
	{
		p.SetState(386)
		p.Match(TypeScriptParserMoreThan)
	}

	return localctx
}

// ITypeIncludeGenericContext is an interface to support dynamic dispatch.
type ITypeIncludeGenericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeIncludeGenericContext differentiates from other interfaces.
	IsTypeIncludeGenericContext()
}

type TypeIncludeGenericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIncludeGenericContext() *TypeIncludeGenericContext {
	var p = new(TypeIncludeGenericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeIncludeGeneric
	return p
}

func (*TypeIncludeGenericContext) IsTypeIncludeGenericContext() {}

func NewTypeIncludeGenericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIncludeGenericContext {
	var p = new(TypeIncludeGenericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeIncludeGeneric

	return p
}

func (s *TypeIncludeGenericContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIncludeGenericContext) AllLessThan() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserLessThan)
}

func (s *TypeIncludeGenericContext) LessThan(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThan, i)
}

func (s *TypeIncludeGenericContext) AllTypeArgumentList() []ITypeArgumentListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentListContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentListContext); ok {
			tst[i] = t.(ITypeArgumentListContext)
			i++
		}
	}

	return tst
}

func (s *TypeIncludeGenericContext) TypeArgumentList(i int) ITypeArgumentListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentListContext)
}

func (s *TypeIncludeGenericContext) AllMoreThan() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserMoreThan)
}

func (s *TypeIncludeGenericContext) MoreThan(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMoreThan, i)
}

func (s *TypeIncludeGenericContext) BindingPattern() IBindingPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingPatternContext)
}

func (s *TypeIncludeGenericContext) RightShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRightShiftArithmetic, 0)
}

func (s *TypeIncludeGenericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIncludeGenericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIncludeGenericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeIncludeGeneric(s)
	}
}

func (s *TypeIncludeGenericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeIncludeGeneric(s)
	}
}

func (p *TypeScriptParser) TypeIncludeGeneric() (localctx ITypeIncludeGenericContext) {
	this := p
	_ = this

	localctx = NewTypeIncludeGenericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, TypeScriptParserRULE_typeIncludeGeneric)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(388)
		p.Match(TypeScriptParserLessThan)
	}
	{
		p.SetState(389)
		p.TypeArgumentList()
	}
	{
		p.SetState(390)
		p.Match(TypeScriptParserLessThan)
	}
	{
		p.SetState(391)
		p.TypeArgumentList()
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserMoreThan:
		{
			p.SetState(392)
			p.Match(TypeScriptParserMoreThan)
		}
		{
			p.SetState(393)
			p.BindingPattern()
		}
		{
			p.SetState(394)
			p.Match(TypeScriptParserMoreThan)
		}

	case TypeScriptParserRightShiftArithmetic:
		{
			p.SetState(396)
			p.Match(TypeScriptParserRightShiftArithmetic)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeName
	return p
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *TypeNameContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *TypeScriptParser) TypeName() (localctx ITypeNameContext) {
	this := p
	_ = this

	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, TypeScriptParserRULE_typeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(401)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(399)
			p.Match(TypeScriptParserIdentifier)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(400)
			p.NamespaceName()
		}

	}

	return localctx
}

// IObjectTypeContext is an interface to support dynamic dispatch.
type IObjectTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectTypeContext differentiates from other interfaces.
	IsObjectTypeContext()
}

type ObjectTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectTypeContext() *ObjectTypeContext {
	var p = new(ObjectTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_objectType
	return p
}

func (*ObjectTypeContext) IsObjectTypeContext() {}

func NewObjectTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectTypeContext {
	var p = new(ObjectTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_objectType

	return p
}

func (s *ObjectTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectTypeContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *ObjectTypeContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *ObjectTypeContext) TypeBody() ITypeBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeBodyContext)
}

func (s *ObjectTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterObjectType(s)
	}
}

func (s *ObjectTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitObjectType(s)
	}
}

func (p *TypeScriptParser) ObjectType() (localctx IObjectTypeContext) {
	this := p
	_ = this

	localctx = NewObjectTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, TypeScriptParserRULE_objectType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(403)
		p.Match(TypeScriptParserOpenBrace)
	}
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&-72057592964186107) != 0 || (int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-4611615649683210241) != 0 {
		{
			p.SetState(404)
			p.TypeBody()
		}

	}
	{
		p.SetState(407)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// ITypeBodyContext is an interface to support dynamic dispatch.
type ITypeBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeBodyContext differentiates from other interfaces.
	IsTypeBodyContext()
}

type TypeBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeBodyContext() *TypeBodyContext {
	var p = new(TypeBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeBody
	return p
}

func (*TypeBodyContext) IsTypeBodyContext() {}

func NewTypeBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeBodyContext {
	var p = new(TypeBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeBody

	return p
}

func (s *TypeBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeBodyContext) TypeMemberList() ITypeMemberListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeMemberListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeMemberListContext)
}

func (s *TypeBodyContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *TypeBodyContext) Comma() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, 0)
}

func (s *TypeBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeBody(s)
	}
}

func (s *TypeBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeBody(s)
	}
}

func (p *TypeScriptParser) TypeBody() (localctx ITypeBodyContext) {
	this := p
	_ = this

	localctx = NewTypeBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, TypeScriptParserRULE_typeBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.TypeMemberList()
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserSemiColon || _la == TypeScriptParserComma {
		{
			p.SetState(410)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TypeScriptParserSemiColon || _la == TypeScriptParserComma) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ITypeMemberListContext is an interface to support dynamic dispatch.
type ITypeMemberListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeMemberListContext differentiates from other interfaces.
	IsTypeMemberListContext()
}

type TypeMemberListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeMemberListContext() *TypeMemberListContext {
	var p = new(TypeMemberListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeMemberList
	return p
}

func (*TypeMemberListContext) IsTypeMemberListContext() {}

func NewTypeMemberListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeMemberListContext {
	var p = new(TypeMemberListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeMemberList

	return p
}

func (s *TypeMemberListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeMemberListContext) AllTypeMember() []ITypeMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeMemberContext); ok {
			len++
		}
	}

	tst := make([]ITypeMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeMemberContext); ok {
			tst[i] = t.(ITypeMemberContext)
			i++
		}
	}

	return tst
}

func (s *TypeMemberListContext) TypeMember(i int) ITypeMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeMemberContext)
}

func (s *TypeMemberListContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserSemiColon)
}

func (s *TypeMemberListContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, i)
}

func (s *TypeMemberListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *TypeMemberListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *TypeMemberListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeMemberListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeMemberListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeMemberList(s)
	}
}

func (s *TypeMemberListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeMemberList(s)
	}
}

func (p *TypeScriptParser) TypeMemberList() (localctx ITypeMemberListContext) {
	this := p
	_ = this

	localctx = NewTypeMemberListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, TypeScriptParserRULE_typeMemberList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.TypeMember()
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(414)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TypeScriptParserSemiColon || _la == TypeScriptParserComma) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(415)
				p.TypeMember()
			}

		}
		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeMemberContext is an interface to support dynamic dispatch.
type ITypeMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeMemberContext differentiates from other interfaces.
	IsTypeMemberContext()
}

type TypeMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeMemberContext() *TypeMemberContext {
	var p = new(TypeMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeMember
	return p
}

func (*TypeMemberContext) IsTypeMemberContext() {}

func NewTypeMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeMemberContext {
	var p = new(TypeMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeMember

	return p
}

func (s *TypeMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeMemberContext) PropertySignature() IPropertySignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertySignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertySignatureContext)
}

func (s *TypeMemberContext) CallSignature() ICallSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSignatureContext)
}

func (s *TypeMemberContext) ConstructSignature() IConstructSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructSignatureContext)
}

func (s *TypeMemberContext) IndexSignature() IIndexSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexSignatureContext)
}

func (s *TypeMemberContext) MethodSignature() IMethodSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodSignatureContext)
}

func (s *TypeMemberContext) ARROW() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserARROW, 0)
}

func (s *TypeMemberContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeMember(s)
	}
}

func (s *TypeMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeMember(s)
	}
}

func (p *TypeScriptParser) TypeMember() (localctx ITypeMemberContext) {
	this := p
	_ = this

	localctx = NewTypeMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, TypeScriptParserRULE_typeMember)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(421)
			p.PropertySignature()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(422)
			p.CallSignature()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(423)
			p.ConstructSignature()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(424)
			p.IndexSignature()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(425)
			p.MethodSignature()
		}
		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserARROW {
			{
				p.SetState(426)
				p.Match(TypeScriptParserARROW)
			}
			{
				p.SetState(427)
				p.Type_()
			}

		}

	}

	return localctx
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrayType
	return p
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *ArrayTypeContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *ArrayTypeContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (p *TypeScriptParser) ArrayType() (localctx IArrayTypeContext) {
	this := p
	_ = this

	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, TypeScriptParserRULE_arrayType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(432)
		p.primaryType(0)
	}
	p.SetState(433)

	if !(p.notLineTerminator()) {
		panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
	}
	{
		p.SetState(434)
		p.Match(TypeScriptParserOpenBracket)
	}
	{
		p.SetState(435)
		p.Match(TypeScriptParserCloseBracket)
	}

	return localctx
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_tupleType
	return p
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *TupleTypeContext) TupleElementTypes() ITupleElementTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleElementTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleElementTypesContext)
}

func (s *TupleTypeContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTupleType(s)
	}
}

func (s *TupleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTupleType(s)
	}
}

func (p *TypeScriptParser) TupleType() (localctx ITupleTypeContext) {
	this := p
	_ = this

	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, TypeScriptParserRULE_tupleType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(437)
		p.Match(TypeScriptParserOpenBracket)
	}
	{
		p.SetState(438)
		p.TupleElementTypes()
	}
	{
		p.SetState(439)
		p.Match(TypeScriptParserCloseBracket)
	}

	return localctx
}

// ITupleElementTypesContext is an interface to support dynamic dispatch.
type ITupleElementTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTupleElementTypesContext differentiates from other interfaces.
	IsTupleElementTypesContext()
}

type TupleElementTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleElementTypesContext() *TupleElementTypesContext {
	var p = new(TupleElementTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_tupleElementTypes
	return p
}

func (*TupleElementTypesContext) IsTupleElementTypesContext() {}

func NewTupleElementTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleElementTypesContext {
	var p = new(TupleElementTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_tupleElementTypes

	return p
}

func (s *TupleElementTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleElementTypesContext) AllType_() []IType_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_Context); ok {
			len++
		}
	}

	tst := make([]IType_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_Context); ok {
			tst[i] = t.(IType_Context)
			i++
		}
	}

	return tst
}

func (s *TupleElementTypesContext) Type_(i int) IType_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TupleElementTypesContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *TupleElementTypesContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *TupleElementTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleElementTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleElementTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTupleElementTypes(s)
	}
}

func (s *TupleElementTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTupleElementTypes(s)
	}
}

func (p *TypeScriptParser) TupleElementTypes() (localctx ITupleElementTypesContext) {
	this := p
	_ = this

	localctx = NewTupleElementTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, TypeScriptParserRULE_tupleElementTypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.Type_()
	}
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		{
			p.SetState(442)
			p.Match(TypeScriptParserComma)
		}
		{
			p.SetState(443)
			p.Type_()
		}

		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionType
	return p
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *FunctionTypeContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *FunctionTypeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserARROW, 0)
}

func (s *FunctionTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FunctionTypeContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *FunctionTypeContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (p *TypeScriptParser) FunctionType() (localctx IFunctionTypeContext) {
	this := p
	_ = this

	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, TypeScriptParserRULE_functionType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(450)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(449)
			p.TypeParameters()
		}

	}
	{
		p.SetState(452)
		p.Match(TypeScriptParserOpenParen)
	}
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6917529027641147936) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-4607182418800017409) != 0 {
		{
			p.SetState(453)
			p.ParameterList()
		}

	}
	{
		p.SetState(456)
		p.Match(TypeScriptParserCloseParen)
	}
	{
		p.SetState(457)
		p.Match(TypeScriptParserARROW)
	}
	{
		p.SetState(458)
		p.Type_()
	}

	return localctx
}

// IConstructorTypeContext is an interface to support dynamic dispatch.
type IConstructorTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorTypeContext differentiates from other interfaces.
	IsConstructorTypeContext()
}

type ConstructorTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorTypeContext() *ConstructorTypeContext {
	var p = new(ConstructorTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constructorType
	return p
}

func (*ConstructorTypeContext) IsConstructorTypeContext() {}

func NewConstructorTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorTypeContext {
	var p = new(ConstructorTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_constructorType

	return p
}

func (s *ConstructorTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorTypeContext) New() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNew, 0)
}

func (s *ConstructorTypeContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ConstructorTypeContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ConstructorTypeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserARROW, 0)
}

func (s *ConstructorTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ConstructorTypeContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ConstructorTypeContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ConstructorTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterConstructorType(s)
	}
}

func (s *ConstructorTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitConstructorType(s)
	}
}

func (p *TypeScriptParser) ConstructorType() (localctx IConstructorTypeContext) {
	this := p
	_ = this

	localctx = NewConstructorTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, TypeScriptParserRULE_constructorType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(460)
		p.Match(TypeScriptParserNew)
	}
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(461)
			p.TypeParameters()
		}

	}
	{
		p.SetState(464)
		p.Match(TypeScriptParserOpenParen)
	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6917529027641147936) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-4607182418800017409) != 0 {
		{
			p.SetState(465)
			p.ParameterList()
		}

	}
	{
		p.SetState(468)
		p.Match(TypeScriptParserCloseParen)
	}
	{
		p.SetState(469)
		p.Match(TypeScriptParserARROW)
	}
	{
		p.SetState(470)
		p.Type_()
	}

	return localctx
}

// ITypeQueryContext is an interface to support dynamic dispatch.
type ITypeQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeQueryContext differentiates from other interfaces.
	IsTypeQueryContext()
}

type TypeQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeQueryContext() *TypeQueryContext {
	var p = new(TypeQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeQuery
	return p
}

func (*TypeQueryContext) IsTypeQueryContext() {}

func NewTypeQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeQueryContext {
	var p = new(TypeQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeQuery

	return p
}

func (s *TypeQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeQueryContext) Typeof() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTypeof, 0)
}

func (s *TypeQueryContext) TypeQueryExpression() ITypeQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQueryExpressionContext)
}

func (s *TypeQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeQuery(s)
	}
}

func (s *TypeQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeQuery(s)
	}
}

func (p *TypeScriptParser) TypeQuery() (localctx ITypeQueryContext) {
	this := p
	_ = this

	localctx = NewTypeQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, TypeScriptParserRULE_typeQuery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(472)
		p.Match(TypeScriptParserTypeof)
	}
	{
		p.SetState(473)
		p.TypeQueryExpression()
	}

	return localctx
}

// ITypeQueryExpressionContext is an interface to support dynamic dispatch.
type ITypeQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeQueryExpressionContext differentiates from other interfaces.
	IsTypeQueryExpressionContext()
}

type TypeQueryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeQueryExpressionContext() *TypeQueryExpressionContext {
	var p = new(TypeQueryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeQueryExpression
	return p
}

func (*TypeQueryExpressionContext) IsTypeQueryExpressionContext() {}

func NewTypeQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeQueryExpressionContext {
	var p = new(TypeQueryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeQueryExpression

	return p
}

func (s *TypeQueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeQueryExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *TypeQueryExpressionContext) AllIdentifierName() []IIdentifierNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierNameContext); ok {
			tst[i] = t.(IIdentifierNameContext)
			i++
		}
	}

	return tst
}

func (s *TypeQueryExpressionContext) IdentifierName(i int) IIdentifierNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *TypeQueryExpressionContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserDot)
}

func (s *TypeQueryExpressionContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDot, i)
}

func (s *TypeQueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeQueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeQueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeQueryExpression(s)
	}
}

func (s *TypeQueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeQueryExpression(s)
	}
}

func (p *TypeScriptParser) TypeQueryExpression() (localctx ITypeQueryExpressionContext) {
	this := p
	_ = this

	localctx = NewTypeQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, TypeScriptParserRULE_typeQueryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(475)
			p.Match(TypeScriptParserIdentifier)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(479)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(476)
					p.IdentifierName()
				}
				{
					p.SetState(477)
					p.Match(TypeScriptParserDot)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(481)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())
		}
		{
			p.SetState(483)
			p.IdentifierName()
		}

	}

	return localctx
}

// IPropertySignatureContext is an interface to support dynamic dispatch.
type IPropertySignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertySignatureContext differentiates from other interfaces.
	IsPropertySignatureContext()
}

type PropertySignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertySignatureContext() *PropertySignatureContext {
	var p = new(PropertySignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertySignature
	return p
}

func (*PropertySignatureContext) IsPropertySignatureContext() {}

func NewPropertySignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertySignatureContext {
	var p = new(PropertySignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_propertySignature

	return p
}

func (s *PropertySignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertySignatureContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertySignatureContext) ReadOnly() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReadOnly, 0)
}

func (s *PropertySignatureContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserQuestionMark, 0)
}

func (s *PropertySignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *PropertySignatureContext) ARROW() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserARROW, 0)
}

func (s *PropertySignatureContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *PropertySignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertySignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertySignature(s)
	}
}

func (s *PropertySignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertySignature(s)
	}
}

func (p *TypeScriptParser) PropertySignature() (localctx IPropertySignatureContext) {
	this := p
	_ = this

	localctx = NewPropertySignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, TypeScriptParserRULE_propertySignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(488)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(487)
			p.Match(TypeScriptParserReadOnly)
		}

	}
	{
		p.SetState(490)
		p.PropertyName()
	}
	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserQuestionMark {
		{
			p.SetState(491)
			p.Match(TypeScriptParserQuestionMark)
		}

	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(494)
			p.TypeAnnotation()
		}

	}
	p.SetState(499)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserARROW {
		{
			p.SetState(497)
			p.Match(TypeScriptParserARROW)
		}
		{
			p.SetState(498)
			p.Type_()
		}

	}

	return localctx
}

// ITypeAnnotationContext is an interface to support dynamic dispatch.
type ITypeAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeAnnotationContext differentiates from other interfaces.
	IsTypeAnnotationContext()
}

type TypeAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAnnotationContext() *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeAnnotation
	return p
}

func (*TypeAnnotationContext) IsTypeAnnotationContext() {}

func NewTypeAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeAnnotation

	return p
}

func (s *TypeAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAnnotationContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *TypeAnnotationContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeAnnotation(s)
	}
}

func (s *TypeAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeAnnotation(s)
	}
}

func (p *TypeScriptParser) TypeAnnotation() (localctx ITypeAnnotationContext) {
	this := p
	_ = this

	localctx = NewTypeAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, TypeScriptParserRULE_typeAnnotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(501)
		p.Match(TypeScriptParserColon)
	}
	{
		p.SetState(502)
		p.Type_()
	}

	return localctx
}

// ICallSignatureContext is an interface to support dynamic dispatch.
type ICallSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallSignatureContext differentiates from other interfaces.
	IsCallSignatureContext()
}

type CallSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallSignatureContext() *CallSignatureContext {
	var p = new(CallSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_callSignature
	return p
}

func (*CallSignatureContext) IsCallSignatureContext() {}

func NewCallSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallSignatureContext {
	var p = new(CallSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_callSignature

	return p
}

func (s *CallSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *CallSignatureContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *CallSignatureContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *CallSignatureContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *CallSignatureContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *CallSignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *CallSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCallSignature(s)
	}
}

func (s *CallSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCallSignature(s)
	}
}

func (p *TypeScriptParser) CallSignature() (localctx ICallSignatureContext) {
	this := p
	_ = this

	localctx = NewCallSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, TypeScriptParserRULE_callSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(504)
			p.TypeParameters()
		}

	}
	{
		p.SetState(507)
		p.Match(TypeScriptParserOpenParen)
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6917529027641147936) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-4607182418800017409) != 0 {
		{
			p.SetState(508)
			p.ParameterList()
		}

	}
	{
		p.SetState(511)
		p.Match(TypeScriptParserCloseParen)
	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(512)
			p.TypeAnnotation()
		}

	}

	return localctx
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_parameterList
	return p
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) RestParameter() IRestParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestParameterContext)
}

func (s *ParameterListContext) AllPredefinedType() []IPredefinedTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredefinedTypeContext); ok {
			len++
		}
	}

	tst := make([]IPredefinedTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredefinedTypeContext); ok {
			tst[i] = t.(IPredefinedTypeContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) PredefinedType(i int) IPredefinedTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredefinedTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredefinedTypeContext)
}

func (s *ParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ParameterListContext) OptionalParameterList() IOptionalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionalParameterListContext)
}

func (s *ParameterListContext) RequiredParameterList() IRequiredParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequiredParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequiredParameterListContext)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (p *TypeScriptParser) ParameterList() (localctx IParameterListContext) {
	this := p
	_ = this

	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, TypeScriptParserRULE_parameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(541)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(515)
			p.RestParameter()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(516)
			p.PredefinedType()
		}
		p.SetState(521)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == TypeScriptParserComma {
			{
				p.SetState(517)
				p.Match(TypeScriptParserComma)
			}
			{
				p.SetState(518)
				p.PredefinedType()
			}

			p.SetState(523)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(524)
			p.OptionalParameterList()
		}
		p.SetState(527)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserComma {
			{
				p.SetState(525)
				p.Match(TypeScriptParserComma)
			}
			{
				p.SetState(526)
				p.RestParameter()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(529)
			p.RequiredParameterList()
		}
		p.SetState(539)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserComma {
			{
				p.SetState(530)
				p.Match(TypeScriptParserComma)
			}
			p.SetState(537)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case TypeScriptParserOpenBracket, TypeScriptParserOpenBrace, TypeScriptParserNullLiteral, TypeScriptParserBooleanLiteral, TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserAs, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserAwait, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield, TypeScriptParserAt, TypeScriptParserIdentifier:
				{
					p.SetState(531)
					p.OptionalParameterList()
				}
				p.SetState(534)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TypeScriptParserComma {
					{
						p.SetState(532)
						p.Match(TypeScriptParserComma)
					}
					{
						p.SetState(533)
						p.RestParameter()
					}

				}

			case TypeScriptParserEllipsis:
				{
					p.SetState(536)
					p.RestParameter()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}

	}

	return localctx
}

// IRequiredParameterListContext is an interface to support dynamic dispatch.
type IRequiredParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRequiredParameterListContext differentiates from other interfaces.
	IsRequiredParameterListContext()
}

type RequiredParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiredParameterListContext() *RequiredParameterListContext {
	var p = new(RequiredParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_requiredParameterList
	return p
}

func (*RequiredParameterListContext) IsRequiredParameterListContext() {}

func NewRequiredParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiredParameterListContext {
	var p = new(RequiredParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_requiredParameterList

	return p
}

func (s *RequiredParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiredParameterListContext) AllRequiredParameter() []IRequiredParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRequiredParameterContext); ok {
			len++
		}
	}

	tst := make([]IRequiredParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRequiredParameterContext); ok {
			tst[i] = t.(IRequiredParameterContext)
			i++
		}
	}

	return tst
}

func (s *RequiredParameterListContext) RequiredParameter(i int) IRequiredParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequiredParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequiredParameterContext)
}

func (s *RequiredParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *RequiredParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *RequiredParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiredParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiredParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRequiredParameterList(s)
	}
}

func (s *RequiredParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRequiredParameterList(s)
	}
}

func (p *TypeScriptParser) RequiredParameterList() (localctx IRequiredParameterListContext) {
	this := p
	_ = this

	localctx = NewRequiredParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, TypeScriptParserRULE_requiredParameterList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.RequiredParameter()
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(544)
				p.Match(TypeScriptParserComma)
			}
			{
				p.SetState(545)
				p.RequiredParameter()
			}

		}
		p.SetState(550)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}

	return localctx
}

// IRequiredParameterContext is an interface to support dynamic dispatch.
type IRequiredParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRequiredParameterContext differentiates from other interfaces.
	IsRequiredParameterContext()
}

type RequiredParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiredParameterContext() *RequiredParameterContext {
	var p = new(RequiredParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_requiredParameter
	return p
}

func (*RequiredParameterContext) IsRequiredParameterContext() {}

func NewRequiredParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiredParameterContext {
	var p = new(RequiredParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_requiredParameter

	return p
}

func (s *RequiredParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiredParameterContext) IdentifierOrPattern() IIdentifierOrPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrPatternContext)
}

func (s *RequiredParameterContext) DecoratorList() IDecoratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorListContext)
}

func (s *RequiredParameterContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *RequiredParameterContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *RequiredParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiredParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiredParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRequiredParameter(s)
	}
}

func (s *RequiredParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRequiredParameter(s)
	}
}

func (p *TypeScriptParser) RequiredParameter() (localctx IRequiredParameterContext) {
	this := p
	_ = this

	localctx = NewRequiredParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, TypeScriptParserRULE_requiredParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(552)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAt {
		{
			p.SetState(551)
			p.DecoratorList()
		}

	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(554)
			p.AccessibilityModifier()
		}

	}
	{
		p.SetState(557)
		p.IdentifierOrPattern()
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(558)
			p.TypeAnnotation()
		}

	}

	return localctx
}

// IAccessibilityModifierContext is an interface to support dynamic dispatch.
type IAccessibilityModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccessibilityModifierContext differentiates from other interfaces.
	IsAccessibilityModifierContext()
}

type AccessibilityModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessibilityModifierContext() *AccessibilityModifierContext {
	var p = new(AccessibilityModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_accessibilityModifier
	return p
}

func (*AccessibilityModifierContext) IsAccessibilityModifierContext() {}

func NewAccessibilityModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessibilityModifierContext {
	var p = new(AccessibilityModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_accessibilityModifier

	return p
}

func (s *AccessibilityModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessibilityModifierContext) Public() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPublic, 0)
}

func (s *AccessibilityModifierContext) Private() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPrivate, 0)
}

func (s *AccessibilityModifierContext) Protected() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserProtected, 0)
}

func (s *AccessibilityModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessibilityModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessibilityModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAccessibilityModifier(s)
	}
}

func (s *AccessibilityModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAccessibilityModifier(s)
	}
}

func (p *TypeScriptParser) AccessibilityModifier() (localctx IAccessibilityModifierContext) {
	this := p
	_ = this

	localctx = NewAccessibilityModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, TypeScriptParserRULE_accessibilityModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(561)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&19) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifierOrPatternContext is an interface to support dynamic dispatch.
type IIdentifierOrPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierOrPatternContext differentiates from other interfaces.
	IsIdentifierOrPatternContext()
}

type IdentifierOrPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrPatternContext() *IdentifierOrPatternContext {
	var p = new(IdentifierOrPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_identifierOrPattern
	return p
}

func (*IdentifierOrPatternContext) IsIdentifierOrPatternContext() {}

func NewIdentifierOrPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrPatternContext {
	var p = new(IdentifierOrPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_identifierOrPattern

	return p
}

func (s *IdentifierOrPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrPatternContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *IdentifierOrPatternContext) BindingPattern() IBindingPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingPatternContext)
}

func (s *IdentifierOrPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIdentifierOrPattern(s)
	}
}

func (s *IdentifierOrPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIdentifierOrPattern(s)
	}
}

func (p *TypeScriptParser) IdentifierOrPattern() (localctx IIdentifierOrPatternContext) {
	this := p
	_ = this

	localctx = NewIdentifierOrPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, TypeScriptParserRULE_identifierOrPattern)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(565)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserNullLiteral, TypeScriptParserBooleanLiteral, TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserAs, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserAwait, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield, TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(563)
			p.IdentifierName()
		}

	case TypeScriptParserOpenBracket, TypeScriptParserOpenBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(564)
			p.BindingPattern()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOptionalParameterListContext is an interface to support dynamic dispatch.
type IOptionalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalParameterListContext differentiates from other interfaces.
	IsOptionalParameterListContext()
}

type OptionalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalParameterListContext() *OptionalParameterListContext {
	var p = new(OptionalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_optionalParameterList
	return p
}

func (*OptionalParameterListContext) IsOptionalParameterListContext() {}

func NewOptionalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalParameterListContext {
	var p = new(OptionalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_optionalParameterList

	return p
}

func (s *OptionalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalParameterListContext) AllOptionalParameter() []IOptionalParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionalParameterContext); ok {
			len++
		}
	}

	tst := make([]IOptionalParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionalParameterContext); ok {
			tst[i] = t.(IOptionalParameterContext)
			i++
		}
	}

	return tst
}

func (s *OptionalParameterListContext) OptionalParameter(i int) IOptionalParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionalParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionalParameterContext)
}

func (s *OptionalParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *OptionalParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *OptionalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterOptionalParameterList(s)
	}
}

func (s *OptionalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitOptionalParameterList(s)
	}
}

func (p *TypeScriptParser) OptionalParameterList() (localctx IOptionalParameterListContext) {
	this := p
	_ = this

	localctx = NewOptionalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, TypeScriptParserRULE_optionalParameterList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(567)
		p.OptionalParameter()
	}
	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(568)
				p.Match(TypeScriptParserComma)
			}
			{
				p.SetState(569)
				p.OptionalParameter()
			}

		}
		p.SetState(574)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext())
	}

	return localctx
}

// IOptionalParameterContext is an interface to support dynamic dispatch.
type IOptionalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalParameterContext differentiates from other interfaces.
	IsOptionalParameterContext()
}

type OptionalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalParameterContext() *OptionalParameterContext {
	var p = new(OptionalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_optionalParameter
	return p
}

func (*OptionalParameterContext) IsOptionalParameterContext() {}

func NewOptionalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalParameterContext {
	var p = new(OptionalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_optionalParameter

	return p
}

func (s *OptionalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalParameterContext) IdentifierOrPattern() IIdentifierOrPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrPatternContext)
}

func (s *OptionalParameterContext) DecoratorList() IDecoratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorListContext)
}

func (s *OptionalParameterContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserQuestionMark, 0)
}

func (s *OptionalParameterContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *OptionalParameterContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *OptionalParameterContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *OptionalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterOptionalParameter(s)
	}
}

func (s *OptionalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitOptionalParameter(s)
	}
}

func (p *TypeScriptParser) OptionalParameter() (localctx IOptionalParameterContext) {
	this := p
	_ = this

	localctx = NewOptionalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, TypeScriptParserRULE_optionalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(576)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAt {
		{
			p.SetState(575)
			p.DecoratorList()
		}

	}

	p.SetState(579)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(578)
			p.AccessibilityModifier()
		}

	}
	{
		p.SetState(581)
		p.IdentifierOrPattern()
	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserQuestionMark:
		{
			p.SetState(582)
			p.Match(TypeScriptParserQuestionMark)
		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserColon {
			{
				p.SetState(583)
				p.TypeAnnotation()
			}

		}

	case TypeScriptParserAssign, TypeScriptParserColon:
		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserColon {
			{
				p.SetState(586)
				p.TypeAnnotation()
			}

		}
		{
			p.SetState(589)
			p.Initializer()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRestParameterContext is an interface to support dynamic dispatch.
type IRestParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRestParameterContext differentiates from other interfaces.
	IsRestParameterContext()
}

type RestParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestParameterContext() *RestParameterContext {
	var p = new(RestParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_restParameter
	return p
}

func (*RestParameterContext) IsRestParameterContext() {}

func NewRestParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestParameterContext {
	var p = new(RestParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_restParameter

	return p
}

func (s *RestParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *RestParameterContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEllipsis, 0)
}

func (s *RestParameterContext) RequiredParameter() IRequiredParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequiredParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequiredParameterContext)
}

func (s *RestParameterContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *RestParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRestParameter(s)
	}
}

func (s *RestParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRestParameter(s)
	}
}

func (p *TypeScriptParser) RestParameter() (localctx IRestParameterContext) {
	this := p
	_ = this

	localctx = NewRestParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, TypeScriptParserRULE_restParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(592)
			p.Match(TypeScriptParserEllipsis)
		}
		{
			p.SetState(593)
			p.RequiredParameter()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(594)
			p.Match(TypeScriptParserEllipsis)
		}
		{
			p.SetState(595)
			p.singleExpression(0)
		}

	}

	return localctx
}

// IConstructSignatureContext is an interface to support dynamic dispatch.
type IConstructSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructSignatureContext differentiates from other interfaces.
	IsConstructSignatureContext()
}

type ConstructSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructSignatureContext() *ConstructSignatureContext {
	var p = new(ConstructSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constructSignature
	return p
}

func (*ConstructSignatureContext) IsConstructSignatureContext() {}

func NewConstructSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructSignatureContext {
	var p = new(ConstructSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_constructSignature

	return p
}

func (s *ConstructSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructSignatureContext) New() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNew, 0)
}

func (s *ConstructSignatureContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ConstructSignatureContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ConstructSignatureContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ConstructSignatureContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ConstructSignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *ConstructSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterConstructSignature(s)
	}
}

func (s *ConstructSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitConstructSignature(s)
	}
}

func (p *TypeScriptParser) ConstructSignature() (localctx IConstructSignatureContext) {
	this := p
	_ = this

	localctx = NewConstructSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, TypeScriptParserRULE_constructSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)
		p.Match(TypeScriptParserNew)
	}
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(599)
			p.TypeParameters()
		}

	}
	{
		p.SetState(602)
		p.Match(TypeScriptParserOpenParen)
	}
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6917529027641147936) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-4607182418800017409) != 0 {
		{
			p.SetState(603)
			p.ParameterList()
		}

	}
	{
		p.SetState(606)
		p.Match(TypeScriptParserCloseParen)
	}
	p.SetState(608)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(607)
			p.TypeAnnotation()
		}

	}

	return localctx
}

// IIndexSignatureContext is an interface to support dynamic dispatch.
type IIndexSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexSignatureContext differentiates from other interfaces.
	IsIndexSignatureContext()
}

type IndexSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexSignatureContext() *IndexSignatureContext {
	var p = new(IndexSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_indexSignature
	return p
}

func (*IndexSignatureContext) IsIndexSignatureContext() {}

func NewIndexSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexSignatureContext {
	var p = new(IndexSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_indexSignature

	return p
}

func (s *IndexSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexSignatureContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *IndexSignatureContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *IndexSignatureContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *IndexSignatureContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *IndexSignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *IndexSignatureContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNUMBER, 0)
}

func (s *IndexSignatureContext) STRING() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSTRING, 0)
}

func (s *IndexSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIndexSignature(s)
	}
}

func (s *IndexSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIndexSignature(s)
	}
}

func (p *TypeScriptParser) IndexSignature() (localctx IIndexSignatureContext) {
	this := p
	_ = this

	localctx = NewIndexSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, TypeScriptParserRULE_indexSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.Match(TypeScriptParserOpenBracket)
	}
	{
		p.SetState(611)
		p.Match(TypeScriptParserIdentifier)
	}
	{
		p.SetState(612)
		p.Match(TypeScriptParserColon)
	}
	{
		p.SetState(613)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TypeScriptParserNUMBER || _la == TypeScriptParserSTRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(614)
		p.Match(TypeScriptParserCloseBracket)
	}
	{
		p.SetState(615)
		p.TypeAnnotation()
	}

	return localctx
}

// IMethodSignatureContext is an interface to support dynamic dispatch.
type IMethodSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodSignatureContext differentiates from other interfaces.
	IsMethodSignatureContext()
}

type MethodSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodSignatureContext() *MethodSignatureContext {
	var p = new(MethodSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_methodSignature
	return p
}

func (*MethodSignatureContext) IsMethodSignatureContext() {}

func NewMethodSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodSignatureContext {
	var p = new(MethodSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_methodSignature

	return p
}

func (s *MethodSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodSignatureContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *MethodSignatureContext) CallSignature() ICallSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSignatureContext)
}

func (s *MethodSignatureContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserQuestionMark, 0)
}

func (s *MethodSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMethodSignature(s)
	}
}

func (s *MethodSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMethodSignature(s)
	}
}

func (p *TypeScriptParser) MethodSignature() (localctx IMethodSignatureContext) {
	this := p
	_ = this

	localctx = NewMethodSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, TypeScriptParserRULE_methodSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.PropertyName()
	}
	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserQuestionMark {
		{
			p.SetState(618)
			p.Match(TypeScriptParserQuestionMark)
		}

	}
	{
		p.SetState(621)
		p.CallSignature()
	}

	return localctx
}

// ITypeAliasDeclarationContext is an interface to support dynamic dispatch.
type ITypeAliasDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeAliasDeclarationContext differentiates from other interfaces.
	IsTypeAliasDeclarationContext()
}

type TypeAliasDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasDeclarationContext() *TypeAliasDeclarationContext {
	var p = new(TypeAliasDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_typeAliasDeclaration
	return p
}

func (*TypeAliasDeclarationContext) IsTypeAliasDeclarationContext() {}

func NewTypeAliasDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasDeclarationContext {
	var p = new(TypeAliasDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_typeAliasDeclaration

	return p
}

func (s *TypeAliasDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasDeclarationContext) Type() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserType, 0)
}

func (s *TypeAliasDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *TypeAliasDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *TypeAliasDeclarationContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeAliasDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *TypeAliasDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *TypeAliasDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeAliasDeclaration(s)
	}
}

func (s *TypeAliasDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeAliasDeclaration(s)
	}
}

func (p *TypeScriptParser) TypeAliasDeclaration() (localctx ITypeAliasDeclarationContext) {
	this := p
	_ = this

	localctx = NewTypeAliasDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, TypeScriptParserRULE_typeAliasDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.Match(TypeScriptParserType)
	}
	{
		p.SetState(624)
		p.Match(TypeScriptParserIdentifier)
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(625)
			p.TypeParameters()
		}

	}
	{
		p.SetState(628)
		p.Match(TypeScriptParserAssign)
	}
	{
		p.SetState(629)
		p.Type_()
	}
	{
		p.SetState(630)
		p.Match(TypeScriptParserSemiColon)
	}

	return localctx
}

// IConstructorDeclarationContext is an interface to support dynamic dispatch.
type IConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorDeclarationContext differentiates from other interfaces.
	IsConstructorDeclarationContext()
}

type ConstructorDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDeclarationContext() *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_constructorDeclaration
	return p
}

func (*ConstructorDeclarationContext) IsConstructorDeclarationContext() {}

func NewConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_constructorDeclaration

	return p
}

func (s *ConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDeclarationContext) Constructor() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserConstructor, 0)
}

func (s *ConstructorDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ConstructorDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ConstructorDeclarationContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *ConstructorDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ConstructorDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *ConstructorDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *ConstructorDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *ConstructorDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *ConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterConstructorDeclaration(s)
	}
}

func (s *ConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitConstructorDeclaration(s)
	}
}

func (p *TypeScriptParser) ConstructorDeclaration() (localctx IConstructorDeclarationContext) {
	this := p
	_ = this

	localctx = NewConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, TypeScriptParserRULE_constructorDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&19) != 0 {
		{
			p.SetState(632)
			p.AccessibilityModifier()
		}

	}
	{
		p.SetState(635)
		p.Match(TypeScriptParserConstructor)
	}
	{
		p.SetState(636)
		p.Match(TypeScriptParserOpenParen)
	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&8388627) != 0 {
		{
			p.SetState(637)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(640)
		p.Match(TypeScriptParserCloseParen)
	}
	p.SetState(646)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(641)
			p.Match(TypeScriptParserOpenBrace)
		}
		{
			p.SetState(642)
			p.FunctionBody()
		}
		{
			p.SetState(643)
			p.Match(TypeScriptParserCloseBrace)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(645)
			p.Match(TypeScriptParserSemiColon)
		}

	}

	return localctx
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_interfaceDeclaration
	return p
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) Interface() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserInterface, 0)
}

func (s *InterfaceDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *InterfaceDeclarationContext) ObjectType() IObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectTypeContext)
}

func (s *InterfaceDeclarationContext) Export() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExport, 0)
}

func (s *InterfaceDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *InterfaceDeclarationContext) InterfaceExtendsClause() IInterfaceExtendsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceExtendsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceExtendsClauseContext)
}

func (s *InterfaceDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (p *TypeScriptParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	this := p
	_ = this

	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, TypeScriptParserRULE_interfaceDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserExport {
		{
			p.SetState(648)
			p.Match(TypeScriptParserExport)
		}

	}
	{
		p.SetState(651)
		p.Match(TypeScriptParserInterface)
	}
	{
		p.SetState(652)
		p.Match(TypeScriptParserIdentifier)
	}
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(653)
			p.TypeParameters()
		}

	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserExtends {
		{
			p.SetState(656)
			p.InterfaceExtendsClause()
		}

	}
	{
		p.SetState(659)
		p.ObjectType()
	}
	p.SetState(661)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(660)
			p.Match(TypeScriptParserSemiColon)
		}

	}

	return localctx
}

// IInterfaceExtendsClauseContext is an interface to support dynamic dispatch.
type IInterfaceExtendsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceExtendsClauseContext differentiates from other interfaces.
	IsInterfaceExtendsClauseContext()
}

type InterfaceExtendsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceExtendsClauseContext() *InterfaceExtendsClauseContext {
	var p = new(InterfaceExtendsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_interfaceExtendsClause
	return p
}

func (*InterfaceExtendsClauseContext) IsInterfaceExtendsClauseContext() {}

func NewInterfaceExtendsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceExtendsClauseContext {
	var p = new(InterfaceExtendsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_interfaceExtendsClause

	return p
}

func (s *InterfaceExtendsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceExtendsClauseContext) Extends() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExtends, 0)
}

func (s *InterfaceExtendsClauseContext) ClassOrInterfaceTypeList() IClassOrInterfaceTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeListContext)
}

func (s *InterfaceExtendsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceExtendsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceExtendsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterInterfaceExtendsClause(s)
	}
}

func (s *InterfaceExtendsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitInterfaceExtendsClause(s)
	}
}

func (p *TypeScriptParser) InterfaceExtendsClause() (localctx IInterfaceExtendsClauseContext) {
	this := p
	_ = this

	localctx = NewInterfaceExtendsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, TypeScriptParserRULE_interfaceExtendsClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(663)
		p.Match(TypeScriptParserExtends)
	}
	{
		p.SetState(664)
		p.ClassOrInterfaceTypeList()
	}

	return localctx
}

// IClassOrInterfaceTypeListContext is an interface to support dynamic dispatch.
type IClassOrInterfaceTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceTypeListContext differentiates from other interfaces.
	IsClassOrInterfaceTypeListContext()
}

type ClassOrInterfaceTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceTypeListContext() *ClassOrInterfaceTypeListContext {
	var p = new(ClassOrInterfaceTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classOrInterfaceTypeList
	return p
}

func (*ClassOrInterfaceTypeListContext) IsClassOrInterfaceTypeListContext() {}

func NewClassOrInterfaceTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceTypeListContext {
	var p = new(ClassOrInterfaceTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classOrInterfaceTypeList

	return p
}

func (s *ClassOrInterfaceTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceTypeListContext) AllTypeReference() []ITypeReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			len++
		}
	}

	tst := make([]ITypeReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeReferenceContext); ok {
			tst[i] = t.(ITypeReferenceContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeListContext) TypeReference(i int) ITypeReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *ClassOrInterfaceTypeListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ClassOrInterfaceTypeListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ClassOrInterfaceTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassOrInterfaceTypeList(s)
	}
}

func (s *ClassOrInterfaceTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassOrInterfaceTypeList(s)
	}
}

func (p *TypeScriptParser) ClassOrInterfaceTypeList() (localctx IClassOrInterfaceTypeListContext) {
	this := p
	_ = this

	localctx = NewClassOrInterfaceTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, TypeScriptParserRULE_classOrInterfaceTypeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.TypeReference()
	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		{
			p.SetState(667)
			p.Match(TypeScriptParserComma)
		}
		{
			p.SetState(668)
			p.TypeReference()
		}

		p.SetState(673)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumDeclaration
	return p
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) Enum() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEnum, 0)
}

func (s *EnumDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *EnumDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *EnumDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *EnumDeclarationContext) Const() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserConst, 0)
}

func (s *EnumDeclarationContext) EnumBody() IEnumBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodyContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEnumDeclaration(s)
	}
}

func (p *TypeScriptParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	this := p
	_ = this

	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, TypeScriptParserRULE_enumDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserConst {
		{
			p.SetState(674)
			p.Match(TypeScriptParserConst)
		}

	}
	{
		p.SetState(677)
		p.Match(TypeScriptParserEnum)
	}
	{
		p.SetState(678)
		p.Match(TypeScriptParserIdentifier)
	}
	{
		p.SetState(679)
		p.Match(TypeScriptParserOpenBrace)
	}
	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&-72057594037927935) != 0 || (int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-4611615649683210241) != 0 {
		{
			p.SetState(680)
			p.EnumBody()
		}

	}
	{
		p.SetState(683)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// IEnumBodyContext is an interface to support dynamic dispatch.
type IEnumBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumBodyContext differentiates from other interfaces.
	IsEnumBodyContext()
}

type EnumBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyContext() *EnumBodyContext {
	var p = new(EnumBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumBody
	return p
}

func (*EnumBodyContext) IsEnumBodyContext() {}

func NewEnumBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyContext {
	var p = new(EnumBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_enumBody

	return p
}

func (s *EnumBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyContext) EnumMemberList() IEnumMemberListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMemberListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMemberListContext)
}

func (s *EnumBodyContext) Comma() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, 0)
}

func (s *EnumBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEnumBody(s)
	}
}

func (s *EnumBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEnumBody(s)
	}
}

func (p *TypeScriptParser) EnumBody() (localctx IEnumBodyContext) {
	this := p
	_ = this

	localctx = NewEnumBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, TypeScriptParserRULE_enumBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.EnumMemberList()
	}
	p.SetState(687)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserComma {
		{
			p.SetState(686)
			p.Match(TypeScriptParserComma)
		}

	}

	return localctx
}

// IEnumMemberListContext is an interface to support dynamic dispatch.
type IEnumMemberListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumMemberListContext differentiates from other interfaces.
	IsEnumMemberListContext()
}

type EnumMemberListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMemberListContext() *EnumMemberListContext {
	var p = new(EnumMemberListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumMemberList
	return p
}

func (*EnumMemberListContext) IsEnumMemberListContext() {}

func NewEnumMemberListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMemberListContext {
	var p = new(EnumMemberListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_enumMemberList

	return p
}

func (s *EnumMemberListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMemberListContext) AllEnumMember() []IEnumMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumMemberContext); ok {
			len++
		}
	}

	tst := make([]IEnumMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumMemberContext); ok {
			tst[i] = t.(IEnumMemberContext)
			i++
		}
	}

	return tst
}

func (s *EnumMemberListContext) EnumMember(i int) IEnumMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMemberContext)
}

func (s *EnumMemberListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *EnumMemberListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *EnumMemberListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMemberListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMemberListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEnumMemberList(s)
	}
}

func (s *EnumMemberListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEnumMemberList(s)
	}
}

func (p *TypeScriptParser) EnumMemberList() (localctx IEnumMemberListContext) {
	this := p
	_ = this

	localctx = NewEnumMemberListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, TypeScriptParserRULE_enumMemberList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(689)
		p.EnumMember()
	}
	p.SetState(694)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(690)
				p.Match(TypeScriptParserComma)
			}
			{
				p.SetState(691)
				p.EnumMember()
			}

		}
		p.SetState(696)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumMemberContext is an interface to support dynamic dispatch.
type IEnumMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumMemberContext differentiates from other interfaces.
	IsEnumMemberContext()
}

type EnumMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMemberContext() *EnumMemberContext {
	var p = new(EnumMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_enumMember
	return p
}

func (*EnumMemberContext) IsEnumMemberContext() {}

func NewEnumMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMemberContext {
	var p = new(EnumMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_enumMember

	return p
}

func (s *EnumMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMemberContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *EnumMemberContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *EnumMemberContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *EnumMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEnumMember(s)
	}
}

func (s *EnumMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEnumMember(s)
	}
}

func (p *TypeScriptParser) EnumMember() (localctx IEnumMemberContext) {
	this := p
	_ = this

	localctx = NewEnumMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, TypeScriptParserRULE_enumMember)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(697)
		p.PropertyName()
	}
	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAssign {
		{
			p.SetState(698)
			p.Match(TypeScriptParserAssign)
		}
		{
			p.SetState(699)
			p.singleExpression(0)
		}

	}

	return localctx
}

// INamespaceDeclarationContext is an interface to support dynamic dispatch.
type INamespaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceDeclarationContext differentiates from other interfaces.
	IsNamespaceDeclarationContext()
}

type NamespaceDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceDeclarationContext() *NamespaceDeclarationContext {
	var p = new(NamespaceDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_namespaceDeclaration
	return p
}

func (*NamespaceDeclarationContext) IsNamespaceDeclarationContext() {}

func NewNamespaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceDeclarationContext {
	var p = new(NamespaceDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_namespaceDeclaration

	return p
}

func (s *NamespaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceDeclarationContext) Namespace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNamespace, 0)
}

func (s *NamespaceDeclarationContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *NamespaceDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *NamespaceDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *NamespaceDeclarationContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *NamespaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterNamespaceDeclaration(s)
	}
}

func (s *NamespaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitNamespaceDeclaration(s)
	}
}

func (p *TypeScriptParser) NamespaceDeclaration() (localctx INamespaceDeclarationContext) {
	this := p
	_ = this

	localctx = NewNamespaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, TypeScriptParserRULE_namespaceDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(TypeScriptParserNamespace)
	}
	{
		p.SetState(703)
		p.NamespaceName()
	}
	{
		p.SetState(704)
		p.Match(TypeScriptParserOpenBrace)
	}
	p.SetState(706)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(705)
			p.StatementList()
		}

	}
	{
		p.SetState(708)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// INamespaceNameContext is an interface to support dynamic dispatch.
type INamespaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceNameContext differentiates from other interfaces.
	IsNamespaceNameContext()
}

type NamespaceNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNameContext() *NamespaceNameContext {
	var p = new(NamespaceNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_namespaceName
	return p
}

func (*NamespaceNameContext) IsNamespaceNameContext() {}

func NewNamespaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNameContext {
	var p = new(NamespaceNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_namespaceName

	return p
}

func (s *NamespaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceNameContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserIdentifier)
}

func (s *NamespaceNameContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, i)
}

func (s *NamespaceNameContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserDot)
}

func (s *NamespaceNameContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDot, i)
}

func (s *NamespaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterNamespaceName(s)
	}
}

func (s *NamespaceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitNamespaceName(s)
	}
}

func (p *TypeScriptParser) NamespaceName() (localctx INamespaceNameContext) {
	this := p
	_ = this

	localctx = NewNamespaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, TypeScriptParserRULE_namespaceName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.Match(TypeScriptParserIdentifier)
	}
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(712)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == TypeScriptParserDot {
				{
					p.SetState(711)
					p.Match(TypeScriptParserDot)
				}

				p.SetState(714)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(716)
				p.Match(TypeScriptParserIdentifier)
			}

		}
		p.SetState(721)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())
	}

	return localctx
}

// IImportAliasDeclarationContext is an interface to support dynamic dispatch.
type IImportAliasDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportAliasDeclarationContext differentiates from other interfaces.
	IsImportAliasDeclarationContext()
}

type ImportAliasDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportAliasDeclarationContext() *ImportAliasDeclarationContext {
	var p = new(ImportAliasDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_importAliasDeclaration
	return p
}

func (*ImportAliasDeclarationContext) IsImportAliasDeclarationContext() {}

func NewImportAliasDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAliasDeclarationContext {
	var p = new(ImportAliasDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_importAliasDeclaration

	return p
}

func (s *ImportAliasDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAliasDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ImportAliasDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *ImportAliasDeclarationContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *ImportAliasDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *ImportAliasDeclarationContext) Require() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRequire, 0)
}

func (s *ImportAliasDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ImportAliasDeclarationContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStringLiteral, 0)
}

func (s *ImportAliasDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ImportAliasDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAliasDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAliasDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterImportAliasDeclaration(s)
	}
}

func (s *ImportAliasDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitImportAliasDeclaration(s)
	}
}

func (p *TypeScriptParser) ImportAliasDeclaration() (localctx IImportAliasDeclarationContext) {
	this := p
	_ = this

	localctx = NewImportAliasDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, TypeScriptParserRULE_importAliasDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(734)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(722)
			p.Match(TypeScriptParserIdentifier)
		}
		{
			p.SetState(723)
			p.Match(TypeScriptParserAssign)
		}
		{
			p.SetState(724)
			p.NamespaceName()
		}
		{
			p.SetState(725)
			p.Match(TypeScriptParserSemiColon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(727)
			p.Match(TypeScriptParserIdentifier)
		}
		{
			p.SetState(728)
			p.Match(TypeScriptParserAssign)
		}
		{
			p.SetState(729)
			p.Match(TypeScriptParserRequire)
		}
		{
			p.SetState(730)
			p.Match(TypeScriptParserOpenParen)
		}
		{
			p.SetState(731)
			p.Match(TypeScriptParserStringLiteral)
		}
		{
			p.SetState(732)
			p.Match(TypeScriptParserCloseParen)
		}
		{
			p.SetState(733)
			p.Match(TypeScriptParserSemiColon)
		}

	}

	return localctx
}

// IImportAllContext is an interface to support dynamic dispatch.
type IImportAllContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportAllContext differentiates from other interfaces.
	IsImportAllContext()
}

type ImportAllContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportAllContext() *ImportAllContext {
	var p = new(ImportAllContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_importAll
	return p
}

func (*ImportAllContext) IsImportAllContext() {}

func NewImportAllContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAllContext {
	var p = new(ImportAllContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_importAll

	return p
}

func (s *ImportAllContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAllContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStringLiteral, 0)
}

func (s *ImportAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAllContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterImportAll(s)
	}
}

func (s *ImportAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitImportAll(s)
	}
}

func (p *TypeScriptParser) ImportAll() (localctx IImportAllContext) {
	this := p
	_ = this

	localctx = NewImportAllContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, TypeScriptParserRULE_importAll)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		p.Match(TypeScriptParserStringLiteral)
	}

	return localctx
}

// IDecoratorListContext is an interface to support dynamic dispatch.
type IDecoratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorListContext differentiates from other interfaces.
	IsDecoratorListContext()
}

type DecoratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorListContext() *DecoratorListContext {
	var p = new(DecoratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decoratorList
	return p
}

func (*DecoratorListContext) IsDecoratorListContext() {}

func NewDecoratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorListContext {
	var p = new(DecoratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_decoratorList

	return p
}

func (s *DecoratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorListContext) AllDecorator() []IDecoratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecoratorContext); ok {
			len++
		}
	}

	tst := make([]IDecoratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecoratorContext); ok {
			tst[i] = t.(IDecoratorContext)
			i++
		}
	}

	return tst
}

func (s *DecoratorListContext) Decorator(i int) IDecoratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorContext)
}

func (s *DecoratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDecoratorList(s)
	}
}

func (s *DecoratorListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDecoratorList(s)
	}
}

func (p *TypeScriptParser) DecoratorList() (localctx IDecoratorListContext) {
	this := p
	_ = this

	localctx = NewDecoratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, TypeScriptParserRULE_decoratorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == TypeScriptParserAt {
		{
			p.SetState(738)
			p.Decorator()
		}

		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDecoratorContext is an interface to support dynamic dispatch.
type IDecoratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorContext differentiates from other interfaces.
	IsDecoratorContext()
}

type DecoratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorContext() *DecoratorContext {
	var p = new(DecoratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decorator
	return p
}

func (*DecoratorContext) IsDecoratorContext() {}

func NewDecoratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorContext {
	var p = new(DecoratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_decorator

	return p
}

func (s *DecoratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorContext) At() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAt, 0)
}

func (s *DecoratorContext) DecoratorMemberExpression() IDecoratorMemberExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorMemberExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorMemberExpressionContext)
}

func (s *DecoratorContext) DecoratorCallExpression() IDecoratorCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorCallExpressionContext)
}

func (s *DecoratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDecorator(s)
	}
}

func (s *DecoratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDecorator(s)
	}
}

func (p *TypeScriptParser) Decorator() (localctx IDecoratorContext) {
	this := p
	_ = this

	localctx = NewDecoratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, TypeScriptParserRULE_decorator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Match(TypeScriptParserAt)
	}
	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(744)
			p.decoratorMemberExpression(0)
		}

	case 2:
		{
			p.SetState(745)
			p.DecoratorCallExpression()
		}

	}

	return localctx
}

// IDecoratorMemberExpressionContext is an interface to support dynamic dispatch.
type IDecoratorMemberExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorMemberExpressionContext differentiates from other interfaces.
	IsDecoratorMemberExpressionContext()
}

type DecoratorMemberExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorMemberExpressionContext() *DecoratorMemberExpressionContext {
	var p = new(DecoratorMemberExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decoratorMemberExpression
	return p
}

func (*DecoratorMemberExpressionContext) IsDecoratorMemberExpressionContext() {}

func NewDecoratorMemberExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorMemberExpressionContext {
	var p = new(DecoratorMemberExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_decoratorMemberExpression

	return p
}

func (s *DecoratorMemberExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorMemberExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *DecoratorMemberExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *DecoratorMemberExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *DecoratorMemberExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *DecoratorMemberExpressionContext) DecoratorMemberExpression() IDecoratorMemberExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorMemberExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorMemberExpressionContext)
}

func (s *DecoratorMemberExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDot, 0)
}

func (s *DecoratorMemberExpressionContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *DecoratorMemberExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorMemberExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorMemberExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDecoratorMemberExpression(s)
	}
}

func (s *DecoratorMemberExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDecoratorMemberExpression(s)
	}
}

func (p *TypeScriptParser) DecoratorMemberExpression() (localctx IDecoratorMemberExpressionContext) {
	return p.decoratorMemberExpression(0)
}

func (p *TypeScriptParser) decoratorMemberExpression(_p int) (localctx IDecoratorMemberExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewDecoratorMemberExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDecoratorMemberExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 114
	p.EnterRecursionRule(localctx, 114, TypeScriptParserRULE_decoratorMemberExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(754)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserIdentifier:
		{
			p.SetState(749)
			p.Match(TypeScriptParserIdentifier)
		}

	case TypeScriptParserOpenParen:
		{
			p.SetState(750)
			p.Match(TypeScriptParserOpenParen)
		}
		{
			p.SetState(751)
			p.singleExpression(0)
		}
		{
			p.SetState(752)
			p.Match(TypeScriptParserCloseParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewDecoratorMemberExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_decoratorMemberExpression)
			p.SetState(756)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(757)
				p.Match(TypeScriptParserDot)
			}
			{
				p.SetState(758)
				p.IdentifierName()
			}

		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())
	}

	return localctx
}

// IDecoratorCallExpressionContext is an interface to support dynamic dispatch.
type IDecoratorCallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorCallExpressionContext differentiates from other interfaces.
	IsDecoratorCallExpressionContext()
}

type DecoratorCallExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorCallExpressionContext() *DecoratorCallExpressionContext {
	var p = new(DecoratorCallExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_decoratorCallExpression
	return p
}

func (*DecoratorCallExpressionContext) IsDecoratorCallExpressionContext() {}

func NewDecoratorCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorCallExpressionContext {
	var p = new(DecoratorCallExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_decoratorCallExpression

	return p
}

func (s *DecoratorCallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorCallExpressionContext) DecoratorMemberExpression() IDecoratorMemberExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorMemberExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorMemberExpressionContext)
}

func (s *DecoratorCallExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *DecoratorCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorCallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDecoratorCallExpression(s)
	}
}

func (s *DecoratorCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDecoratorCallExpression(s)
	}
}

func (p *TypeScriptParser) DecoratorCallExpression() (localctx IDecoratorCallExpressionContext) {
	this := p
	_ = this

	localctx = NewDecoratorCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, TypeScriptParserRULE_decoratorCallExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.decoratorMemberExpression(0)
	}
	{
		p.SetState(765)
		p.Arguments()
	}

	return localctx
}

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_program
	return p
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEOF, 0)
}

func (s *ProgramContext) SourceElements() ISourceElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (p *TypeScriptParser) Program() (localctx IProgramContext) {
	this := p
	_ = this

	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, TypeScriptParserRULE_program)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(768)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(767)
			p.SourceElements()
		}

	}
	{
		p.SetState(770)
		p.Match(TypeScriptParserEOF)
	}

	return localctx
}

// ISourceElementContext is an interface to support dynamic dispatch.
type ISourceElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceElementContext differentiates from other interfaces.
	IsSourceElementContext()
}

type SourceElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementContext() *SourceElementContext {
	var p = new(SourceElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_sourceElement
	return p
}

func (*SourceElementContext) IsSourceElementContext() {}

func NewSourceElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementContext {
	var p = new(SourceElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_sourceElement

	return p
}

func (s *SourceElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SourceElementContext) Export() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExport, 0)
}

func (s *SourceElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSourceElement(s)
	}
}

func (s *SourceElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSourceElement(s)
	}
}

func (p *TypeScriptParser) SourceElement() (localctx ISourceElementContext) {
	this := p
	_ = this

	localctx = NewSourceElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, TypeScriptParserRULE_sourceElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(773)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(772)
			p.Match(TypeScriptParserExport)
		}

	}
	{
		p.SetState(775)
		p.Statement()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *StatementContext) ImportStatement() IImportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *StatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *StatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *StatementContext) AbstractDeclaration() IAbstractDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclarationContext)
}

func (s *StatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *StatementContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *StatementContext) NamespaceDeclaration() INamespaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceDeclarationContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) IterationStatement() IIterationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterationStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) YieldStatement() IYieldStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *StatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StatementContext) LabelledStatement() ILabelledStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelledStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelledStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) DebuggerStatement() IDebuggerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDebuggerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDebuggerStatementContext)
}

func (s *StatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *StatementContext) ArrowFunctionDeclaration() IArrowFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionDeclarationContext)
}

func (s *StatementContext) GeneratorFunctionDeclaration() IGeneratorFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratorFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratorFunctionDeclarationContext)
}

func (s *StatementContext) TypeAliasDeclaration() ITypeAliasDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasDeclarationContext)
}

func (s *StatementContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) Export() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExport, 0)
}

func (s *StatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *TypeScriptParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, TypeScriptParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(777)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(778)
			p.VariableStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(779)
			p.ImportStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(780)
			p.ExportStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(781)
			p.EmptyStatement_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(782)
			p.AbstractDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(783)
			p.ClassDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(784)
			p.InterfaceDeclaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(785)
			p.NamespaceDeclaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(786)
			p.IfStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(787)
			p.IterationStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(788)
			p.ContinueStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(789)
			p.BreakStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(790)
			p.ReturnStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(791)
			p.YieldStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(792)
			p.WithStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(793)
			p.LabelledStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(794)
			p.SwitchStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(795)
			p.ThrowStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(796)
			p.TryStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(797)
			p.DebuggerStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(798)
			p.FunctionDeclaration()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(799)
			p.ArrowFunctionDeclaration()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(800)
			p.GeneratorFunctionDeclaration()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(801)
			p.TypeAliasDeclaration()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(802)
			p.EnumDeclaration()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(803)
			p.ExpressionStatement()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(804)
			p.Match(TypeScriptParserExport)
		}
		{
			p.SetState(805)
			p.Statement()
		}

	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *BlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *BlockContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *TypeScriptParser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, TypeScriptParserRULE_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(808)
		p.Match(TypeScriptParserOpenBrace)
	}
	p.SetState(810)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(809)
			p.StatementList()
		}

	}
	{
		p.SetState(812)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// IStatementListContext is an interface to support dynamic dispatch.
type IStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementListContext differentiates from other interfaces.
	IsStatementListContext()
}

type StatementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementListContext() *StatementListContext {
	var p = new(StatementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_statementList
	return p
}

func (*StatementListContext) IsStatementListContext() {}

func NewStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementListContext {
	var p = new(StatementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_statementList

	return p
}

func (s *StatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementListContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementListContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterStatementList(s)
	}
}

func (s *StatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitStatementList(s)
	}
}

func (p *TypeScriptParser) StatementList() (localctx IStatementListContext) {
	this := p
	_ = this

	localctx = NewStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, TypeScriptParserRULE_statementList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(815)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(814)
				p.Statement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(817)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())
	}

	return localctx
}

// IAbstractDeclarationContext is an interface to support dynamic dispatch.
type IAbstractDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstractDeclarationContext differentiates from other interfaces.
	IsAbstractDeclarationContext()
}

type AbstractDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractDeclarationContext() *AbstractDeclarationContext {
	var p = new(AbstractDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_abstractDeclaration
	return p
}

func (*AbstractDeclarationContext) IsAbstractDeclarationContext() {}

func NewAbstractDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractDeclarationContext {
	var p = new(AbstractDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_abstractDeclaration

	return p
}

func (s *AbstractDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractDeclarationContext) Abstract() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAbstract, 0)
}

func (s *AbstractDeclarationContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *AbstractDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *AbstractDeclarationContext) CallSignature() ICallSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSignatureContext)
}

func (s *AbstractDeclarationContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *AbstractDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAbstractDeclaration(s)
	}
}

func (s *AbstractDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAbstractDeclaration(s)
	}
}

func (p *TypeScriptParser) AbstractDeclaration() (localctx IAbstractDeclarationContext) {
	this := p
	_ = this

	localctx = NewAbstractDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, TypeScriptParserRULE_abstractDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(819)
		p.Match(TypeScriptParserAbstract)
	}
	p.SetState(823)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(820)
			p.Match(TypeScriptParserIdentifier)
		}
		{
			p.SetState(821)
			p.CallSignature()
		}

	case 2:
		{
			p.SetState(822)
			p.VariableStatement()
		}

	}
	{
		p.SetState(825)
		p.Eos()
	}

	return localctx
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_importStatement
	return p
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) Import() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserImport, 0)
}

func (s *ImportStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ImportStatementContext) ImportFromBlock() IImportFromBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromBlockContext)
}

func (s *ImportStatementContext) ImportAliasDeclaration() IImportAliasDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportAliasDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportAliasDeclarationContext)
}

func (s *ImportStatementContext) ImportAll() IImportAllContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportAllContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportAllContext)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterImportStatement(s)
	}
}

func (s *ImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitImportStatement(s)
	}
}

func (p *TypeScriptParser) ImportStatement() (localctx IImportStatementContext) {
	this := p
	_ = this

	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, TypeScriptParserRULE_importStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		p.Match(TypeScriptParserImport)
	}
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(828)
			p.ImportFromBlock()
		}

	case 2:
		{
			p.SetState(829)
			p.ImportAliasDeclaration()
		}

	case 3:
		{
			p.SetState(830)
			p.ImportAll()
		}

	}
	{
		p.SetState(833)
		p.Eos()
	}

	return localctx
}

// IImportFromBlockContext is an interface to support dynamic dispatch.
type IImportFromBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportFromBlockContext differentiates from other interfaces.
	IsImportFromBlockContext()
}

type ImportFromBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportFromBlockContext() *ImportFromBlockContext {
	var p = new(ImportFromBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_importFromBlock
	return p
}

func (*ImportFromBlockContext) IsImportFromBlockContext() {}

func NewImportFromBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportFromBlockContext {
	var p = new(ImportFromBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_importFromBlock

	return p
}

func (s *ImportFromBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportFromBlockContext) From() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFrom, 0)
}

func (s *ImportFromBlockContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStringLiteral, 0)
}

func (s *ImportFromBlockContext) Dollar() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDollar, 0)
}

func (s *ImportFromBlockContext) Lodash() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLodash, 0)
}

func (s *ImportFromBlockContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *ImportFromBlockContext) MultipleImportStatement() IMultipleImportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleImportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleImportStatementContext)
}

func (s *ImportFromBlockContext) AllIdentifierName() []IIdentifierNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierNameContext); ok {
			tst[i] = t.(IIdentifierNameContext)
			i++
		}
	}

	return tst
}

func (s *ImportFromBlockContext) IdentifierName(i int) IIdentifierNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *ImportFromBlockContext) As() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAs, 0)
}

func (s *ImportFromBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportFromBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterImportFromBlock(s)
	}
}

func (s *ImportFromBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitImportFromBlock(s)
	}
}

func (p *TypeScriptParser) ImportFromBlock() (localctx IImportFromBlockContext) {
	this := p
	_ = this

	localctx = NewImportFromBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, TypeScriptParserRULE_importFromBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(835)
			p.Match(TypeScriptParserDollar)
		}

	case 2:
		{
			p.SetState(836)
			p.Match(TypeScriptParserLodash)
		}

	case 3:
		{
			p.SetState(837)
			p.Match(TypeScriptParserMultiply)
		}

	case 4:
		{
			p.SetState(838)
			p.MultipleImportStatement()
		}

	case 5:
		{
			p.SetState(839)
			p.IdentifierName()
		}

	}
	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAs {
		{
			p.SetState(842)
			p.Match(TypeScriptParserAs)
		}
		{
			p.SetState(843)
			p.IdentifierName()
		}

	}
	{
		p.SetState(846)
		p.Match(TypeScriptParserFrom)
	}
	{
		p.SetState(847)
		p.Match(TypeScriptParserStringLiteral)
	}

	return localctx
}

// IMultipleImportStatementContext is an interface to support dynamic dispatch.
type IMultipleImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultipleImportStatementContext differentiates from other interfaces.
	IsMultipleImportStatementContext()
}

type MultipleImportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipleImportStatementContext() *MultipleImportStatementContext {
	var p = new(MultipleImportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_multipleImportStatement
	return p
}

func (*MultipleImportStatementContext) IsMultipleImportStatementContext() {}

func NewMultipleImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleImportStatementContext {
	var p = new(MultipleImportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_multipleImportStatement

	return p
}

func (s *MultipleImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleImportStatementContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *MultipleImportStatementContext) AllIdentifierName() []IIdentifierNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierNameContext); ok {
			tst[i] = t.(IIdentifierNameContext)
			i++
		}
	}

	return tst
}

func (s *MultipleImportStatementContext) IdentifierName(i int) IIdentifierNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *MultipleImportStatementContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *MultipleImportStatementContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *MultipleImportStatementContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *MultipleImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMultipleImportStatement(s)
	}
}

func (s *MultipleImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMultipleImportStatement(s)
	}
}

func (p *TypeScriptParser) MultipleImportStatement() (localctx IMultipleImportStatementContext) {
	this := p
	_ = this

	localctx = NewMultipleImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, TypeScriptParserRULE_multipleImportStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(852)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserNullLiteral || _la == TypeScriptParserBooleanLiteral || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-9223231299366420481) != 0 {
		{
			p.SetState(849)
			p.IdentifierName()
		}
		{
			p.SetState(850)
			p.Match(TypeScriptParserComma)
		}

	}
	{
		p.SetState(854)
		p.Match(TypeScriptParserOpenBrace)
	}
	{
		p.SetState(855)
		p.IdentifierName()
	}
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == TypeScriptParserComma {
		{
			p.SetState(856)
			p.Match(TypeScriptParserComma)
		}
		{
			p.SetState(857)
			p.IdentifierName()
		}

		p.SetState(862)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(863)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_exportStatement
	return p
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) Export() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExport, 0)
}

func (s *ExportStatementContext) ImportFromBlock() IImportFromBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromBlockContext)
}

func (s *ExportStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExportStatementContext) Default() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDefault, 0)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterExportStatement(s)
	}
}

func (s *ExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitExportStatement(s)
	}
}

func (p *TypeScriptParser) ExportStatement() (localctx IExportStatementContext) {
	this := p
	_ = this

	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, TypeScriptParserRULE_exportStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(865)
		p.Match(TypeScriptParserExport)
	}
	p.SetState(867)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(866)
			p.Match(TypeScriptParserDefault)
		}

	}
	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(869)
			p.ImportFromBlock()
		}

	case 2:
		{
			p.SetState(870)
			p.Statement()
		}

	}

	return localctx
}

// IVariableStatementContext is an interface to support dynamic dispatch.
type IVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableStatementContext differentiates from other interfaces.
	IsVariableStatementContext()
}

type VariableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableStatementContext() *VariableStatementContext {
	var p = new(VariableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_variableStatement
	return p
}

func (*VariableStatementContext) IsVariableStatementContext() {}

func NewVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableStatementContext {
	var p = new(VariableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_variableStatement

	return p
}

func (s *VariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableStatementContext) BindingPattern() IBindingPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingPatternContext)
}

func (s *VariableStatementContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *VariableStatementContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *VariableStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *VariableStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *VariableStatementContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *VariableStatementContext) VarModifier() IVarModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *VariableStatementContext) ReadOnly() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReadOnly, 0)
}

func (s *VariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterVariableStatement(s)
	}
}

func (s *VariableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitVariableStatement(s)
	}
}

func (p *TypeScriptParser) VariableStatement() (localctx IVariableStatementContext) {
	this := p
	_ = this

	localctx = NewVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, TypeScriptParserRULE_variableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(873)
			p.BindingPattern()
		}
		p.SetState(875)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserColon {
			{
				p.SetState(874)
				p.TypeAnnotation()
			}

		}
		{
			p.SetState(877)
			p.Initializer()
		}
		p.SetState(879)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(878)
				p.Match(TypeScriptParserSemiColon)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&19) != 0 {
			{
				p.SetState(881)
				p.AccessibilityModifier()
			}

		}
		p.SetState(885)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&4429185025) != 0 {
			{
				p.SetState(884)
				p.VarModifier()
			}

		}
		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserReadOnly {
			{
				p.SetState(887)
				p.Match(TypeScriptParserReadOnly)
			}

		}
		{
			p.SetState(890)
			p.VariableDeclarationList()
		}
		p.SetState(892)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(891)
				p.Match(TypeScriptParserSemiColon)
			}

		}

	}

	return localctx
}

// IVariableDeclarationListContext is an interface to support dynamic dispatch.
type IVariableDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationListContext differentiates from other interfaces.
	IsVariableDeclarationListContext()
}

type VariableDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationListContext() *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_variableDeclarationList
	return p
}

func (*VariableDeclarationListContext) IsVariableDeclarationListContext() {}

func NewVariableDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_variableDeclarationList

	return p
}

func (s *VariableDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationListContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationListContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *VariableDeclarationListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *VariableDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitVariableDeclarationList(s)
	}
}

func (p *TypeScriptParser) VariableDeclarationList() (localctx IVariableDeclarationListContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, TypeScriptParserRULE_variableDeclarationList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(896)
		p.VariableDeclaration()
	}
	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(897)
				p.Match(TypeScriptParserComma)
			}
			{
				p.SetState(898)
				p.VariableDeclaration()
			}

		}
		p.SetState(903)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())
	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *VariableDeclarationContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *VariableDeclarationContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VariableDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *VariableDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *TypeScriptParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, TypeScriptParserRULE_variableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(904)
		p.Assignable()
	}
	p.SetState(906)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(905)
			p.TypeAnnotation()
		}

	}
	p.SetState(909)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(908)
			p.singleExpression(0)
		}

	}
	p.SetState(916)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(911)
			p.Match(TypeScriptParserAssign)
		}
		p.SetState(913)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(912)
				p.TypeParameters()
			}

		}
		{
			p.SetState(915)
			p.singleExpression(0)
		}

	}

	return localctx
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_emptyStatement_
	return p
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (p *TypeScriptParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	this := p
	_ = this

	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, TypeScriptParserRULE_emptyStatement_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(918)
		p.Match(TypeScriptParserSemiColon)
	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ExpressionStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (p *TypeScriptParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	this := p
	_ = this

	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, TypeScriptParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(920)

	if !(p.notOpenBraceAndNotFunction()) {
		panic(antlr.NewFailedPredicateException(p, "p.notOpenBraceAndNotFunction()", ""))
	}
	{
		p.SetState(921)
		p.ExpressionSequence()
	}
	p.SetState(923)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(922)
			p.Match(TypeScriptParserSemiColon)
		}

	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) If() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIf, 0)
}

func (s *IfStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *IfStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *IfStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserElse, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *TypeScriptParser) IfStatement() (localctx IIfStatementContext) {
	this := p
	_ = this

	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, TypeScriptParserRULE_ifStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(925)
		p.Match(TypeScriptParserIf)
	}
	{
		p.SetState(926)
		p.Match(TypeScriptParserOpenParen)
	}
	{
		p.SetState(927)
		p.ExpressionSequence()
	}
	{
		p.SetState(928)
		p.Match(TypeScriptParserCloseParen)
	}
	{
		p.SetState(929)
		p.Statement()
	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(930)
			p.Match(TypeScriptParserElse)
		}
		{
			p.SetState(931)
			p.Statement()
		}

	}

	return localctx
}

// IIterationStatementContext is an interface to support dynamic dispatch.
type IIterationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIterationStatementContext differentiates from other interfaces.
	IsIterationStatementContext()
}

type IterationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterationStatementContext() *IterationStatementContext {
	var p = new(IterationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_iterationStatement
	return p
}

func (*IterationStatementContext) IsIterationStatementContext() {}

func NewIterationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterationStatementContext {
	var p = new(IterationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_iterationStatement

	return p
}

func (s *IterationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterationStatementContext) CopyFrom(ctx *IterationStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IterationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DoStatementContext struct {
	*IterationStatementContext
}

func NewDoStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoStatementContext {
	var p = new(DoStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDo, 0)
}

func (s *DoStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoStatementContext) While() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserWhile, 0)
}

func (s *DoStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *DoStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *DoStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *DoStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

type ForVarStatementContext struct {
	*IterationStatementContext
}

func NewForVarStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForVarStatementContext {
	var p = new(ForVarStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForVarStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForVarStatementContext) For() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFor, 0)
}

func (s *ForVarStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ForVarStatementContext) VarModifier() IVarModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *ForVarStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *ForVarStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserSemiColon)
}

func (s *ForVarStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, i)
}

func (s *ForVarStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ForVarStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForVarStatementContext) AllExpressionSequence() []IExpressionSequenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			len++
		}
	}

	tst := make([]IExpressionSequenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionSequenceContext); ok {
			tst[i] = t.(IExpressionSequenceContext)
			i++
		}
	}

	return tst
}

func (s *ForVarStatementContext) ExpressionSequence(i int) IExpressionSequenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForVarStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterForVarStatement(s)
	}
}

func (s *ForVarStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitForVarStatement(s)
	}
}

type ForVarInStatementContext struct {
	*IterationStatementContext
}

func NewForVarInStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForVarInStatementContext {
	var p = new(ForVarInStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForVarInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForVarInStatementContext) For() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFor, 0)
}

func (s *ForVarInStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ForVarInStatementContext) VarModifier() IVarModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *ForVarInStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *ForVarInStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForVarInStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ForVarInStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForVarInStatementContext) In() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIn, 0)
}

func (s *ForVarInStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ForVarInStatementContext) Await() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAwait, 0)
}

func (s *ForVarInStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterForVarInStatement(s)
	}
}

func (s *ForVarInStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitForVarInStatement(s)
	}
}

type WhileStatementContext struct {
	*IterationStatementContext
}

func NewWhileStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserWhile, 0)
}

func (s *WhileStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *WhileStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WhileStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

type ForStatementContext struct {
	*IterationStatementContext
}

func NewForStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForStatementContext {
	var p = new(ForStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) For() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFor, 0)
}

func (s *ForStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ForStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserSemiColon)
}

func (s *ForStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, i)
}

func (s *ForStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) AllExpressionSequence() []IExpressionSequenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			len++
		}
	}

	tst := make([]IExpressionSequenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionSequenceContext); ok {
			tst[i] = t.(IExpressionSequenceContext)
			i++
		}
	}

	return tst
}

func (s *ForStatementContext) ExpressionSequence(i int) IExpressionSequenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

type ForInStatementContext struct {
	*IterationStatementContext
}

func NewForInStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForInStatementContext {
	var p = new(ForInStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInStatementContext) For() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFor, 0)
}

func (s *ForInStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ForInStatementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForInStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForInStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ForInStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForInStatementContext) In() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIn, 0)
}

func (s *ForInStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ForInStatementContext) Await() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAwait, 0)
}

func (s *ForInStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterForInStatement(s)
	}
}

func (s *ForInStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitForInStatement(s)
	}
}

func (p *TypeScriptParser) IterationStatement() (localctx IIterationStatementContext) {
	this := p
	_ = this

	localctx = NewIterationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, TypeScriptParserRULE_iterationStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDoStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(934)
			p.Match(TypeScriptParserDo)
		}
		{
			p.SetState(935)
			p.Statement()
		}
		{
			p.SetState(936)
			p.Match(TypeScriptParserWhile)
		}
		{
			p.SetState(937)
			p.Match(TypeScriptParserOpenParen)
		}
		{
			p.SetState(938)
			p.ExpressionSequence()
		}
		{
			p.SetState(939)
			p.Match(TypeScriptParserCloseParen)
		}
		{
			p.SetState(940)
			p.Eos()
		}

	case 2:
		localctx = NewWhileStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(942)
			p.Match(TypeScriptParserWhile)
		}
		{
			p.SetState(943)
			p.Match(TypeScriptParserOpenParen)
		}
		{
			p.SetState(944)
			p.ExpressionSequence()
		}
		{
			p.SetState(945)
			p.Match(TypeScriptParserCloseParen)
		}
		{
			p.SetState(946)
			p.Statement()
		}

	case 3:
		localctx = NewForStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(948)
			p.Match(TypeScriptParserFor)
		}
		{
			p.SetState(949)
			p.Match(TypeScriptParserOpenParen)
		}
		p.SetState(951)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305842974837439824) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2251799813685247) != 0 || (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&7) != 0 {
			{
				p.SetState(950)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(953)
			p.Match(TypeScriptParserSemiColon)
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305842974837439824) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2251799813685247) != 0 || (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&7) != 0 {
			{
				p.SetState(954)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(957)
			p.Match(TypeScriptParserSemiColon)
		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305842974837439824) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2251799813685247) != 0 || (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&7) != 0 {
			{
				p.SetState(958)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(961)
			p.Match(TypeScriptParserCloseParen)
		}
		{
			p.SetState(962)
			p.Statement()
		}

	case 4:
		localctx = NewForVarStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(963)
			p.Match(TypeScriptParserFor)
		}
		{
			p.SetState(964)
			p.Match(TypeScriptParserOpenParen)
		}
		{
			p.SetState(965)
			p.VarModifier()
		}
		{
			p.SetState(966)
			p.VariableDeclarationList()
		}
		{
			p.SetState(967)
			p.Match(TypeScriptParserSemiColon)
		}
		p.SetState(969)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305842974837439824) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2251799813685247) != 0 || (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&7) != 0 {
			{
				p.SetState(968)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(971)
			p.Match(TypeScriptParserSemiColon)
		}
		p.SetState(973)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305842974837439824) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2251799813685247) != 0 || (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&7) != 0 {
			{
				p.SetState(972)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(975)
			p.Match(TypeScriptParserCloseParen)
		}
		{
			p.SetState(976)
			p.Statement()
		}

	case 5:
		localctx = NewForInStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(978)
			p.Match(TypeScriptParserFor)
		}
		p.SetState(980)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserAwait {
			{
				p.SetState(979)
				p.Match(TypeScriptParserAwait)
			}

		}
		{
			p.SetState(982)
			p.Match(TypeScriptParserOpenParen)
		}
		{
			p.SetState(983)
			p.singleExpression(0)
		}
		p.SetState(987)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case TypeScriptParserIn:
			{
				p.SetState(984)
				p.Match(TypeScriptParserIn)
			}

		case TypeScriptParserIdentifier:
			{
				p.SetState(985)
				p.Match(TypeScriptParserIdentifier)
			}
			p.SetState(986)

			if !(p.p("of")) {
				panic(antlr.NewFailedPredicateException(p, "p.p(\"of\")", ""))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(989)
			p.ExpressionSequence()
		}
		{
			p.SetState(990)
			p.Match(TypeScriptParserCloseParen)
		}
		{
			p.SetState(991)
			p.Statement()
		}

	case 6:
		localctx = NewForVarInStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(993)
			p.Match(TypeScriptParserFor)
		}
		p.SetState(995)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserAwait {
			{
				p.SetState(994)
				p.Match(TypeScriptParserAwait)
			}

		}
		{
			p.SetState(997)
			p.Match(TypeScriptParserOpenParen)
		}
		{
			p.SetState(998)
			p.VarModifier()
		}
		{
			p.SetState(999)
			p.VariableDeclaration()
		}
		p.SetState(1003)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case TypeScriptParserIn:
			{
				p.SetState(1000)
				p.Match(TypeScriptParserIn)
			}

		case TypeScriptParserIdentifier:
			{
				p.SetState(1001)
				p.Match(TypeScriptParserIdentifier)
			}
			p.SetState(1002)

			if !(p.p("of")) {
				panic(antlr.NewFailedPredicateException(p, "p.p(\"of\")", ""))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1005)
			p.ExpressionSequence()
		}
		{
			p.SetState(1006)
			p.Match(TypeScriptParserCloseParen)
		}
		{
			p.SetState(1007)
			p.Statement()
		}

	}

	return localctx
}

// IVarModifierContext is an interface to support dynamic dispatch.
type IVarModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarModifierContext differentiates from other interfaces.
	IsVarModifierContext()
}

type VarModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarModifierContext() *VarModifierContext {
	var p = new(VarModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_varModifier
	return p
}

func (*VarModifierContext) IsVarModifierContext() {}

func NewVarModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarModifierContext {
	var p = new(VarModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_varModifier

	return p
}

func (s *VarModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VarModifierContext) Var() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserVar, 0)
}

func (s *VarModifierContext) Let() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLet, 0)
}

func (s *VarModifierContext) Const() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserConst, 0)
}

func (s *VarModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterVarModifier(s)
	}
}

func (s *VarModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitVarModifier(s)
	}
}

func (p *TypeScriptParser) VarModifier() (localctx IVarModifierContext) {
	this := p
	_ = this

	localctx = NewVarModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, TypeScriptParserRULE_varModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&4429185025) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserContinue, 0)
}

func (s *ContinueStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ContinueStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *TypeScriptParser) ContinueStatement() (localctx IContinueStatementContext) {
	this := p
	_ = this

	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, TypeScriptParserRULE_continueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.Match(TypeScriptParserContinue)
	}
	p.SetState(1016)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		p.SetState(1014)

		if !(p.notLineTerminator()) {
			panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		}
		{
			p.SetState(1015)
			p.Match(TypeScriptParserIdentifier)
		}

	}
	{
		p.SetState(1018)
		p.Eos()
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBreak, 0)
}

func (s *BreakStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *BreakStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *TypeScriptParser) BreakStatement() (localctx IBreakStatementContext) {
	this := p
	_ = this

	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, TypeScriptParserRULE_breakStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)
		p.Match(TypeScriptParserBreak)
	}
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
		p.SetState(1021)

		if !(p.notLineTerminator()) {
			panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		}
		{
			p.SetState(1022)
			p.Match(TypeScriptParserIdentifier)
		}

	}
	{
		p.SetState(1025)
		p.Eos()
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReturn, 0)
}

func (s *ReturnStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ReturnStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *TypeScriptParser) ReturnStatement() (localctx IReturnStatementContext) {
	this := p
	_ = this

	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, TypeScriptParserRULE_returnStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1027)
		p.Match(TypeScriptParserReturn)
	}
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		p.SetState(1028)

		if !(p.notLineTerminator()) {
			panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		}
		{
			p.SetState(1029)
			p.ExpressionSequence()
		}

	}
	{
		p.SetState(1032)
		p.Eos()
	}

	return localctx
}

// IYieldStatementContext is an interface to support dynamic dispatch.
type IYieldStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldStatementContext differentiates from other interfaces.
	IsYieldStatementContext()
}

type YieldStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStatementContext() *YieldStatementContext {
	var p = new(YieldStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_yieldStatement
	return p
}

func (*YieldStatementContext) IsYieldStatementContext() {}

func NewYieldStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStatementContext {
	var p = new(YieldStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_yieldStatement

	return p
}

func (s *YieldStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStatementContext) Yield() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserYield, 0)
}

func (s *YieldStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *YieldStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *YieldStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterYieldStatement(s)
	}
}

func (s *YieldStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitYieldStatement(s)
	}
}

func (p *TypeScriptParser) YieldStatement() (localctx IYieldStatementContext) {
	this := p
	_ = this

	localctx = NewYieldStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, TypeScriptParserRULE_yieldStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1034)
		p.Match(TypeScriptParserYield)
	}
	p.SetState(1037)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		p.SetState(1035)

		if !(p.notLineTerminator()) {
			panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		}
		{
			p.SetState(1036)
			p.ExpressionSequence()
		}

	}
	{
		p.SetState(1039)
		p.Eos()
	}

	return localctx
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_withStatement
	return p
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) With() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserWith, 0)
}

func (s *WithStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *WithStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WithStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (p *TypeScriptParser) WithStatement() (localctx IWithStatementContext) {
	this := p
	_ = this

	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, TypeScriptParserRULE_withStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1041)
		p.Match(TypeScriptParserWith)
	}
	{
		p.SetState(1042)
		p.Match(TypeScriptParserOpenParen)
	}
	{
		p.SetState(1043)
		p.ExpressionSequence()
	}
	{
		p.SetState(1044)
		p.Match(TypeScriptParserCloseParen)
	}
	{
		p.SetState(1045)
		p.Statement()
	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSwitch, 0)
}

func (s *SwitchStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *SwitchStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *SwitchStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *SwitchStatementContext) CaseBlock() ICaseBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (p *TypeScriptParser) SwitchStatement() (localctx ISwitchStatementContext) {
	this := p
	_ = this

	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, TypeScriptParserRULE_switchStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1047)
		p.Match(TypeScriptParserSwitch)
	}
	{
		p.SetState(1048)
		p.Match(TypeScriptParserOpenParen)
	}
	{
		p.SetState(1049)
		p.ExpressionSequence()
	}
	{
		p.SetState(1050)
		p.Match(TypeScriptParserCloseParen)
	}
	{
		p.SetState(1051)
		p.CaseBlock()
	}

	return localctx
}

// ICaseBlockContext is an interface to support dynamic dispatch.
type ICaseBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseBlockContext differentiates from other interfaces.
	IsCaseBlockContext()
}

type CaseBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseBlockContext() *CaseBlockContext {
	var p = new(CaseBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_caseBlock
	return p
}

func (*CaseBlockContext) IsCaseBlockContext() {}

func NewCaseBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseBlockContext {
	var p = new(CaseBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_caseBlock

	return p
}

func (s *CaseBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseBlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *CaseBlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *CaseBlockContext) AllCaseClauses() []ICaseClausesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClausesContext); ok {
			len++
		}
	}

	tst := make([]ICaseClausesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClausesContext); ok {
			tst[i] = t.(ICaseClausesContext)
			i++
		}
	}

	return tst
}

func (s *CaseBlockContext) CaseClauses(i int) ICaseClausesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClausesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClausesContext)
}

func (s *CaseBlockContext) DefaultClause() IDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *CaseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCaseBlock(s)
	}
}

func (s *CaseBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCaseBlock(s)
	}
}

func (p *TypeScriptParser) CaseBlock() (localctx ICaseBlockContext) {
	this := p
	_ = this

	localctx = NewCaseBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, TypeScriptParserRULE_caseBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1053)
		p.Match(TypeScriptParserOpenBrace)
	}
	p.SetState(1055)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserCase {
		{
			p.SetState(1054)
			p.CaseClauses()
		}

	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserDefault {
		{
			p.SetState(1057)
			p.DefaultClause()
		}
		p.SetState(1059)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserCase {
			{
				p.SetState(1058)
				p.CaseClauses()
			}

		}

	}
	{
		p.SetState(1063)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// ICaseClausesContext is an interface to support dynamic dispatch.
type ICaseClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseClausesContext differentiates from other interfaces.
	IsCaseClausesContext()
}

type CaseClausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClausesContext() *CaseClausesContext {
	var p = new(CaseClausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_caseClauses
	return p
}

func (*CaseClausesContext) IsCaseClausesContext() {}

func NewCaseClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClausesContext {
	var p = new(CaseClausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_caseClauses

	return p
}

func (s *CaseClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClausesContext) AllCaseClause() []ICaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClauseContext); ok {
			tst[i] = t.(ICaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *CaseClausesContext) CaseClause(i int) ICaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *CaseClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCaseClauses(s)
	}
}

func (s *CaseClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCaseClauses(s)
	}
}

func (p *TypeScriptParser) CaseClauses() (localctx ICaseClausesContext) {
	this := p
	_ = this

	localctx = NewCaseClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, TypeScriptParserRULE_caseClauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1066)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == TypeScriptParserCase {
		{
			p.SetState(1065)
			p.CaseClause()
		}

		p.SetState(1068)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_caseClause
	return p
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) Case() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCase, 0)
}

func (s *CaseClauseContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *CaseClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *CaseClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (p *TypeScriptParser) CaseClause() (localctx ICaseClauseContext) {
	this := p
	_ = this

	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, TypeScriptParserRULE_caseClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1070)
		p.Match(TypeScriptParserCase)
	}
	{
		p.SetState(1071)
		p.ExpressionSequence()
	}
	{
		p.SetState(1072)
		p.Match(TypeScriptParserColon)
	}
	p.SetState(1074)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1073)
			p.StatementList()
		}

	}

	return localctx
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_defaultClause
	return p
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) Default() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDefault, 0)
}

func (s *DefaultClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *DefaultClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDefaultClause(s)
	}
}

func (s *DefaultClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDefaultClause(s)
	}
}

func (p *TypeScriptParser) DefaultClause() (localctx IDefaultClauseContext) {
	this := p
	_ = this

	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, TypeScriptParserRULE_defaultClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1076)
		p.Match(TypeScriptParserDefault)
	}
	{
		p.SetState(1077)
		p.Match(TypeScriptParserColon)
	}
	p.SetState(1079)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1078)
			p.StatementList()
		}

	}

	return localctx
}

// ILabelledStatementContext is an interface to support dynamic dispatch.
type ILabelledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelledStatementContext differentiates from other interfaces.
	IsLabelledStatementContext()
}

type LabelledStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelledStatementContext() *LabelledStatementContext {
	var p = new(LabelledStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_labelledStatement
	return p
}

func (*LabelledStatementContext) IsLabelledStatementContext() {}

func NewLabelledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelledStatementContext {
	var p = new(LabelledStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_labelledStatement

	return p
}

func (s *LabelledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelledStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *LabelledStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *LabelledStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabelledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLabelledStatement(s)
	}
}

func (s *LabelledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLabelledStatement(s)
	}
}

func (p *TypeScriptParser) LabelledStatement() (localctx ILabelledStatementContext) {
	this := p
	_ = this

	localctx = NewLabelledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, TypeScriptParserRULE_labelledStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1081)
		p.Match(TypeScriptParserIdentifier)
	}
	{
		p.SetState(1082)
		p.Match(TypeScriptParserColon)
	}
	{
		p.SetState(1083)
		p.Statement()
	}

	return localctx
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_throwStatement
	return p
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) Throw() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserThrow, 0)
}

func (s *ThrowStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ThrowStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (p *TypeScriptParser) ThrowStatement() (localctx IThrowStatementContext) {
	this := p
	_ = this

	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, TypeScriptParserRULE_throwStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		p.Match(TypeScriptParserThrow)
	}
	p.SetState(1086)

	if !(p.notLineTerminator()) {
		panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
	}
	{
		p.SetState(1087)
		p.ExpressionSequence()
	}
	{
		p.SetState(1088)
		p.Eos()
	}

	return localctx
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_tryStatement
	return p
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) Try() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTry, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) CatchProduction() ICatchProductionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchProductionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchProductionContext)
}

func (s *TryStatementContext) FinallyProduction() IFinallyProductionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyProductionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyProductionContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (p *TypeScriptParser) TryStatement() (localctx ITryStatementContext) {
	this := p
	_ = this

	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, TypeScriptParserRULE_tryStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1090)
		p.Match(TypeScriptParserTry)
	}
	{
		p.SetState(1091)
		p.Block()
	}
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserCatch:
		{
			p.SetState(1092)
			p.CatchProduction()
		}
		p.SetState(1094)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1093)
				p.FinallyProduction()
			}

		}

	case TypeScriptParserFinally:
		{
			p.SetState(1096)
			p.FinallyProduction()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICatchProductionContext is an interface to support dynamic dispatch.
type ICatchProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchProductionContext differentiates from other interfaces.
	IsCatchProductionContext()
}

type CatchProductionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchProductionContext() *CatchProductionContext {
	var p = new(CatchProductionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_catchProduction
	return p
}

func (*CatchProductionContext) IsCatchProductionContext() {}

func NewCatchProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchProductionContext {
	var p = new(CatchProductionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_catchProduction

	return p
}

func (s *CatchProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchProductionContext) Catch() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCatch, 0)
}

func (s *CatchProductionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchProductionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *CatchProductionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *CatchProductionContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *CatchProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCatchProduction(s)
	}
}

func (s *CatchProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCatchProduction(s)
	}
}

func (p *TypeScriptParser) CatchProduction() (localctx ICatchProductionContext) {
	this := p
	_ = this

	localctx = NewCatchProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, TypeScriptParserRULE_catchProduction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.Match(TypeScriptParserCatch)
	}
	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserOpenParen {
		{
			p.SetState(1100)
			p.Match(TypeScriptParserOpenParen)
		}
		p.SetState(1102)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserOpenBracket || _la == TypeScriptParserOpenBrace || _la == TypeScriptParserIdentifier {
			{
				p.SetState(1101)
				p.Assignable()
			}

		}
		{
			p.SetState(1104)
			p.Match(TypeScriptParserCloseParen)
		}

	}
	{
		p.SetState(1107)
		p.Block()
	}

	return localctx
}

// IAssignableContext is an interface to support dynamic dispatch.
type IAssignableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignableContext differentiates from other interfaces.
	IsAssignableContext()
}

type AssignableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableContext() *AssignableContext {
	var p = new(AssignableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_assignable
	return p
}

func (*AssignableContext) IsAssignableContext() {}

func NewAssignableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableContext {
	var p = new(AssignableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_assignable

	return p
}

func (s *AssignableContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *AssignableContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *AssignableContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *AssignableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAssignable(s)
	}
}

func (s *AssignableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAssignable(s)
	}
}

func (p *TypeScriptParser) Assignable() (localctx IAssignableContext) {
	this := p
	_ = this

	localctx = NewAssignableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, TypeScriptParserRULE_assignable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1112)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1109)
			p.Match(TypeScriptParserIdentifier)
		}

	case TypeScriptParserOpenBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1110)
			p.ArrayLiteral()
		}

	case TypeScriptParserOpenBrace:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1111)
			p.ObjectLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFinallyProductionContext is an interface to support dynamic dispatch.
type IFinallyProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyProductionContext differentiates from other interfaces.
	IsFinallyProductionContext()
}

type FinallyProductionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyProductionContext() *FinallyProductionContext {
	var p = new(FinallyProductionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_finallyProduction
	return p
}

func (*FinallyProductionContext) IsFinallyProductionContext() {}

func NewFinallyProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyProductionContext {
	var p = new(FinallyProductionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_finallyProduction

	return p
}

func (s *FinallyProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyProductionContext) Finally() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFinally, 0)
}

func (s *FinallyProductionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFinallyProduction(s)
	}
}

func (s *FinallyProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFinallyProduction(s)
	}
}

func (p *TypeScriptParser) FinallyProduction() (localctx IFinallyProductionContext) {
	this := p
	_ = this

	localctx = NewFinallyProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, TypeScriptParserRULE_finallyProduction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1114)
		p.Match(TypeScriptParserFinally)
	}
	{
		p.SetState(1115)
		p.Block()
	}

	return localctx
}

// IDebuggerStatementContext is an interface to support dynamic dispatch.
type IDebuggerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDebuggerStatementContext differentiates from other interfaces.
	IsDebuggerStatementContext()
}

type DebuggerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDebuggerStatementContext() *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_debuggerStatement
	return p
}

func (*DebuggerStatementContext) IsDebuggerStatementContext() {}

func NewDebuggerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_debuggerStatement

	return p
}

func (s *DebuggerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DebuggerStatementContext) Debugger() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDebugger, 0)
}

func (s *DebuggerStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DebuggerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DebuggerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DebuggerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDebuggerStatement(s)
	}
}

func (s *DebuggerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDebuggerStatement(s)
	}
}

func (p *TypeScriptParser) DebuggerStatement() (localctx IDebuggerStatementContext) {
	this := p
	_ = this

	localctx = NewDebuggerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, TypeScriptParserRULE_debuggerStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1117)
		p.Match(TypeScriptParserDebugger)
	}
	{
		p.SetState(1118)
		p.Eos()
	}

	return localctx
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionDeclaration
	return p
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) Function() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFunction, 0)
}

func (s *FunctionDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *FunctionDeclarationContext) CallSignature() ICallSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSignatureContext)
}

func (s *FunctionDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *FunctionDeclarationContext) Async() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAsync, 0)
}

func (s *FunctionDeclarationContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *FunctionDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (p *TypeScriptParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	this := p
	_ = this

	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, TypeScriptParserRULE_functionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1121)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAsync {
		{
			p.SetState(1120)
			p.Match(TypeScriptParserAsync)
		}

	}
	{
		p.SetState(1123)
		p.Match(TypeScriptParserFunction)
	}
	p.SetState(1125)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserMultiply {
		{
			p.SetState(1124)
			p.Match(TypeScriptParserMultiply)
		}

	}
	{
		p.SetState(1127)
		p.Match(TypeScriptParserIdentifier)
	}
	{
		p.SetState(1128)
		p.CallSignature()
	}
	p.SetState(1134)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserOpenBrace:
		{
			p.SetState(1129)
			p.Match(TypeScriptParserOpenBrace)
		}
		{
			p.SetState(1130)
			p.FunctionBody()
		}
		{
			p.SetState(1131)
			p.Match(TypeScriptParserCloseBrace)
		}

	case TypeScriptParserSemiColon:
		{
			p.SetState(1133)
			p.Match(TypeScriptParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) Class() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserClass, 0)
}

func (s *ClassDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ClassDeclarationContext) ClassHeritage() IClassHeritageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassHeritageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassHeritageContext)
}

func (s *ClassDeclarationContext) ClassTail() IClassTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTailContext)
}

func (s *ClassDeclarationContext) Abstract() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAbstract, 0)
}

func (s *ClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *TypeScriptParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	this := p
	_ = this

	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, TypeScriptParserRULE_classDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1137)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAbstract {
		{
			p.SetState(1136)
			p.Match(TypeScriptParserAbstract)
		}

	}
	{
		p.SetState(1139)
		p.Match(TypeScriptParserClass)
	}
	{
		p.SetState(1140)
		p.Match(TypeScriptParserIdentifier)
	}
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserLessThan {
		{
			p.SetState(1141)
			p.TypeParameters()
		}

	}
	{
		p.SetState(1144)
		p.ClassHeritage()
	}
	{
		p.SetState(1145)
		p.ClassTail()
	}

	return localctx
}

// IClassHeritageContext is an interface to support dynamic dispatch.
type IClassHeritageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassHeritageContext differentiates from other interfaces.
	IsClassHeritageContext()
}

type ClassHeritageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassHeritageContext() *ClassHeritageContext {
	var p = new(ClassHeritageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classHeritage
	return p
}

func (*ClassHeritageContext) IsClassHeritageContext() {}

func NewClassHeritageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassHeritageContext {
	var p = new(ClassHeritageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classHeritage

	return p
}

func (s *ClassHeritageContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassHeritageContext) ClassExtendsClause() IClassExtendsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassExtendsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassExtendsClauseContext)
}

func (s *ClassHeritageContext) ImplementsClause() IImplementsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementsClauseContext)
}

func (s *ClassHeritageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassHeritageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassHeritageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassHeritage(s)
	}
}

func (s *ClassHeritageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassHeritage(s)
	}
}

func (p *TypeScriptParser) ClassHeritage() (localctx IClassHeritageContext) {
	this := p
	_ = this

	localctx = NewClassHeritageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, TypeScriptParserRULE_classHeritage)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserExtends {
		{
			p.SetState(1147)
			p.ClassExtendsClause()
		}

	}
	p.SetState(1151)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserImplements {
		{
			p.SetState(1150)
			p.ImplementsClause()
		}

	}

	return localctx
}

// IClassTailContext is an interface to support dynamic dispatch.
type IClassTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassTailContext differentiates from other interfaces.
	IsClassTailContext()
}

type ClassTailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTailContext() *ClassTailContext {
	var p = new(ClassTailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classTail
	return p
}

func (*ClassTailContext) IsClassTailContext() {}

func NewClassTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTailContext {
	var p = new(ClassTailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classTail

	return p
}

func (s *ClassTailContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTailContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *ClassTailContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *ClassTailContext) AllClassElement() []IClassElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassElementContext); ok {
			len++
		}
	}

	tst := make([]IClassElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassElementContext); ok {
			tst[i] = t.(IClassElementContext)
			i++
		}
	}

	return tst
}

func (s *ClassTailContext) ClassElement(i int) IClassElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassElementContext)
}

func (s *ClassTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassTail(s)
	}
}

func (s *ClassTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassTail(s)
	}
}

func (p *TypeScriptParser) ClassTail() (localctx IClassTailContext) {
	this := p
	_ = this

	localctx = NewClassTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, TypeScriptParserRULE_classTail)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1153)
		p.Match(TypeScriptParserOpenBrace)
	}
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1154)
				p.ClassElement()
			}

		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}
	{
		p.SetState(1160)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// IClassExtendsClauseContext is an interface to support dynamic dispatch.
type IClassExtendsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassExtendsClauseContext differentiates from other interfaces.
	IsClassExtendsClauseContext()
}

type ClassExtendsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassExtendsClauseContext() *ClassExtendsClauseContext {
	var p = new(ClassExtendsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classExtendsClause
	return p
}

func (*ClassExtendsClauseContext) IsClassExtendsClauseContext() {}

func NewClassExtendsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassExtendsClauseContext {
	var p = new(ClassExtendsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classExtendsClause

	return p
}

func (s *ClassExtendsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassExtendsClauseContext) Extends() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExtends, 0)
}

func (s *ClassExtendsClauseContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *ClassExtendsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassExtendsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassExtendsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassExtendsClause(s)
	}
}

func (s *ClassExtendsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassExtendsClause(s)
	}
}

func (p *TypeScriptParser) ClassExtendsClause() (localctx IClassExtendsClauseContext) {
	this := p
	_ = this

	localctx = NewClassExtendsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, TypeScriptParserRULE_classExtendsClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1162)
		p.Match(TypeScriptParserExtends)
	}
	{
		p.SetState(1163)
		p.TypeReference()
	}

	return localctx
}

// IImplementsClauseContext is an interface to support dynamic dispatch.
type IImplementsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplementsClauseContext differentiates from other interfaces.
	IsImplementsClauseContext()
}

type ImplementsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementsClauseContext() *ImplementsClauseContext {
	var p = new(ImplementsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_implementsClause
	return p
}

func (*ImplementsClauseContext) IsImplementsClauseContext() {}

func NewImplementsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementsClauseContext {
	var p = new(ImplementsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_implementsClause

	return p
}

func (s *ImplementsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementsClauseContext) Implements() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserImplements, 0)
}

func (s *ImplementsClauseContext) ClassOrInterfaceTypeList() IClassOrInterfaceTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeListContext)
}

func (s *ImplementsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterImplementsClause(s)
	}
}

func (s *ImplementsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitImplementsClause(s)
	}
}

func (p *TypeScriptParser) ImplementsClause() (localctx IImplementsClauseContext) {
	this := p
	_ = this

	localctx = NewImplementsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, TypeScriptParserRULE_implementsClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1165)
		p.Match(TypeScriptParserImplements)
	}
	{
		p.SetState(1166)
		p.ClassOrInterfaceTypeList()
	}

	return localctx
}

// IClassElementContext is an interface to support dynamic dispatch.
type IClassElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassElementContext differentiates from other interfaces.
	IsClassElementContext()
}

type ClassElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassElementContext() *ClassElementContext {
	var p = new(ClassElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_classElement
	return p
}

func (*ClassElementContext) IsClassElementContext() {}

func NewClassElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassElementContext {
	var p = new(ClassElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_classElement

	return p
}

func (s *ClassElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassElementContext) ConstructorDeclaration() IConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclarationContext)
}

func (s *ClassElementContext) PropertyMemberDeclaration() IPropertyMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyMemberDeclarationContext)
}

func (s *ClassElementContext) IndexMemberDeclaration() IIndexMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexMemberDeclarationContext)
}

func (s *ClassElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ClassElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassElement(s)
	}
}

func (s *ClassElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassElement(s)
	}
}

func (p *TypeScriptParser) ClassElement() (localctx IClassElementContext) {
	this := p
	_ = this

	localctx = NewClassElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, TypeScriptParserRULE_classElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1172)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1168)
			p.ConstructorDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1169)
			p.PropertyMemberDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1170)
			p.IndexMemberDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1171)
			p.Statement()
		}

	}

	return localctx
}

// IPropertyMemberDeclarationContext is an interface to support dynamic dispatch.
type IPropertyMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyMemberDeclarationContext differentiates from other interfaces.
	IsPropertyMemberDeclarationContext()
}

type PropertyMemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyMemberDeclarationContext() *PropertyMemberDeclarationContext {
	var p = new(PropertyMemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyMemberDeclaration
	return p
}

func (*PropertyMemberDeclarationContext) IsPropertyMemberDeclarationContext() {}

func NewPropertyMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyMemberDeclarationContext {
	var p = new(PropertyMemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_propertyMemberDeclaration

	return p
}

func (s *PropertyMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyMemberDeclarationContext) PropertyMemberBase() IPropertyMemberBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyMemberBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyMemberBaseContext)
}

func (s *PropertyMemberDeclarationContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyMemberDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *PropertyMemberDeclarationContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *PropertyMemberDeclarationContext) Hashtag() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserHashtag, 0)
}

func (s *PropertyMemberDeclarationContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *PropertyMemberDeclarationContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *PropertyMemberDeclarationContext) CallSignature() ICallSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSignatureContext)
}

func (s *PropertyMemberDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *PropertyMemberDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *PropertyMemberDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *PropertyMemberDeclarationContext) GetAccessor() IGetAccessorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetAccessorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetAccessorContext)
}

func (s *PropertyMemberDeclarationContext) SetAccessor() ISetAccessorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetAccessorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetAccessorContext)
}

func (s *PropertyMemberDeclarationContext) AbstractDeclaration() IAbstractDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclarationContext)
}

func (s *PropertyMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyMemberDeclaration(s)
	}
}

func (s *PropertyMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyMemberDeclaration(s)
	}
}

func (p *TypeScriptParser) PropertyMemberDeclaration() (localctx IPropertyMemberDeclarationContext) {
	this := p
	_ = this

	localctx = NewPropertyMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, TypeScriptParserRULE_propertyMemberDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1174)
			p.PropertyMemberBase()
		}
		p.SetState(1176)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserMultiply {
			{
				p.SetState(1175)
				p.Match(TypeScriptParserMultiply)
			}

		}
		p.SetState(1179)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserHashtag {
			{
				p.SetState(1178)
				p.Match(TypeScriptParserHashtag)
			}

		}
		{
			p.SetState(1181)
			p.PropertyName()
		}
		p.SetState(1183)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserColon {
			{
				p.SetState(1182)
				p.TypeAnnotation()
			}

		}
		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserAssign {
			{
				p.SetState(1185)
				p.Initializer()
			}

		}
		{
			p.SetState(1188)
			p.Match(TypeScriptParserSemiColon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1190)
			p.PropertyMemberBase()
		}
		p.SetState(1192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserMultiply {
			{
				p.SetState(1191)
				p.Match(TypeScriptParserMultiply)
			}

		}
		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserHashtag {
			{
				p.SetState(1194)
				p.Match(TypeScriptParserHashtag)
			}

		}
		{
			p.SetState(1197)
			p.PropertyName()
		}
		{
			p.SetState(1198)
			p.CallSignature()
		}
		p.SetState(1204)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case TypeScriptParserOpenBrace:
			{
				p.SetState(1199)
				p.Match(TypeScriptParserOpenBrace)
			}
			{
				p.SetState(1200)
				p.FunctionBody()
			}
			{
				p.SetState(1201)
				p.Match(TypeScriptParserCloseBrace)
			}

		case TypeScriptParserSemiColon:
			{
				p.SetState(1203)
				p.Match(TypeScriptParserSemiColon)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1206)
			p.PropertyMemberBase()
		}
		p.SetState(1208)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserMultiply {
			{
				p.SetState(1207)
				p.Match(TypeScriptParserMultiply)
			}

		}
		p.SetState(1211)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserHashtag {
			{
				p.SetState(1210)
				p.Match(TypeScriptParserHashtag)
			}

		}
		p.SetState(1215)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1213)
				p.GetAccessor()
			}

		case 2:
			{
				p.SetState(1214)
				p.SetAccessor()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1217)
			p.AbstractDeclaration()
		}

	}

	return localctx
}

// IPropertyMemberBaseContext is an interface to support dynamic dispatch.
type IPropertyMemberBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyMemberBaseContext differentiates from other interfaces.
	IsPropertyMemberBaseContext()
}

type PropertyMemberBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyMemberBaseContext() *PropertyMemberBaseContext {
	var p = new(PropertyMemberBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyMemberBase
	return p
}

func (*PropertyMemberBaseContext) IsPropertyMemberBaseContext() {}

func NewPropertyMemberBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyMemberBaseContext {
	var p = new(PropertyMemberBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_propertyMemberBase

	return p
}

func (s *PropertyMemberBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyMemberBaseContext) Async() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAsync, 0)
}

func (s *PropertyMemberBaseContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *PropertyMemberBaseContext) Static() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStatic, 0)
}

func (s *PropertyMemberBaseContext) ReadOnly() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReadOnly, 0)
}

func (s *PropertyMemberBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyMemberBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyMemberBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyMemberBase(s)
	}
}

func (s *PropertyMemberBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyMemberBase(s)
	}
}

func (p *TypeScriptParser) PropertyMemberBase() (localctx IPropertyMemberBaseContext) {
	this := p
	_ = this

	localctx = NewPropertyMemberBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, TypeScriptParserRULE_propertyMemberBase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1221)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1220)
			p.Match(TypeScriptParserAsync)
		}

	}
	p.SetState(1224)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1223)
			p.AccessibilityModifier()
		}

	}
	p.SetState(1227)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1226)
			p.Match(TypeScriptParserStatic)
		}

	}
	p.SetState(1230)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1229)
			p.Match(TypeScriptParserReadOnly)
		}

	}

	return localctx
}

// IIndexMemberDeclarationContext is an interface to support dynamic dispatch.
type IIndexMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexMemberDeclarationContext differentiates from other interfaces.
	IsIndexMemberDeclarationContext()
}

type IndexMemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexMemberDeclarationContext() *IndexMemberDeclarationContext {
	var p = new(IndexMemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_indexMemberDeclaration
	return p
}

func (*IndexMemberDeclarationContext) IsIndexMemberDeclarationContext() {}

func NewIndexMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexMemberDeclarationContext {
	var p = new(IndexMemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_indexMemberDeclaration

	return p
}

func (s *IndexMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexMemberDeclarationContext) IndexSignature() IIndexSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexSignatureContext)
}

func (s *IndexMemberDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *IndexMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIndexMemberDeclaration(s)
	}
}

func (s *IndexMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIndexMemberDeclaration(s)
	}
}

func (p *TypeScriptParser) IndexMemberDeclaration() (localctx IIndexMemberDeclarationContext) {
	this := p
	_ = this

	localctx = NewIndexMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, TypeScriptParserRULE_indexMemberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1232)
		p.IndexSignature()
	}
	{
		p.SetState(1233)
		p.Match(TypeScriptParserSemiColon)
	}

	return localctx
}

// IGeneratorMethodContext is an interface to support dynamic dispatch.
type IGeneratorMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneratorMethodContext differentiates from other interfaces.
	IsGeneratorMethodContext()
}

type GeneratorMethodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratorMethodContext() *GeneratorMethodContext {
	var p = new(GeneratorMethodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorMethod
	return p
}

func (*GeneratorMethodContext) IsGeneratorMethodContext() {}

func NewGeneratorMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratorMethodContext {
	var p = new(GeneratorMethodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_generatorMethod

	return p
}

func (s *GeneratorMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratorMethodContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *GeneratorMethodContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *GeneratorMethodContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *GeneratorMethodContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *GeneratorMethodContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *GeneratorMethodContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *GeneratorMethodContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *GeneratorMethodContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *GeneratorMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratorMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorMethod(s)
	}
}

func (s *GeneratorMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorMethod(s)
	}
}

func (p *TypeScriptParser) GeneratorMethod() (localctx IGeneratorMethodContext) {
	this := p
	_ = this

	localctx = NewGeneratorMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, TypeScriptParserRULE_generatorMethod)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserMultiply {
		{
			p.SetState(1235)
			p.Match(TypeScriptParserMultiply)
		}

	}
	{
		p.SetState(1238)
		p.Match(TypeScriptParserIdentifier)
	}
	{
		p.SetState(1239)
		p.Match(TypeScriptParserOpenParen)
	}
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&8388627) != 0 {
		{
			p.SetState(1240)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1243)
		p.Match(TypeScriptParserCloseParen)
	}
	{
		p.SetState(1244)
		p.Match(TypeScriptParserOpenBrace)
	}
	{
		p.SetState(1245)
		p.FunctionBody()
	}
	{
		p.SetState(1246)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// IGeneratorFunctionDeclarationContext is an interface to support dynamic dispatch.
type IGeneratorFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneratorFunctionDeclarationContext differentiates from other interfaces.
	IsGeneratorFunctionDeclarationContext()
}

type GeneratorFunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratorFunctionDeclarationContext() *GeneratorFunctionDeclarationContext {
	var p = new(GeneratorFunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorFunctionDeclaration
	return p
}

func (*GeneratorFunctionDeclarationContext) IsGeneratorFunctionDeclarationContext() {}

func NewGeneratorFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratorFunctionDeclarationContext {
	var p = new(GeneratorFunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_generatorFunctionDeclaration

	return p
}

func (s *GeneratorFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratorFunctionDeclarationContext) Function() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFunction, 0)
}

func (s *GeneratorFunctionDeclarationContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *GeneratorFunctionDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *GeneratorFunctionDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *GeneratorFunctionDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *GeneratorFunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *GeneratorFunctionDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *GeneratorFunctionDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *GeneratorFunctionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *GeneratorFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratorFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorFunctionDeclaration(s)
	}
}

func (s *GeneratorFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorFunctionDeclaration(s)
	}
}

func (p *TypeScriptParser) GeneratorFunctionDeclaration() (localctx IGeneratorFunctionDeclarationContext) {
	this := p
	_ = this

	localctx = NewGeneratorFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, TypeScriptParserRULE_generatorFunctionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1248)
		p.Match(TypeScriptParserFunction)
	}
	{
		p.SetState(1249)
		p.Match(TypeScriptParserMultiply)
	}
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserIdentifier {
		{
			p.SetState(1250)
			p.Match(TypeScriptParserIdentifier)
		}

	}
	{
		p.SetState(1253)
		p.Match(TypeScriptParserOpenParen)
	}
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&8388627) != 0 {
		{
			p.SetState(1254)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1257)
		p.Match(TypeScriptParserCloseParen)
	}
	{
		p.SetState(1258)
		p.Match(TypeScriptParserOpenBrace)
	}
	{
		p.SetState(1259)
		p.FunctionBody()
	}
	{
		p.SetState(1260)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// IGeneratorBlockContext is an interface to support dynamic dispatch.
type IGeneratorBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneratorBlockContext differentiates from other interfaces.
	IsGeneratorBlockContext()
}

type GeneratorBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratorBlockContext() *GeneratorBlockContext {
	var p = new(GeneratorBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorBlock
	return p
}

func (*GeneratorBlockContext) IsGeneratorBlockContext() {}

func NewGeneratorBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratorBlockContext {
	var p = new(GeneratorBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_generatorBlock

	return p
}

func (s *GeneratorBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratorBlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *GeneratorBlockContext) AllGeneratorDefinition() []IGeneratorDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGeneratorDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IGeneratorDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGeneratorDefinitionContext); ok {
			tst[i] = t.(IGeneratorDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *GeneratorBlockContext) GeneratorDefinition(i int) IGeneratorDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratorDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratorDefinitionContext)
}

func (s *GeneratorBlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *GeneratorBlockContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *GeneratorBlockContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *GeneratorBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratorBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorBlock(s)
	}
}

func (s *GeneratorBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorBlock(s)
	}
}

func (p *TypeScriptParser) GeneratorBlock() (localctx IGeneratorBlockContext) {
	this := p
	_ = this

	localctx = NewGeneratorBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, TypeScriptParserRULE_generatorBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1262)
		p.Match(TypeScriptParserOpenBrace)
	}
	{
		p.SetState(1263)
		p.GeneratorDefinition()
	}
	p.SetState(1268)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1264)
				p.Match(TypeScriptParserComma)
			}
			{
				p.SetState(1265)
				p.GeneratorDefinition()
			}

		}
		p.SetState(1270)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())
	}
	p.SetState(1272)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserComma {
		{
			p.SetState(1271)
			p.Match(TypeScriptParserComma)
		}

	}
	{
		p.SetState(1274)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// IGeneratorDefinitionContext is an interface to support dynamic dispatch.
type IGeneratorDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneratorDefinitionContext differentiates from other interfaces.
	IsGeneratorDefinitionContext()
}

type GeneratorDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratorDefinitionContext() *GeneratorDefinitionContext {
	var p = new(GeneratorDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_generatorDefinition
	return p
}

func (*GeneratorDefinitionContext) IsGeneratorDefinitionContext() {}

func NewGeneratorDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratorDefinitionContext {
	var p = new(GeneratorDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_generatorDefinition

	return p
}

func (s *GeneratorDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratorDefinitionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *GeneratorDefinitionContext) IteratorDefinition() IIteratorDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIteratorDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIteratorDefinitionContext)
}

func (s *GeneratorDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratorDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorDefinition(s)
	}
}

func (s *GeneratorDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorDefinition(s)
	}
}

func (p *TypeScriptParser) GeneratorDefinition() (localctx IGeneratorDefinitionContext) {
	this := p
	_ = this

	localctx = NewGeneratorDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, TypeScriptParserRULE_generatorDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1276)
		p.Match(TypeScriptParserMultiply)
	}
	{
		p.SetState(1277)
		p.IteratorDefinition()
	}

	return localctx
}

// IIteratorBlockContext is an interface to support dynamic dispatch.
type IIteratorBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteratorBlockContext differentiates from other interfaces.
	IsIteratorBlockContext()
}

type IteratorBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteratorBlockContext() *IteratorBlockContext {
	var p = new(IteratorBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_iteratorBlock
	return p
}

func (*IteratorBlockContext) IsIteratorBlockContext() {}

func NewIteratorBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IteratorBlockContext {
	var p = new(IteratorBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_iteratorBlock

	return p
}

func (s *IteratorBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *IteratorBlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *IteratorBlockContext) AllIteratorDefinition() []IIteratorDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIteratorDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IIteratorDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIteratorDefinitionContext); ok {
			tst[i] = t.(IIteratorDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *IteratorBlockContext) IteratorDefinition(i int) IIteratorDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIteratorDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIteratorDefinitionContext)
}

func (s *IteratorBlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *IteratorBlockContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *IteratorBlockContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *IteratorBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IteratorBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIteratorBlock(s)
	}
}

func (s *IteratorBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIteratorBlock(s)
	}
}

func (p *TypeScriptParser) IteratorBlock() (localctx IIteratorBlockContext) {
	this := p
	_ = this

	localctx = NewIteratorBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, TypeScriptParserRULE_iteratorBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1279)
		p.Match(TypeScriptParserOpenBrace)
	}
	{
		p.SetState(1280)
		p.IteratorDefinition()
	}
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1281)
				p.Match(TypeScriptParserComma)
			}
			{
				p.SetState(1282)
				p.IteratorDefinition()
			}

		}
		p.SetState(1287)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())
	}
	p.SetState(1289)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserComma {
		{
			p.SetState(1288)
			p.Match(TypeScriptParserComma)
		}

	}
	{
		p.SetState(1291)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// IIteratorDefinitionContext is an interface to support dynamic dispatch.
type IIteratorDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteratorDefinitionContext differentiates from other interfaces.
	IsIteratorDefinitionContext()
}

type IteratorDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteratorDefinitionContext() *IteratorDefinitionContext {
	var p = new(IteratorDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_iteratorDefinition
	return p
}

func (*IteratorDefinitionContext) IsIteratorDefinitionContext() {}

func NewIteratorDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IteratorDefinitionContext {
	var p = new(IteratorDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_iteratorDefinition

	return p
}

func (s *IteratorDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *IteratorDefinitionContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *IteratorDefinitionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *IteratorDefinitionContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *IteratorDefinitionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *IteratorDefinitionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *IteratorDefinitionContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *IteratorDefinitionContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *IteratorDefinitionContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *IteratorDefinitionContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *IteratorDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IteratorDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIteratorDefinition(s)
	}
}

func (s *IteratorDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIteratorDefinition(s)
	}
}

func (p *TypeScriptParser) IteratorDefinition() (localctx IIteratorDefinitionContext) {
	this := p
	_ = this

	localctx = NewIteratorDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, TypeScriptParserRULE_iteratorDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1293)
		p.Match(TypeScriptParserOpenBracket)
	}
	{
		p.SetState(1294)
		p.singleExpression(0)
	}
	{
		p.SetState(1295)
		p.Match(TypeScriptParserCloseBracket)
	}
	{
		p.SetState(1296)
		p.Match(TypeScriptParserOpenParen)
	}
	p.SetState(1298)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&8388627) != 0 {
		{
			p.SetState(1297)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1300)
		p.Match(TypeScriptParserCloseParen)
	}
	{
		p.SetState(1301)
		p.Match(TypeScriptParserOpenBrace)
	}
	{
		p.SetState(1302)
		p.FunctionBody()
	}
	{
		p.SetState(1303)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameterArg() []IFormalParameterArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterArgContext); ok {
			tst[i] = t.(IFormalParameterArgContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterArg(i int) IFormalParameterArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterArgContext)
}

func (s *FormalParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *FormalParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *FormalParameterListContext) LastFormalParameterArg() ILastFormalParameterArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastFormalParameterArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastFormalParameterArgContext)
}

func (s *FormalParameterListContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *FormalParameterListContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *FormalParameterListContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *FormalParameterListContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (p *TypeScriptParser) FormalParameterList() (localctx IFormalParameterListContext) {
	this := p
	_ = this

	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, TypeScriptParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1324)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserProtected, TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1305)
			p.FormalParameterArg()
		}
		p.SetState(1310)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1306)
					p.Match(TypeScriptParserComma)
				}
				{
					p.SetState(1307)
					p.FormalParameterArg()
				}

			}
			p.SetState(1312)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext())
		}
		p.SetState(1315)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserComma {
			{
				p.SetState(1313)
				p.Match(TypeScriptParserComma)
			}
			{
				p.SetState(1314)
				p.LastFormalParameterArg()
			}

		}

	case TypeScriptParserEllipsis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1317)
			p.LastFormalParameterArg()
		}

	case TypeScriptParserOpenBracket:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1318)
			p.ArrayLiteral()
		}

	case TypeScriptParserOpenBrace:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1319)
			p.ObjectLiteral()
		}
		p.SetState(1322)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserColon {
			{
				p.SetState(1320)
				p.Match(TypeScriptParserColon)
			}
			{
				p.SetState(1321)
				p.FormalParameterList()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFormalParameterArgContext is an interface to support dynamic dispatch.
type IFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterArgContext differentiates from other interfaces.
	IsFormalParameterArgContext()
}

type FormalParameterArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterArgContext() *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_formalParameterArg
	return p
}

func (*FormalParameterArgContext) IsFormalParameterArgContext() {}

func NewFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_formalParameterArg

	return p
}

func (s *FormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterArgContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *FormalParameterArgContext) AccessibilityModifier() IAccessibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessibilityModifierContext)
}

func (s *FormalParameterArgContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FormalParameterArgContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *FormalParameterArgContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *FormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFormalParameterArg(s)
	}
}

func (s *FormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFormalParameterArg(s)
	}
}

func (p *TypeScriptParser) FormalParameterArg() (localctx IFormalParameterArgContext) {
	this := p
	_ = this

	localctx = NewFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, TypeScriptParserRULE_formalParameterArg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&19) != 0 {
		{
			p.SetState(1326)
			p.AccessibilityModifier()
		}

	}
	{
		p.SetState(1329)
		p.Match(TypeScriptParserIdentifier)
	}
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(1330)
			p.TypeAnnotation()
		}

	}
	p.SetState(1335)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAssign {
		{
			p.SetState(1333)
			p.Match(TypeScriptParserAssign)
		}
		{
			p.SetState(1334)
			p.singleExpression(0)
		}

	}

	return localctx
}

// ILastFormalParameterArgContext is an interface to support dynamic dispatch.
type ILastFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLastFormalParameterArgContext differentiates from other interfaces.
	IsLastFormalParameterArgContext()
}

type LastFormalParameterArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFormalParameterArgContext() *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_lastFormalParameterArg
	return p
}

func (*LastFormalParameterArgContext) IsLastFormalParameterArgContext() {}

func NewLastFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_lastFormalParameterArg

	return p
}

func (s *LastFormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFormalParameterArgContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEllipsis, 0)
}

func (s *LastFormalParameterArgContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *LastFormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLastFormalParameterArg(s)
	}
}

func (s *LastFormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLastFormalParameterArg(s)
	}
}

func (p *TypeScriptParser) LastFormalParameterArg() (localctx ILastFormalParameterArgContext) {
	this := p
	_ = this

	localctx = NewLastFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, TypeScriptParserRULE_lastFormalParameterArg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1337)
		p.Match(TypeScriptParserEllipsis)
	}
	{
		p.SetState(1338)
		p.Match(TypeScriptParserIdentifier)
	}

	return localctx
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionBody
	return p
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) SourceElements() ISourceElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (p *TypeScriptParser) FunctionBody() (localctx IFunctionBodyContext) {
	this := p
	_ = this

	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, TypeScriptParserRULE_functionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1341)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1340)
			p.SourceElements()
		}

	}

	return localctx
}

// ISourceElementsContext is an interface to support dynamic dispatch.
type ISourceElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceElementsContext differentiates from other interfaces.
	IsSourceElementsContext()
}

type SourceElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementsContext() *SourceElementsContext {
	var p = new(SourceElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_sourceElements
	return p
}

func (*SourceElementsContext) IsSourceElementsContext() {}

func NewSourceElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementsContext {
	var p = new(SourceElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_sourceElements

	return p
}

func (s *SourceElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementsContext) AllSourceElement() []ISourceElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISourceElementContext); ok {
			len++
		}
	}

	tst := make([]ISourceElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISourceElementContext); ok {
			tst[i] = t.(ISourceElementContext)
			i++
		}
	}

	return tst
}

func (s *SourceElementsContext) SourceElement(i int) ISourceElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementContext)
}

func (s *SourceElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSourceElements(s)
	}
}

func (s *SourceElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSourceElements(s)
	}
}

func (p *TypeScriptParser) SourceElements() (localctx ISourceElementsContext) {
	this := p
	_ = this

	localctx = NewSourceElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, TypeScriptParserRULE_sourceElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1344)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1343)
				p.SourceElement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1346)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())
	}

	return localctx
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrayLiteral
	return p
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *ArrayLiteralContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *ArrayLiteralContext) ElementList() IElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (p *TypeScriptParser) ArrayLiteral() (localctx IArrayLiteralContext) {
	this := p
	_ = this

	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, TypeScriptParserRULE_arrayLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1348)
		p.Match(TypeScriptParserOpenBracket)
	}
	p.SetState(1350)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305842974837374288) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2251799813685247) != 0 || (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&7) != 0 {
		{
			p.SetState(1349)
			p.ElementList()
		}

	}
	{
		p.SetState(1352)
		p.Match(TypeScriptParserCloseBracket)
	}

	return localctx
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_elementList
	return p
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ElementListContext) LastElement() ILastElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastElementContext)
}

func (s *ElementListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ElementListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (p *TypeScriptParser) ElementList() (localctx IElementListContext) {
	this := p
	_ = this

	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, TypeScriptParserRULE_elementList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1375)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserRegularExpressionLiteral, TypeScriptParserOpenBracket, TypeScriptParserOpenParen, TypeScriptParserOpenBrace, TypeScriptParserPlusPlus, TypeScriptParserMinusMinus, TypeScriptParserPlus, TypeScriptParserMinus, TypeScriptParserBitNot, TypeScriptParserNot, TypeScriptParserLessThan, TypeScriptParserNullLiteral, TypeScriptParserBooleanLiteral, TypeScriptParserDecimalLiteral, TypeScriptParserHexIntegerLiteral, TypeScriptParserOctalIntegerLiteral, TypeScriptParserOctalIntegerLiteral2, TypeScriptParserBinaryIntegerLiteral, TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserAs, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserAwait, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield, TypeScriptParserIdentifier, TypeScriptParserStringLiteral, TypeScriptParserTemplateStringLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1354)
			p.singleExpression(0)
		}
		p.SetState(1363)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1356)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == TypeScriptParserComma {
					{
						p.SetState(1355)
						p.Match(TypeScriptParserComma)
					}

					p.SetState(1358)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1360)
					p.singleExpression(0)
				}

			}
			p.SetState(1365)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext())
		}
		p.SetState(1372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserComma {
			p.SetState(1367)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == TypeScriptParserComma {
				{
					p.SetState(1366)
					p.Match(TypeScriptParserComma)
				}

				p.SetState(1369)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1371)
				p.LastElement()
			}

		}

	case TypeScriptParserEllipsis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1374)
			p.LastElement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILastElementContext is an interface to support dynamic dispatch.
type ILastElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLastElementContext differentiates from other interfaces.
	IsLastElementContext()
}

type LastElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastElementContext() *LastElementContext {
	var p = new(LastElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_lastElement
	return p
}

func (*LastElementContext) IsLastElementContext() {}

func NewLastElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastElementContext {
	var p = new(LastElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_lastElement

	return p
}

func (s *LastElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LastElementContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEllipsis, 0)
}

func (s *LastElementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *LastElementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LastElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLastElement(s)
	}
}

func (s *LastElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLastElement(s)
	}
}

func (p *TypeScriptParser) LastElement() (localctx ILastElementContext) {
	this := p
	_ = this

	localctx = NewLastElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, TypeScriptParserRULE_lastElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1377)
		p.Match(TypeScriptParserEllipsis)
	}
	p.SetState(1380)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1378)
			p.Match(TypeScriptParserIdentifier)
		}

	case 2:
		{
			p.SetState(1379)
			p.singleExpression(0)
		}

	}

	return localctx
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_objectLiteral
	return p
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *ObjectLiteralContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *ObjectLiteralContext) AllPropertyAssignment() []IPropertyAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IPropertyAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyAssignmentContext); ok {
			tst[i] = t.(IPropertyAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *ObjectLiteralContext) PropertyAssignment(i int) IPropertyAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentContext)
}

func (s *ObjectLiteralContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ObjectLiteralContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (p *TypeScriptParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	this := p
	_ = this

	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, TypeScriptParserRULE_objectLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1382)
		p.Match(TypeScriptParserOpenBrace)
	}
	p.SetState(1391)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&-72057594037401599) != 0 || (int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-4611615649683210241) != 0 {
		{
			p.SetState(1383)
			p.PropertyAssignment()
		}
		p.SetState(1388)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1384)
					p.Match(TypeScriptParserComma)
				}
				{
					p.SetState(1385)
					p.PropertyAssignment()
				}

			}
			p.SetState(1390)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext())
		}

	}
	p.SetState(1394)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserComma {
		{
			p.SetState(1393)
			p.Match(TypeScriptParserComma)
		}

	}
	{
		p.SetState(1396)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// IPropertyAssignmentContext is an interface to support dynamic dispatch.
type IPropertyAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyAssignmentContext differentiates from other interfaces.
	IsPropertyAssignmentContext()
}

type PropertyAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyAssignmentContext() *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyAssignment
	return p
}

func (*PropertyAssignmentContext) IsPropertyAssignmentContext() {}

func NewPropertyAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_propertyAssignment

	return p
}

func (s *PropertyAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyAssignmentContext) CopyFrom(ctx *PropertyAssignmentContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PropertyAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PropertyExpressionAssignmentContext struct {
	*PropertyAssignmentContext
}

func NewPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyExpressionAssignmentContext {
	var p = new(PropertyExpressionAssignmentContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExpressionAssignmentContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyExpressionAssignmentContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *PropertyExpressionAssignmentContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *PropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyExpressionAssignment(s)
	}
}

func (s *PropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyExpressionAssignment(s)
	}
}

type ComputedPropertyExpressionAssignmentContext struct {
	*PropertyAssignmentContext
}

func NewComputedPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComputedPropertyExpressionAssignmentContext {
	var p = new(ComputedPropertyExpressionAssignmentContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *ComputedPropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedPropertyExpressionAssignmentContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComputedPropertyExpressionAssignmentContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ComputedPropertyExpressionAssignmentContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterComputedPropertyExpressionAssignment(s)
	}
}

func (s *ComputedPropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitComputedPropertyExpressionAssignment(s)
	}
}

type PropertyShorthandContext struct {
	*PropertyAssignmentContext
}

func NewPropertyShorthandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyShorthandContext {
	var p = new(PropertyShorthandContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyShorthandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyShorthandContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *PropertyShorthandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyShorthand(s)
	}
}

func (s *PropertyShorthandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyShorthand(s)
	}
}

type PropertySetterContext struct {
	*PropertyAssignmentContext
}

func NewPropertySetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertySetterContext {
	var p = new(PropertySetterContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertySetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySetterContext) SetAccessor() ISetAccessorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetAccessorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetAccessorContext)
}

func (s *PropertySetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertySetter(s)
	}
}

func (s *PropertySetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertySetter(s)
	}
}

type PropertyGetterContext struct {
	*PropertyAssignmentContext
}

func NewPropertyGetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyGetterContext {
	var p = new(PropertyGetterContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyGetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyGetterContext) GetAccessor() IGetAccessorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetAccessorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetAccessorContext)
}

func (s *PropertyGetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyGetter(s)
	}
}

func (s *PropertyGetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyGetter(s)
	}
}

type FunctionPropertyContext struct {
	*PropertyAssignmentContext
}

func NewFunctionPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionPropertyContext {
	var p = new(FunctionPropertyContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *FunctionPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionPropertyContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *FunctionPropertyContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *FunctionPropertyContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *FunctionPropertyContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *FunctionPropertyContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionPropertyContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *FunctionPropertyContext) Async() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAsync, 0)
}

func (s *FunctionPropertyContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *FunctionPropertyContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFunctionProperty(s)
	}
}

func (s *FunctionPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFunctionProperty(s)
	}
}

type RestParameterInObjectContext struct {
	*PropertyAssignmentContext
}

func NewRestParameterInObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RestParameterInObjectContext {
	var p = new(RestParameterInObjectContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *RestParameterInObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestParameterInObjectContext) RestParameter() IRestParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestParameterContext)
}

func (s *RestParameterInObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRestParameterInObject(s)
	}
}

func (s *RestParameterInObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRestParameterInObject(s)
	}
}

type MethodPropertyContext struct {
	*PropertyAssignmentContext
}

func NewMethodPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MethodPropertyContext {
	var p = new(MethodPropertyContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *MethodPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodPropertyContext) GeneratorMethod() IGeneratorMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratorMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratorMethodContext)
}

func (s *MethodPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMethodProperty(s)
	}
}

func (s *MethodPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMethodProperty(s)
	}
}

func (p *TypeScriptParser) PropertyAssignment() (localctx IPropertyAssignmentContext) {
	this := p
	_ = this

	localctx = NewPropertyAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, TypeScriptParserRULE_propertyAssignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1429)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1398)
			p.PropertyName()
		}
		{
			p.SetState(1399)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TypeScriptParserAssign || _la == TypeScriptParserColon) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1400)
			p.singleExpression(0)
		}

	case 2:
		localctx = NewComputedPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1402)
			p.Match(TypeScriptParserOpenBracket)
		}
		{
			p.SetState(1403)
			p.singleExpression(0)
		}
		{
			p.SetState(1404)
			p.Match(TypeScriptParserCloseBracket)
		}
		{
			p.SetState(1405)
			p.Match(TypeScriptParserColon)
		}
		{
			p.SetState(1406)
			p.singleExpression(0)
		}

	case 3:
		localctx = NewFunctionPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1409)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1408)
				p.Match(TypeScriptParserAsync)
			}

		}
		p.SetState(1412)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserMultiply {
			{
				p.SetState(1411)
				p.Match(TypeScriptParserMultiply)
			}

		}
		{
			p.SetState(1414)
			p.PropertyName()
		}
		{
			p.SetState(1415)
			p.Match(TypeScriptParserOpenParen)
		}
		p.SetState(1417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&8388627) != 0 {
			{
				p.SetState(1416)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(1419)
			p.Match(TypeScriptParserCloseParen)
		}
		{
			p.SetState(1420)
			p.Match(TypeScriptParserOpenBrace)
		}
		{
			p.SetState(1421)
			p.FunctionBody()
		}
		{
			p.SetState(1422)
			p.Match(TypeScriptParserCloseBrace)
		}

	case 4:
		localctx = NewPropertyGetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1424)
			p.GetAccessor()
		}

	case 5:
		localctx = NewPropertySetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1425)
			p.SetAccessor()
		}

	case 6:
		localctx = NewMethodPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1426)
			p.GeneratorMethod()
		}

	case 7:
		localctx = NewPropertyShorthandContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1427)
			p.Match(TypeScriptParserIdentifier)
		}

	case 8:
		localctx = NewRestParameterInObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1428)
			p.RestParameter()
		}

	}

	return localctx
}

// IGetAccessorContext is an interface to support dynamic dispatch.
type IGetAccessorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetAccessorContext differentiates from other interfaces.
	IsGetAccessorContext()
}

type GetAccessorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetAccessorContext() *GetAccessorContext {
	var p = new(GetAccessorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_getAccessor
	return p
}

func (*GetAccessorContext) IsGetAccessorContext() {}

func NewGetAccessorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetAccessorContext {
	var p = new(GetAccessorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_getAccessor

	return p
}

func (s *GetAccessorContext) GetParser() antlr.Parser { return s.parser }

func (s *GetAccessorContext) Getter() IGetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *GetAccessorContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *GetAccessorContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *GetAccessorContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *GetAccessorContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *GetAccessorContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *GetAccessorContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *GetAccessorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetAccessorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetAccessorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGetAccessor(s)
	}
}

func (s *GetAccessorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGetAccessor(s)
	}
}

func (p *TypeScriptParser) GetAccessor() (localctx IGetAccessorContext) {
	this := p
	_ = this

	localctx = NewGetAccessorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, TypeScriptParserRULE_getAccessor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1431)
		p.Getter()
	}
	{
		p.SetState(1432)
		p.Match(TypeScriptParserOpenParen)
	}
	{
		p.SetState(1433)
		p.Match(TypeScriptParserCloseParen)
	}
	p.SetState(1435)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(1434)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(1437)
		p.Match(TypeScriptParserOpenBrace)
	}
	{
		p.SetState(1438)
		p.FunctionBody()
	}
	{
		p.SetState(1439)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// ISetAccessorContext is an interface to support dynamic dispatch.
type ISetAccessorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetAccessorContext differentiates from other interfaces.
	IsSetAccessorContext()
}

type SetAccessorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetAccessorContext() *SetAccessorContext {
	var p = new(SetAccessorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_setAccessor
	return p
}

func (*SetAccessorContext) IsSetAccessorContext() {}

func NewSetAccessorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetAccessorContext {
	var p = new(SetAccessorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_setAccessor

	return p
}

func (s *SetAccessorContext) GetParser() antlr.Parser { return s.parser }

func (s *SetAccessorContext) Setter() ISetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *SetAccessorContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *SetAccessorContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *SetAccessorContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *SetAccessorContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *SetAccessorContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *SetAccessorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *SetAccessorContext) BindingPattern() IBindingPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingPatternContext)
}

func (s *SetAccessorContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *SetAccessorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAccessorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetAccessorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSetAccessor(s)
	}
}

func (s *SetAccessorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSetAccessor(s)
	}
}

func (p *TypeScriptParser) SetAccessor() (localctx ISetAccessorContext) {
	this := p
	_ = this

	localctx = NewSetAccessorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, TypeScriptParserRULE_setAccessor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1441)
		p.Setter()
	}
	{
		p.SetState(1442)
		p.Match(TypeScriptParserOpenParen)
	}
	p.SetState(1445)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserIdentifier:
		{
			p.SetState(1443)
			p.Match(TypeScriptParserIdentifier)
		}

	case TypeScriptParserOpenBracket, TypeScriptParserOpenBrace:
		{
			p.SetState(1444)
			p.BindingPattern()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(1447)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(1450)
		p.Match(TypeScriptParserCloseParen)
	}
	{
		p.SetState(1451)
		p.Match(TypeScriptParserOpenBrace)
	}
	{
		p.SetState(1452)
		p.FunctionBody()
	}
	{
		p.SetState(1453)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// IPropertyNameContext is an interface to support dynamic dispatch.
type IPropertyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyNameContext differentiates from other interfaces.
	IsPropertyNameContext()
}

type PropertyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyNameContext() *PropertyNameContext {
	var p = new(PropertyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_propertyName
	return p
}

func (*PropertyNameContext) IsPropertyNameContext() {}

func NewPropertyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyNameContext {
	var p = new(PropertyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_propertyName

	return p
}

func (s *PropertyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyNameContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *PropertyNameContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStringLiteral, 0)
}

func (s *PropertyNameContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *PropertyNameContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *PropertyNameContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyNameContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *PropertyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPropertyName(s)
	}
}

func (s *PropertyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPropertyName(s)
	}
}

func (p *TypeScriptParser) PropertyName() (localctx IPropertyNameContext) {
	this := p
	_ = this

	localctx = NewPropertyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, TypeScriptParserRULE_propertyName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1462)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserNullLiteral, TypeScriptParserBooleanLiteral, TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserAs, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserAwait, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield, TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1455)
			p.IdentifierName()
		}

	case TypeScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1456)
			p.Match(TypeScriptParserStringLiteral)
		}

	case TypeScriptParserDecimalLiteral, TypeScriptParserHexIntegerLiteral, TypeScriptParserOctalIntegerLiteral, TypeScriptParserOctalIntegerLiteral2, TypeScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1457)
			p.NumericLiteral()
		}

	case TypeScriptParserOpenBracket:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1458)
			p.Match(TypeScriptParserOpenBracket)
		}
		{
			p.SetState(1459)
			p.singleExpression(0)
		}
		{
			p.SetState(1460)
			p.Match(TypeScriptParserCloseBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ArgumentsContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ArgumentsContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentsContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentsContext) LastArgument() ILastArgumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastArgumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastArgumentContext)
}

func (s *ArgumentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ArgumentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *TypeScriptParser) Arguments() (localctx IArgumentsContext) {
	this := p
	_ = this

	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, TypeScriptParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1464)
		p.Match(TypeScriptParserOpenParen)
	}
	p.SetState(1478)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserRegularExpressionLiteral, TypeScriptParserOpenBracket, TypeScriptParserOpenParen, TypeScriptParserOpenBrace, TypeScriptParserPlusPlus, TypeScriptParserMinusMinus, TypeScriptParserPlus, TypeScriptParserMinus, TypeScriptParserBitNot, TypeScriptParserNot, TypeScriptParserLessThan, TypeScriptParserNullLiteral, TypeScriptParserBooleanLiteral, TypeScriptParserDecimalLiteral, TypeScriptParserHexIntegerLiteral, TypeScriptParserOctalIntegerLiteral, TypeScriptParserOctalIntegerLiteral2, TypeScriptParserBinaryIntegerLiteral, TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserAs, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserAwait, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield, TypeScriptParserIdentifier, TypeScriptParserStringLiteral, TypeScriptParserTemplateStringLiteral:
		{
			p.SetState(1465)
			p.singleExpression(0)
		}
		p.SetState(1470)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1466)
					p.Match(TypeScriptParserComma)
				}
				{
					p.SetState(1467)
					p.singleExpression(0)
				}

			}
			p.SetState(1472)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext())
		}
		p.SetState(1475)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserComma {
			{
				p.SetState(1473)
				p.Match(TypeScriptParserComma)
			}
			{
				p.SetState(1474)
				p.LastArgument()
			}

		}

	case TypeScriptParserEllipsis:
		{
			p.SetState(1477)
			p.LastArgument()
		}

	case TypeScriptParserCloseParen:

	default:
	}
	{
		p.SetState(1480)
		p.Match(TypeScriptParserCloseParen)
	}

	return localctx
}

// ILastArgumentContext is an interface to support dynamic dispatch.
type ILastArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLastArgumentContext differentiates from other interfaces.
	IsLastArgumentContext()
}

type LastArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastArgumentContext() *LastArgumentContext {
	var p = new(LastArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_lastArgument
	return p
}

func (*LastArgumentContext) IsLastArgumentContext() {}

func NewLastArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastArgumentContext {
	var p = new(LastArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_lastArgument

	return p
}

func (s *LastArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *LastArgumentContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEllipsis, 0)
}

func (s *LastArgumentContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *LastArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLastArgument(s)
	}
}

func (s *LastArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLastArgument(s)
	}
}

func (p *TypeScriptParser) LastArgument() (localctx ILastArgumentContext) {
	this := p
	_ = this

	localctx = NewLastArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, TypeScriptParserRULE_lastArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1482)
		p.Match(TypeScriptParserEllipsis)
	}
	{
		p.SetState(1483)
		p.Match(TypeScriptParserIdentifier)
	}

	return localctx
}

// IExpressionSequenceContext is an interface to support dynamic dispatch.
type IExpressionSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionSequenceContext differentiates from other interfaces.
	IsExpressionSequenceContext()
}

type ExpressionSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSequenceContext() *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_expressionSequence
	return p
}

func (*ExpressionSequenceContext) IsExpressionSequenceContext() {}

func NewExpressionSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_expressionSequence

	return p
}

func (s *ExpressionSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSequenceContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionSequenceContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ExpressionSequenceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(TypeScriptParserComma)
}

func (s *ExpressionSequenceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(TypeScriptParserComma, i)
}

func (s *ExpressionSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterExpressionSequence(s)
	}
}

func (s *ExpressionSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitExpressionSequence(s)
	}
}

func (p *TypeScriptParser) ExpressionSequence() (localctx IExpressionSequenceContext) {
	this := p
	_ = this

	localctx = NewExpressionSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, TypeScriptParserRULE_expressionSequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1485)
		p.singleExpression(0)
	}
	p.SetState(1490)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1486)
				p.Match(TypeScriptParserComma)
			}
			{
				p.SetState(1487)
				p.singleExpression(0)
			}

		}
		p.SetState(1492)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())
	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1493)
			p.Match(TypeScriptParserComma)
		}

	}

	return localctx
}

// IFunctionExpressionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionExpressionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionExpressionDeclarationContext differentiates from other interfaces.
	IsFunctionExpressionDeclarationContext()
}

type FunctionExpressionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionExpressionDeclarationContext() *FunctionExpressionDeclarationContext {
	var p = new(FunctionExpressionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_functionExpressionDeclaration
	return p
}

func (*FunctionExpressionDeclarationContext) IsFunctionExpressionDeclarationContext() {}

func NewFunctionExpressionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionExpressionDeclarationContext {
	var p = new(FunctionExpressionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_functionExpressionDeclaration

	return p
}

func (s *FunctionExpressionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionExpressionDeclarationContext) Function() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFunction, 0)
}

func (s *FunctionExpressionDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *FunctionExpressionDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *FunctionExpressionDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *FunctionExpressionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionExpressionDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *FunctionExpressionDeclarationContext) Async() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAsync, 0)
}

func (s *FunctionExpressionDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *FunctionExpressionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionExpressionDeclarationContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FunctionExpressionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionExpressionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFunctionExpressionDeclaration(s)
	}
}

func (s *FunctionExpressionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFunctionExpressionDeclaration(s)
	}
}

func (p *TypeScriptParser) FunctionExpressionDeclaration() (localctx IFunctionExpressionDeclarationContext) {
	this := p
	_ = this

	localctx = NewFunctionExpressionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, TypeScriptParserRULE_functionExpressionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1497)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAsync {
		{
			p.SetState(1496)
			p.Match(TypeScriptParserAsync)
		}

	}
	{
		p.SetState(1499)
		p.Match(TypeScriptParserFunction)
	}
	p.SetState(1501)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserIdentifier {
		{
			p.SetState(1500)
			p.Match(TypeScriptParserIdentifier)
		}

	}
	{
		p.SetState(1503)
		p.Match(TypeScriptParserOpenParen)
	}
	p.SetState(1505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&8388627) != 0 {
		{
			p.SetState(1504)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1507)
		p.Match(TypeScriptParserCloseParen)
	}
	p.SetState(1509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(1508)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(1511)
		p.Match(TypeScriptParserOpenBrace)
	}
	{
		p.SetState(1512)
		p.FunctionBody()
	}
	{
		p.SetState(1513)
		p.Match(TypeScriptParserCloseBrace)
	}

	return localctx
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_singleExpression
	return p
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) CopyFrom(ctx *SingleExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TemplateStringExpressionContext struct {
	*SingleExpressionContext
}

func NewTemplateStringExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TemplateStringExpressionContext {
	var p = new(TemplateStringExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TemplateStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TemplateStringExpressionContext) TemplateStringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTemplateStringLiteral, 0)
}

func (s *TemplateStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTemplateStringExpression(s)
	}
}

func (s *TemplateStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTemplateStringExpression(s)
	}
}

type GeneratorsExpressionContext struct {
	*SingleExpressionContext
}

func NewGeneratorsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GeneratorsExpressionContext {
	var p = new(GeneratorsExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *GeneratorsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorsExpressionContext) GeneratorBlock() IGeneratorBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratorBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratorBlockContext)
}

func (s *GeneratorsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorsExpression(s)
	}
}

func (s *GeneratorsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorsExpression(s)
	}
}

type PowerExpressionContext struct {
	*SingleExpressionContext
}

func NewPowerExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExpressionContext {
	var p = new(PowerExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PowerExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PowerExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PowerExpressionContext) Power() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPower, 0)
}

func (s *PowerExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPowerExpression(s)
	}
}

func (s *PowerExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPowerExpression(s)
	}
}

type InExpressionContext struct {
	*SingleExpressionContext
}

func NewInExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InExpressionContext {
	var p = new(InExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *InExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InExpressionContext) In() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIn, 0)
}

func (s *InExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterInExpression(s)
	}
}

func (s *InExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitInExpression(s)
	}
}

type GenericTypesContext struct {
	*SingleExpressionContext
}

func NewGenericTypesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GenericTypesContext {
	var p = new(GenericTypesContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *GenericTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTypesContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *GenericTypesContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *GenericTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGenericTypes(s)
	}
}

func (s *GenericTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGenericTypes(s)
	}
}

type ArgumentsExpressionContext struct {
	*SingleExpressionContext
}

func NewArgumentsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArgumentsExpressionContext {
	var p = new(ArgumentsExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArgumentsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentsExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArgumentsExpression(s)
	}
}

func (s *ArgumentsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArgumentsExpression(s)
	}
}

type ThisExpressionContext struct {
	*SingleExpressionContext
}

func NewThisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) This() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserThis, 0)
}

func (s *ThisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterThisExpression(s)
	}
}

func (s *ThisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitThisExpression(s)
	}
}

type TypeofExpressionContext struct {
	*SingleExpressionContext
}

func NewTypeofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeofExpressionContext {
	var p = new(TypeofExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TypeofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeofExpressionContext) Typeof() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTypeof, 0)
}

func (s *TypeofExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TypeofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTypeofExpression(s)
	}
}

func (s *TypeofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTypeofExpression(s)
	}
}

type GeneratorsFunctionExpressionContext struct {
	*SingleExpressionContext
}

func NewGeneratorsFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GeneratorsFunctionExpressionContext {
	var p = new(GeneratorsFunctionExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *GeneratorsFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorsFunctionExpressionContext) GeneratorFunctionDeclaration() IGeneratorFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratorFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratorFunctionDeclarationContext)
}

func (s *GeneratorsFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGeneratorsFunctionExpression(s)
	}
}

func (s *GeneratorsFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGeneratorsFunctionExpression(s)
	}
}

type EqualityExpressionContext struct {
	*SingleExpressionContext
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *EqualityExpressionContext) Equals_() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEquals_, 0)
}

func (s *EqualityExpressionContext) NotEquals() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNotEquals, 0)
}

func (s *EqualityExpressionContext) IdentityEquals() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentityEquals, 0)
}

func (s *EqualityExpressionContext) IdentityNotEquals() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentityNotEquals, 0)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

type BitXOrExpressionContext struct {
	*SingleExpressionContext
}

func NewBitXOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitXOrExpressionContext {
	var p = new(BitXOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitXOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitXOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitXOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitXOrExpressionContext) BitXOr() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitXOr, 0)
}

func (s *BitXOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBitXOrExpression(s)
	}
}

func (s *BitXOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBitXOrExpression(s)
	}
}

type MultiplicativeExpressionContext struct {
	*SingleExpressionContext
}

func NewMultiplicativeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MultiplicativeExpressionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiply, 0)
}

func (s *MultiplicativeExpressionContext) Divide() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDivide, 0)
}

func (s *MultiplicativeExpressionContext) Modulus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserModulus, 0)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

type BitShiftExpressionContext struct {
	*SingleExpressionContext
}

func NewBitShiftExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitShiftExpressionContext {
	var p = new(BitShiftExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitShiftExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitShiftExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitShiftExpressionContext) LeftShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLeftShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRightShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftLogical() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRightShiftLogical, 0)
}

func (s *BitShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBitShiftExpression(s)
	}
}

func (s *BitShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBitShiftExpression(s)
	}
}

type AdditiveExpressionContext struct {
	*SingleExpressionContext
}

func NewAdditiveExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AdditiveExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPlus, 0)
}

func (s *AdditiveExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMinus, 0)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

type RelationalExpressionContext struct {
	*SingleExpressionContext
}

func NewRelationalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *RelationalExpressionContext) LessThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThan, 0)
}

func (s *RelationalExpressionContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMoreThan, 0)
}

func (s *RelationalExpressionContext) LessThanEquals() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLessThanEquals, 0)
}

func (s *RelationalExpressionContext) GreaterThanEquals() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserGreaterThanEquals, 0)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

type BitNotExpressionContext struct {
	*SingleExpressionContext
}

func NewBitNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitNotExpressionContext {
	var p = new(BitNotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitNotExpressionContext) BitNot() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitNot, 0)
}

func (s *BitNotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitNotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBitNotExpression(s)
	}
}

func (s *BitNotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBitNotExpression(s)
	}
}

type NewExpressionContext struct {
	*SingleExpressionContext
}

func NewNewExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewExpressionContext {
	var p = new(NewExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *NewExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExpressionContext) New() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNew, 0)
}

func (s *NewExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NewExpressionContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *NewExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *NewExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterNewExpression(s)
	}
}

func (s *NewExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitNewExpression(s)
	}
}

type LiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

type ArrayLiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewArrayLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayLiteralExpressionContext {
	var p = new(ArrayLiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArrayLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *ArrayLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrayLiteralExpression(s)
	}
}

func (s *ArrayLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrayLiteralExpression(s)
	}
}

type MemberDotExpressionContext struct {
	*SingleExpressionContext
}

func NewMemberDotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberDotExpressionContext {
	var p = new(MemberDotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberDotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberDotExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDot, 0)
}

func (s *MemberDotExpressionContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *MemberDotExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserQuestionMark, 0)
}

func (s *MemberDotExpressionContext) Hashtag() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserHashtag, 0)
}

func (s *MemberDotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMemberDotExpression(s)
	}
}

func (s *MemberDotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMemberDotExpression(s)
	}
}

type MemberIndexExpressionContext struct {
	*SingleExpressionContext
}

func NewMemberIndexExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberIndexExpressionContext {
	var p = new(MemberIndexExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberIndexExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberIndexExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberIndexExpressionContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBracket, 0)
}

func (s *MemberIndexExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *MemberIndexExpressionContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBracket, 0)
}

func (s *MemberIndexExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterMemberIndexExpression(s)
	}
}

func (s *MemberIndexExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitMemberIndexExpression(s)
	}
}

type BitAndExpressionContext struct {
	*SingleExpressionContext
}

func NewBitAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitAndExpressionContext {
	var p = new(BitAndExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitAndExpressionContext) BitAnd() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitAnd, 0)
}

func (s *BitAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBitAndExpression(s)
	}
}

func (s *BitAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBitAndExpression(s)
	}
}

type BitOrExpressionContext struct {
	*SingleExpressionContext
}

func NewBitOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitOrExpressionContext {
	var p = new(BitOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitOrExpressionContext) BitOr() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitOr, 0)
}

func (s *BitOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterBitOrExpression(s)
	}
}

func (s *BitOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitBitOrExpression(s)
	}
}

type AssignmentOperatorExpressionContext struct {
	*SingleExpressionContext
}

func NewAssignmentOperatorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentOperatorExpressionContext {
	var p = new(AssignmentOperatorExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentOperatorExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentOperatorExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAssignmentOperatorExpression(s)
	}
}

func (s *AssignmentOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAssignmentOperatorExpression(s)
	}
}

type VoidExpressionContext struct {
	*SingleExpressionContext
}

func NewVoidExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VoidExpressionContext {
	var p = new(VoidExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *VoidExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VoidExpressionContext) Void() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserVoid, 0)
}

func (s *VoidExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VoidExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterVoidExpression(s)
	}
}

func (s *VoidExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitVoidExpression(s)
	}
}

type TernaryExpressionContext struct {
	*SingleExpressionContext
}

func NewTernaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TernaryExpressionContext {
	var p = new(TernaryExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TernaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TernaryExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TernaryExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserQuestionMark, 0)
}

func (s *TernaryExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserColon, 0)
}

func (s *TernaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitTernaryExpression(s)
	}
}

type LogicalAndExpressionContext struct {
	*SingleExpressionContext
}

func NewLogicalAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalAndExpressionContext) And() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAnd, 0)
}

func (s *LogicalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLogicalAndExpression(s)
	}
}

type PreIncrementExpressionContext struct {
	*SingleExpressionContext
}

func NewPreIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreIncrementExpressionContext {
	var p = new(PreIncrementExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPlusPlus, 0)
}

func (s *PreIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPreIncrementExpression(s)
	}
}

type ObjectLiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewObjectLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectLiteralExpressionContext {
	var p = new(ObjectLiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ObjectLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *ObjectLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterObjectLiteralExpression(s)
	}
}

func (s *ObjectLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitObjectLiteralExpression(s)
	}
}

type LogicalOrExpressionContext struct {
	*SingleExpressionContext
}

func NewLogicalOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalOrExpressionContext) Or() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOr, 0)
}

func (s *LogicalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLogicalOrExpression(s)
	}
}

type NotExpressionContext struct {
	*SingleExpressionContext
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Not() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNot, 0)
}

func (s *NotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

type PreDecreaseExpressionContext struct {
	*SingleExpressionContext
}

func NewPreDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreDecreaseExpressionContext {
	var p = new(PreDecreaseExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMinusMinus, 0)
}

func (s *PreDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPreDecreaseExpression(s)
	}
}

func (s *PreDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPreDecreaseExpression(s)
	}
}

type AwaitExpressionContext struct {
	*SingleExpressionContext
}

func NewAwaitExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AwaitExpressionContext {
	var p = new(AwaitExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AwaitExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AwaitExpressionContext) Await() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAwait, 0)
}

func (s *AwaitExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AwaitExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAwaitExpression(s)
	}
}

func (s *AwaitExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAwaitExpression(s)
	}
}

type FunctionExpressionContext struct {
	*SingleExpressionContext
}

func NewFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *FunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionContext) FunctionExpressionDeclaration() IFunctionExpressionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionExpressionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionExpressionDeclarationContext)
}

func (s *FunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitFunctionExpression(s)
	}
}

type UnaryMinusExpressionContext struct {
	*SingleExpressionContext
}

func NewUnaryMinusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryMinusExpressionContext {
	var p = new(UnaryMinusExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryMinusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryMinusExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMinus, 0)
}

func (s *UnaryMinusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryMinusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterUnaryMinusExpression(s)
	}
}

func (s *UnaryMinusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitUnaryMinusExpression(s)
	}
}

type AssignmentExpressionContext struct {
	*SingleExpressionContext
}

func NewAssignmentExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentExpressionContext) Assign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAssign, 0)
}

func (s *AssignmentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAssignmentExpression(s)
	}
}

type PostDecreaseExpressionContext struct {
	*SingleExpressionContext
}

func NewPostDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostDecreaseExpressionContext {
	var p = new(PostDecreaseExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMinusMinus, 0)
}

func (s *PostDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPostDecreaseExpression(s)
	}
}

func (s *PostDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPostDecreaseExpression(s)
	}
}

type InstanceofExpressionContext struct {
	*SingleExpressionContext
}

func NewInstanceofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceofExpressionContext {
	var p = new(InstanceofExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *InstanceofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceofExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InstanceofExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InstanceofExpressionContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserInstanceof, 0)
}

func (s *InstanceofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterInstanceofExpression(s)
	}
}

func (s *InstanceofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitInstanceofExpression(s)
	}
}

type UnaryPlusExpressionContext struct {
	*SingleExpressionContext
}

func NewUnaryPlusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryPlusExpressionContext {
	var p = new(UnaryPlusExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryPlusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPlusExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPlus, 0)
}

func (s *UnaryPlusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryPlusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterUnaryPlusExpression(s)
	}
}

func (s *UnaryPlusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitUnaryPlusExpression(s)
	}
}

type DeleteExpressionContext struct {
	*SingleExpressionContext
}

func NewDeleteExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteExpressionContext {
	var p = new(DeleteExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *DeleteExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteExpressionContext) Delete() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDelete, 0)
}

func (s *DeleteExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *DeleteExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitDeleteExpression(s)
	}
}

type ArrowFunctionExpressionContext struct {
	*SingleExpressionContext
}

func NewArrowFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowFunctionExpressionContext {
	var p = new(ArrowFunctionExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArrowFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionExpressionContext) ArrowFunctionDeclaration() IArrowFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionDeclarationContext)
}

func (s *ArrowFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrowFunctionExpression(s)
	}
}

func (s *ArrowFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrowFunctionExpression(s)
	}
}

type IteratorsExpressionContext struct {
	*SingleExpressionContext
}

func NewIteratorsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IteratorsExpressionContext {
	var p = new(IteratorsExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *IteratorsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorsExpressionContext) IteratorBlock() IIteratorBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIteratorBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIteratorBlockContext)
}

func (s *IteratorsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIteratorsExpression(s)
	}
}

func (s *IteratorsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIteratorsExpression(s)
	}
}

type SuperExpressionContext struct {
	*SingleExpressionContext
}

func NewSuperExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuperExpressionContext {
	var p = new(SuperExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *SuperExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperExpressionContext) Super() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSuper, 0)
}

func (s *SuperExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSuperExpression(s)
	}
}

func (s *SuperExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSuperExpression(s)
	}
}

type ParenthesizedExpressionContext struct {
	*SingleExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ParenthesizedExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ParenthesizedExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type PostIncrementExpressionContext struct {
	*SingleExpressionContext
}

func NewPostIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostIncrementExpressionContext {
	var p = new(PostIncrementExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPlusPlus, 0)
}

func (s *PostIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitPostIncrementExpression(s)
	}
}

type YieldExpressionContext struct {
	*SingleExpressionContext
}

func NewYieldExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *YieldExpressionContext {
	var p = new(YieldExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *YieldExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldExpressionContext) YieldStatement() IYieldStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *YieldExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterYieldExpression(s)
	}
}

func (s *YieldExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitYieldExpression(s)
	}
}

type ClassExpressionContext struct {
	*SingleExpressionContext
}

func NewClassExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClassExpressionContext {
	var p = new(ClassExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ClassExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassExpressionContext) Class() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserClass, 0)
}

func (s *ClassExpressionContext) ClassTail() IClassTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTailContext)
}

func (s *ClassExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ClassExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterClassExpression(s)
	}
}

func (s *ClassExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitClassExpression(s)
	}
}

type IdentifierExpressionContext struct {
	*SingleExpressionContext
}

func NewIdentifierExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierExpressionContext {
	var p = new(IdentifierExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *IdentifierExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierExpressionContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *IdentifierExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *IdentifierExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIdentifierExpression(s)
	}
}

func (s *IdentifierExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIdentifierExpression(s)
	}
}

type CoalesceExpressionContext struct {
	*SingleExpressionContext
}

func NewCoalesceExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CoalesceExpressionContext {
	var p = new(CoalesceExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *CoalesceExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CoalesceExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CoalesceExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *CoalesceExpressionContext) NullCoalesce() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNullCoalesce, 0)
}

func (s *CoalesceExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterCoalesceExpression(s)
	}
}

func (s *CoalesceExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitCoalesceExpression(s)
	}
}

func (p *TypeScriptParser) SingleExpression() (localctx ISingleExpressionContext) {
	return p.singleExpression(0)
}

func (p *TypeScriptParser) singleExpression(_p int) (localctx ISingleExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISingleExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 254
	p.EnterRecursionRule(localctx, 254, TypeScriptParserRULE_singleExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1572)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1516)
			p.FunctionExpressionDeclaration()
		}

	case 2:
		localctx = NewArrowFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1517)
			p.ArrowFunctionDeclaration()
		}

	case 3:
		localctx = NewClassExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1518)
			p.Match(TypeScriptParserClass)
		}
		p.SetState(1520)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TypeScriptParserIdentifier {
			{
				p.SetState(1519)
				p.Match(TypeScriptParserIdentifier)
			}

		}
		{
			p.SetState(1522)
			p.ClassTail()
		}

	case 4:
		localctx = NewNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1523)
			p.Match(TypeScriptParserNew)
		}
		{
			p.SetState(1524)
			p.singleExpression(0)
		}
		p.SetState(1526)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1525)
				p.TypeArguments()
			}

		}
		p.SetState(1529)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1528)
				p.Arguments()
			}

		}

	case 5:
		localctx = NewDeleteExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1531)
			p.Match(TypeScriptParserDelete)
		}
		{
			p.SetState(1532)
			p.singleExpression(40)
		}

	case 6:
		localctx = NewVoidExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1533)
			p.Match(TypeScriptParserVoid)
		}
		{
			p.SetState(1534)
			p.singleExpression(39)
		}

	case 7:
		localctx = NewTypeofExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1535)
			p.Match(TypeScriptParserTypeof)
		}
		{
			p.SetState(1536)
			p.singleExpression(38)
		}

	case 8:
		localctx = NewPreIncrementExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1537)
			p.Match(TypeScriptParserPlusPlus)
		}
		{
			p.SetState(1538)
			p.singleExpression(37)
		}

	case 9:
		localctx = NewPreDecreaseExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1539)
			p.Match(TypeScriptParserMinusMinus)
		}
		{
			p.SetState(1540)
			p.singleExpression(36)
		}

	case 10:
		localctx = NewUnaryPlusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1541)
			p.Match(TypeScriptParserPlus)
		}
		{
			p.SetState(1542)
			p.singleExpression(35)
		}

	case 11:
		localctx = NewUnaryMinusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1543)
			p.Match(TypeScriptParserMinus)
		}
		{
			p.SetState(1544)
			p.singleExpression(34)
		}

	case 12:
		localctx = NewBitNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1545)
			p.Match(TypeScriptParserBitNot)
		}
		{
			p.SetState(1546)
			p.singleExpression(33)
		}

	case 13:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1547)
			p.Match(TypeScriptParserNot)
		}
		{
			p.SetState(1548)
			p.singleExpression(32)
		}

	case 14:
		localctx = NewAwaitExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1549)
			p.Match(TypeScriptParserAwait)
		}
		{
			p.SetState(1550)
			p.singleExpression(31)
		}

	case 15:
		localctx = NewIteratorsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1551)
			p.IteratorBlock()
		}

	case 16:
		localctx = NewGeneratorsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1552)
			p.GeneratorBlock()
		}

	case 17:
		localctx = NewGeneratorsFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1553)
			p.GeneratorFunctionDeclaration()
		}

	case 18:
		localctx = NewYieldExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1554)
			p.YieldStatement()
		}

	case 19:
		localctx = NewThisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1555)
			p.Match(TypeScriptParserThis)
		}

	case 20:
		localctx = NewIdentifierExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1556)
			p.IdentifierName()
		}
		p.SetState(1558)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1557)
				p.singleExpression(0)
			}

		}

	case 21:
		localctx = NewSuperExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1560)
			p.Match(TypeScriptParserSuper)
		}

	case 22:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1561)
			p.Literal()
		}

	case 23:
		localctx = NewArrayLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1562)
			p.ArrayLiteral()
		}

	case 24:
		localctx = NewObjectLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1563)
			p.ObjectLiteral()
		}

	case 25:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1564)
			p.Match(TypeScriptParserOpenParen)
		}
		{
			p.SetState(1565)
			p.ExpressionSequence()
		}
		{
			p.SetState(1566)
			p.Match(TypeScriptParserCloseParen)
		}

	case 26:
		localctx = NewGenericTypesContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1568)
			p.TypeArguments()
		}
		p.SetState(1570)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1569)
				p.ExpressionSequence()
			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1655)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1653)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPowerExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1574)

				if !(p.Precpred(p.GetParserRuleContext(), 30)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 30)", ""))
				}
				{
					p.SetState(1575)
					p.Match(TypeScriptParserPower)
				}
				{
					p.SetState(1576)
					p.singleExpression(30)
				}

			case 2:
				localctx = NewMultiplicativeExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1577)

				if !(p.Precpred(p.GetParserRuleContext(), 29)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 29)", ""))
				}
				{
					p.SetState(1578)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&419430400) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1579)
					p.singleExpression(30)
				}

			case 3:
				localctx = NewAdditiveExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1580)

				if !(p.Precpred(p.GetParserRuleContext(), 28)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 28)", ""))
				}
				{
					p.SetState(1581)
					_la = p.GetTokenStream().LA(1)

					if !(_la == TypeScriptParserPlus || _la == TypeScriptParserMinus) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1582)
					p.singleExpression(29)
				}

			case 4:
				localctx = NewBitShiftExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1583)

				if !(p.Precpred(p.GetParserRuleContext(), 27)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 27)", ""))
				}
				{
					p.SetState(1584)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&30064771072) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1585)
					p.singleExpression(28)
				}

			case 5:
				localctx = NewRelationalExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1586)

				if !(p.Precpred(p.GetParserRuleContext(), 26)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 26)", ""))
				}
				{
					p.SetState(1587)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&515396075520) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1588)
					p.singleExpression(27)
				}

			case 6:
				localctx = NewInstanceofExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1589)

				if !(p.Precpred(p.GetParserRuleContext(), 25)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 25)", ""))
				}
				{
					p.SetState(1590)
					p.Match(TypeScriptParserInstanceof)
				}
				{
					p.SetState(1591)
					p.singleExpression(26)
				}

			case 7:
				localctx = NewInExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1592)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
				}
				{
					p.SetState(1593)
					p.Match(TypeScriptParserIn)
				}
				{
					p.SetState(1594)
					p.singleExpression(25)
				}

			case 8:
				localctx = NewEqualityExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1595)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
				}
				{
					p.SetState(1596)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8246337208320) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1597)
					p.singleExpression(24)
				}

			case 9:
				localctx = NewBitAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1598)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
				}
				{
					p.SetState(1599)
					p.Match(TypeScriptParserBitAnd)
				}
				{
					p.SetState(1600)
					p.singleExpression(23)
				}

			case 10:
				localctx = NewBitXOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1601)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(1602)
					p.Match(TypeScriptParserBitXOr)
				}
				{
					p.SetState(1603)
					p.singleExpression(22)
				}

			case 11:
				localctx = NewBitOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1604)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				{
					p.SetState(1605)
					p.Match(TypeScriptParserBitOr)
				}
				{
					p.SetState(1606)
					p.singleExpression(21)
				}

			case 12:
				localctx = NewLogicalAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1607)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				{
					p.SetState(1608)
					p.Match(TypeScriptParserAnd)
				}
				{
					p.SetState(1609)
					p.singleExpression(20)
				}

			case 13:
				localctx = NewLogicalOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1610)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(1611)
					p.Match(TypeScriptParserOr)
				}
				{
					p.SetState(1612)
					p.singleExpression(19)
				}

			case 14:
				localctx = NewTernaryExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1613)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(1614)
					p.Match(TypeScriptParserQuestionMark)
				}
				{
					p.SetState(1615)
					p.singleExpression(0)
				}
				{
					p.SetState(1616)
					p.Match(TypeScriptParserColon)
				}
				{
					p.SetState(1617)
					p.singleExpression(18)
				}

			case 15:
				localctx = NewCoalesceExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1619)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(1620)
					p.Match(TypeScriptParserNullCoalesce)
				}
				{
					p.SetState(1621)
					p.singleExpression(17)
				}

			case 16:
				localctx = NewAssignmentExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1622)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(1623)
					p.Match(TypeScriptParserAssign)
				}
				{
					p.SetState(1624)
					p.singleExpression(15)
				}

			case 17:
				localctx = NewAssignmentOperatorExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1625)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(1626)
					p.AssignmentOperator()
				}
				{
					p.SetState(1627)
					p.singleExpression(14)
				}

			case 18:
				localctx = NewMemberIndexExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1629)

				if !(p.Precpred(p.GetParserRuleContext(), 46)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 46)", ""))
				}
				{
					p.SetState(1630)
					p.Match(TypeScriptParserOpenBracket)
				}
				{
					p.SetState(1631)
					p.ExpressionSequence()
				}
				{
					p.SetState(1632)
					p.Match(TypeScriptParserCloseBracket)
				}

			case 19:
				localctx = NewMemberDotExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1634)

				if !(p.Precpred(p.GetParserRuleContext(), 45)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 45)", ""))
				}
				p.SetState(1636)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TypeScriptParserQuestionMark {
					{
						p.SetState(1635)
						p.Match(TypeScriptParserQuestionMark)
					}

				}
				{
					p.SetState(1638)
					p.Match(TypeScriptParserDot)
				}
				p.SetState(1640)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TypeScriptParserHashtag {
					{
						p.SetState(1639)
						p.Match(TypeScriptParserHashtag)
					}

				}
				{
					p.SetState(1642)
					p.IdentifierName()
				}

			case 20:
				localctx = NewArgumentsExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1643)

				if !(p.Precpred(p.GetParserRuleContext(), 44)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 44)", ""))
				}
				{
					p.SetState(1644)
					p.Arguments()
				}

			case 21:
				localctx = NewPostIncrementExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1645)

				if !(p.Precpred(p.GetParserRuleContext(), 42)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 42)", ""))
				}
				p.SetState(1646)

				if !(p.notLineTerminator()) {
					panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
				}
				{
					p.SetState(1647)
					p.Match(TypeScriptParserPlusPlus)
				}

			case 22:
				localctx = NewPostDecreaseExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1648)

				if !(p.Precpred(p.GetParserRuleContext(), 41)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 41)", ""))
				}
				p.SetState(1649)

				if !(p.notLineTerminator()) {
					panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
				}
				{
					p.SetState(1650)
					p.Match(TypeScriptParserMinusMinus)
				}

			case 23:
				localctx = NewTemplateStringExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TypeScriptParserRULE_singleExpression)
				p.SetState(1651)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(1652)
					p.Match(TypeScriptParserTemplateStringLiteral)
				}

			}

		}
		p.SetState(1657)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext())
	}

	return localctx
}

// IArrowFunctionDeclarationContext is an interface to support dynamic dispatch.
type IArrowFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowFunctionDeclarationContext differentiates from other interfaces.
	IsArrowFunctionDeclarationContext()
}

type ArrowFunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionDeclarationContext() *ArrowFunctionDeclarationContext {
	var p = new(ArrowFunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionDeclaration
	return p
}

func (*ArrowFunctionDeclarationContext) IsArrowFunctionDeclarationContext() {}

func NewArrowFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionDeclarationContext {
	var p = new(ArrowFunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionDeclaration

	return p
}

func (s *ArrowFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionDeclarationContext) ArrowFunctionParameters() IArrowFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionParametersContext)
}

func (s *ArrowFunctionDeclarationContext) ARROW() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserARROW, 0)
}

func (s *ArrowFunctionDeclarationContext) ArrowFunctionBody() IArrowFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionBodyContext)
}

func (s *ArrowFunctionDeclarationContext) Async() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAsync, 0)
}

func (s *ArrowFunctionDeclarationContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *ArrowFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrowFunctionDeclaration(s)
	}
}

func (s *ArrowFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrowFunctionDeclaration(s)
	}
}

func (p *TypeScriptParser) ArrowFunctionDeclaration() (localctx IArrowFunctionDeclarationContext) {
	this := p
	_ = this

	localctx = NewArrowFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, TypeScriptParserRULE_arrowFunctionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1659)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserAsync {
		{
			p.SetState(1658)
			p.Match(TypeScriptParserAsync)
		}

	}
	{
		p.SetState(1661)
		p.ArrowFunctionParameters()
	}
	p.SetState(1663)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TypeScriptParserColon {
		{
			p.SetState(1662)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(1665)
		p.Match(TypeScriptParserARROW)
	}
	{
		p.SetState(1666)
		p.ArrowFunctionBody()
	}

	return localctx
}

// IArrowFunctionParametersContext is an interface to support dynamic dispatch.
type IArrowFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowFunctionParametersContext differentiates from other interfaces.
	IsArrowFunctionParametersContext()
}

type ArrowFunctionParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionParametersContext() *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionParameters
	return p
}

func (*ArrowFunctionParametersContext) IsArrowFunctionParametersContext() {}

func NewArrowFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionParameters

	return p
}

func (s *ArrowFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionParametersContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *ArrowFunctionParametersContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenParen, 0)
}

func (s *ArrowFunctionParametersContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseParen, 0)
}

func (s *ArrowFunctionParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ArrowFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrowFunctionParameters(s)
	}
}

func (s *ArrowFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrowFunctionParameters(s)
	}
}

func (p *TypeScriptParser) ArrowFunctionParameters() (localctx IArrowFunctionParametersContext) {
	this := p
	_ = this

	localctx = NewArrowFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, TypeScriptParserRULE_arrowFunctionParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1674)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1668)
			p.Match(TypeScriptParserIdentifier)
		}

	case TypeScriptParserOpenParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1669)
			p.Match(TypeScriptParserOpenParen)
		}
		p.SetState(1671)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&8388627) != 0 {
			{
				p.SetState(1670)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(1673)
			p.Match(TypeScriptParserCloseParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrowFunctionBodyContext is an interface to support dynamic dispatch.
type IArrowFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowFunctionBodyContext differentiates from other interfaces.
	IsArrowFunctionBodyContext()
}

type ArrowFunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionBodyContext() *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionBody
	return p
}

func (*ArrowFunctionBodyContext) IsArrowFunctionBodyContext() {}

func NewArrowFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_arrowFunctionBody

	return p
}

func (s *ArrowFunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionBodyContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrowFunctionBodyContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOpenBrace, 0)
}

func (s *ArrowFunctionBodyContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *ArrowFunctionBodyContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCloseBrace, 0)
}

func (s *ArrowFunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterArrowFunctionBody(s)
	}
}

func (s *ArrowFunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitArrowFunctionBody(s)
	}
}

func (p *TypeScriptParser) ArrowFunctionBody() (localctx IArrowFunctionBodyContext) {
	this := p
	_ = this

	localctx = NewArrowFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, TypeScriptParserRULE_arrowFunctionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1681)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1676)
			p.singleExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1677)
			p.Match(TypeScriptParserOpenBrace)
		}
		{
			p.SetState(1678)
			p.FunctionBody()
		}
		{
			p.SetState(1679)
			p.Match(TypeScriptParserCloseBrace)
		}

	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) MultiplyAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMultiplyAssign, 0)
}

func (s *AssignmentOperatorContext) DivideAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDivideAssign, 0)
}

func (s *AssignmentOperatorContext) ModulusAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserModulusAssign, 0)
}

func (s *AssignmentOperatorContext) PlusAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPlusAssign, 0)
}

func (s *AssignmentOperatorContext) MinusAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserMinusAssign, 0)
}

func (s *AssignmentOperatorContext) LeftShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLeftShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRightShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftLogicalAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRightShiftLogicalAssign, 0)
}

func (s *AssignmentOperatorContext) BitAndAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitAndAssign, 0)
}

func (s *AssignmentOperatorContext) BitXorAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitXorAssign, 0)
}

func (s *AssignmentOperatorContext) BitOrAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBitOrAssign, 0)
}

func (s *AssignmentOperatorContext) PowerAssign() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPowerAssign, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (p *TypeScriptParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	this := p
	_ = this

	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, TypeScriptParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1683)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1729100781933559808) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNullLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBooleanLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStringLiteral, 0)
}

func (s *LiteralContext) TemplateStringLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTemplateStringLiteral, 0)
}

func (s *LiteralContext) RegularExpressionLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserRegularExpressionLiteral, 0)
}

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *TypeScriptParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, TypeScriptParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1691)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1685)
			p.Match(TypeScriptParserNullLiteral)
		}

	case TypeScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1686)
			p.Match(TypeScriptParserBooleanLiteral)
		}

	case TypeScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1687)
			p.Match(TypeScriptParserStringLiteral)
		}

	case TypeScriptParserTemplateStringLiteral:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1688)
			p.Match(TypeScriptParserTemplateStringLiteral)
		}

	case TypeScriptParserRegularExpressionLiteral:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1689)
			p.Match(TypeScriptParserRegularExpressionLiteral)
		}

	case TypeScriptParserDecimalLiteral, TypeScriptParserHexIntegerLiteral, TypeScriptParserOctalIntegerLiteral, TypeScriptParserOctalIntegerLiteral2, TypeScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1690)
			p.NumericLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_numericLiteral
	return p
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) DecimalLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDecimalLiteral, 0)
}

func (s *NumericLiteralContext) HexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserHexIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOctalIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral2() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserOctalIntegerLiteral2, 0)
}

func (s *NumericLiteralContext) BinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBinaryIntegerLiteral, 0)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (p *TypeScriptParser) NumericLiteral() (localctx INumericLiteralContext) {
	this := p
	_ = this

	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, TypeScriptParserRULE_numericLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1693)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-63)) & ^0x3f) == 0 && ((int64(1)<<(_la-63))&31) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifierNameContext is an interface to support dynamic dispatch.
type IIdentifierNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierNameContext differentiates from other interfaces.
	IsIdentifierNameContext()
}

type IdentifierNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierNameContext() *IdentifierNameContext {
	var p = new(IdentifierNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_identifierName
	return p
}

func (*IdentifierNameContext) IsIdentifierNameContext() {}

func NewIdentifierNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierNameContext {
	var p = new(IdentifierNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_identifierName

	return p
}

func (s *IdentifierNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *IdentifierNameContext) ReservedWord() IReservedWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedWordContext)
}

func (s *IdentifierNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterIdentifierName(s)
	}
}

func (s *IdentifierNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitIdentifierName(s)
	}
}

func (p *TypeScriptParser) IdentifierName() (localctx IIdentifierNameContext) {
	this := p
	_ = this

	localctx = NewIdentifierNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, TypeScriptParserRULE_identifierName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1697)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1695)
			p.Match(TypeScriptParserIdentifier)
		}

	case TypeScriptParserNullLiteral, TypeScriptParserBooleanLiteral, TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserAs, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserAwait, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1696)
			p.ReservedWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_reservedWord
	return p
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedWordContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *ReservedWordContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNullLiteral, 0)
}

func (s *ReservedWordContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBooleanLiteral, 0)
}

func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterReservedWord(s)
	}
}

func (s *ReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitReservedWord(s)
	}
}

func (p *TypeScriptParser) ReservedWord() (localctx IReservedWordContext) {
	this := p
	_ = this

	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, TypeScriptParserRULE_reservedWord)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1702)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TypeScriptParserBreak, TypeScriptParserDo, TypeScriptParserInstanceof, TypeScriptParserTypeof, TypeScriptParserCase, TypeScriptParserElse, TypeScriptParserNew, TypeScriptParserVar, TypeScriptParserCatch, TypeScriptParserFinally, TypeScriptParserReturn, TypeScriptParserVoid, TypeScriptParserContinue, TypeScriptParserFor, TypeScriptParserSwitch, TypeScriptParserWhile, TypeScriptParserDebugger, TypeScriptParserFunction, TypeScriptParserThis, TypeScriptParserWith, TypeScriptParserDefault, TypeScriptParserIf, TypeScriptParserThrow, TypeScriptParserDelete, TypeScriptParserIn, TypeScriptParserTry, TypeScriptParserAs, TypeScriptParserFrom, TypeScriptParserReadOnly, TypeScriptParserAsync, TypeScriptParserClass, TypeScriptParserEnum, TypeScriptParserExtends, TypeScriptParserSuper, TypeScriptParserConst, TypeScriptParserExport, TypeScriptParserImport, TypeScriptParserAwait, TypeScriptParserImplements, TypeScriptParserLet, TypeScriptParserPrivate, TypeScriptParserPublic, TypeScriptParserInterface, TypeScriptParserPackage, TypeScriptParserProtected, TypeScriptParserStatic, TypeScriptParserYield:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1699)
			p.Keyword()
		}

	case TypeScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1700)
			p.Match(TypeScriptParserNullLiteral)
		}

	case TypeScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1701)
			p.Match(TypeScriptParserBooleanLiteral)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_keyword
	return p
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) Break() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserBreak, 0)
}

func (s *KeywordContext) Do() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDo, 0)
}

func (s *KeywordContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserInstanceof, 0)
}

func (s *KeywordContext) Typeof() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTypeof, 0)
}

func (s *KeywordContext) Case() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCase, 0)
}

func (s *KeywordContext) Else() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserElse, 0)
}

func (s *KeywordContext) New() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserNew, 0)
}

func (s *KeywordContext) Var() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserVar, 0)
}

func (s *KeywordContext) Catch() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserCatch, 0)
}

func (s *KeywordContext) Finally() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFinally, 0)
}

func (s *KeywordContext) Return() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReturn, 0)
}

func (s *KeywordContext) Void() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserVoid, 0)
}

func (s *KeywordContext) Continue() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserContinue, 0)
}

func (s *KeywordContext) For() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFor, 0)
}

func (s *KeywordContext) Switch() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSwitch, 0)
}

func (s *KeywordContext) While() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserWhile, 0)
}

func (s *KeywordContext) Debugger() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDebugger, 0)
}

func (s *KeywordContext) Function() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFunction, 0)
}

func (s *KeywordContext) This() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserThis, 0)
}

func (s *KeywordContext) With() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserWith, 0)
}

func (s *KeywordContext) Default() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDefault, 0)
}

func (s *KeywordContext) If() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIf, 0)
}

func (s *KeywordContext) Throw() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserThrow, 0)
}

func (s *KeywordContext) Delete() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserDelete, 0)
}

func (s *KeywordContext) In() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIn, 0)
}

func (s *KeywordContext) Try() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserTry, 0)
}

func (s *KeywordContext) ReadOnly() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserReadOnly, 0)
}

func (s *KeywordContext) Async() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAsync, 0)
}

func (s *KeywordContext) From() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserFrom, 0)
}

func (s *KeywordContext) Class() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserClass, 0)
}

func (s *KeywordContext) Enum() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEnum, 0)
}

func (s *KeywordContext) Extends() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExtends, 0)
}

func (s *KeywordContext) Super() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSuper, 0)
}

func (s *KeywordContext) Const() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserConst, 0)
}

func (s *KeywordContext) Export() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserExport, 0)
}

func (s *KeywordContext) Import() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserImport, 0)
}

func (s *KeywordContext) Implements() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserImplements, 0)
}

func (s *KeywordContext) Let() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserLet, 0)
}

func (s *KeywordContext) Private() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPrivate, 0)
}

func (s *KeywordContext) Public() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPublic, 0)
}

func (s *KeywordContext) Interface() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserInterface, 0)
}

func (s *KeywordContext) Package() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserPackage, 0)
}

func (s *KeywordContext) Protected() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserProtected, 0)
}

func (s *KeywordContext) Static() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserStatic, 0)
}

func (s *KeywordContext) Yield() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserYield, 0)
}

func (s *KeywordContext) Await() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAwait, 0)
}

func (s *KeywordContext) As() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserAs, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (p *TypeScriptParser) Keyword() (localctx IKeywordContext) {
	this := p
	_ = this

	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, TypeScriptParserRULE_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1704)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&140737488355327) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_getter
	return p
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *GetterContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterGetter(s)
	}
}

func (s *GetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitGetter(s)
	}
}

func (p *TypeScriptParser) Getter() (localctx IGetterContext) {
	this := p
	_ = this

	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, TypeScriptParserRULE_getter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1706)
		p.Match(TypeScriptParserIdentifier)
	}
	p.SetState(1707)

	if !(p.p("get")) {
		panic(antlr.NewFailedPredicateException(p, "p.p(\"get\")", ""))
	}
	{
		p.SetState(1708)
		p.PropertyName()
	}

	return localctx
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_setter
	return p
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserIdentifier, 0)
}

func (s *SetterContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterSetter(s)
	}
}

func (s *SetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitSetter(s)
	}
}

func (p *TypeScriptParser) Setter() (localctx ISetterContext) {
	this := p
	_ = this

	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, TypeScriptParserRULE_setter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1710)
		p.Match(TypeScriptParserIdentifier)
	}
	p.SetState(1711)

	if !(p.p("set")) {
		panic(antlr.NewFailedPredicateException(p, "p.p(\"set\")", ""))
	}
	{
		p.SetState(1712)
		p.PropertyName()
	}

	return localctx
}

// IEosContext is an interface to support dynamic dispatch.
type IEosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEosContext differentiates from other interfaces.
	IsEosContext()
}

type EosContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosContext() *EosContext {
	var p = new(EosContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TypeScriptParserRULE_eos
	return p
}

func (*EosContext) IsEosContext() {}

func NewEosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosContext {
	var p = new(EosContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TypeScriptParserRULE_eos

	return p
}

func (s *EosContext) GetParser() antlr.Parser { return s.parser }

func (s *EosContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserSemiColon, 0)
}

func (s *EosContext) EOF() antlr.TerminalNode {
	return s.GetToken(TypeScriptParserEOF, 0)
}

func (s *EosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.EnterEos(s)
	}
}

func (s *EosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TypeScriptParserListener); ok {
		listenerT.ExitEos(s)
	}
}

func (p *TypeScriptParser) Eos() (localctx IEosContext) {
	this := p
	_ = this

	localctx = NewEosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, TypeScriptParserRULE_eos)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1718)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 217, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1714)
			p.Match(TypeScriptParserSemiColon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1715)
			p.Match(TypeScriptParserEOF)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1716)

		if !(p.lineTerminatorAhead()) {
			panic(antlr.NewFailedPredicateException(p, "p.lineTerminatorAhead()", ""))
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1717)

		if !(p.closeBrace()) {
			panic(antlr.NewFailedPredicateException(p, "p.closeBrace()", ""))
		}

	}

	return localctx
}

func (p *TypeScriptParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 10:
		var t *UnionOrIntersectionOrPrimaryTypeContext = nil
		if localctx != nil {
			t = localctx.(*UnionOrIntersectionOrPrimaryTypeContext)
		}
		return p.UnionOrIntersectionOrPrimaryType_Sempred(t, predIndex)

	case 11:
		var t *PrimaryTypeContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryTypeContext)
		}
		return p.PrimaryType_Sempred(t, predIndex)

	case 21:
		var t *ArrayTypeContext = nil
		if localctx != nil {
			t = localctx.(*ArrayTypeContext)
		}
		return p.ArrayType_Sempred(t, predIndex)

	case 57:
		var t *DecoratorMemberExpressionContext = nil
		if localctx != nil {
			t = localctx.(*DecoratorMemberExpressionContext)
		}
		return p.DecoratorMemberExpression_Sempred(t, predIndex)

	case 73:
		var t *ExpressionStatementContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionStatementContext)
		}
		return p.ExpressionStatement_Sempred(t, predIndex)

	case 75:
		var t *IterationStatementContext = nil
		if localctx != nil {
			t = localctx.(*IterationStatementContext)
		}
		return p.IterationStatement_Sempred(t, predIndex)

	case 77:
		var t *ContinueStatementContext = nil
		if localctx != nil {
			t = localctx.(*ContinueStatementContext)
		}
		return p.ContinueStatement_Sempred(t, predIndex)

	case 78:
		var t *BreakStatementContext = nil
		if localctx != nil {
			t = localctx.(*BreakStatementContext)
		}
		return p.BreakStatement_Sempred(t, predIndex)

	case 79:
		var t *ReturnStatementContext = nil
		if localctx != nil {
			t = localctx.(*ReturnStatementContext)
		}
		return p.ReturnStatement_Sempred(t, predIndex)

	case 80:
		var t *YieldStatementContext = nil
		if localctx != nil {
			t = localctx.(*YieldStatementContext)
		}
		return p.YieldStatement_Sempred(t, predIndex)

	case 88:
		var t *ThrowStatementContext = nil
		if localctx != nil {
			t = localctx.(*ThrowStatementContext)
		}
		return p.ThrowStatement_Sempred(t, predIndex)

	case 127:
		var t *SingleExpressionContext = nil
		if localctx != nil {
			t = localctx.(*SingleExpressionContext)
		}
		return p.SingleExpression_Sempred(t, predIndex)

	case 137:
		var t *GetterContext = nil
		if localctx != nil {
			t = localctx.(*GetterContext)
		}
		return p.Getter_Sempred(t, predIndex)

	case 138:
		var t *SetterContext = nil
		if localctx != nil {
			t = localctx.(*SetterContext)
		}
		return p.Setter_Sempred(t, predIndex)

	case 139:
		var t *EosContext = nil
		if localctx != nil {
			t = localctx.(*EosContext)
		}
		return p.Eos_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *TypeScriptParser) UnionOrIntersectionOrPrimaryType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) PrimaryType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 3:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) ArrayType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 4:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) DecoratorMemberExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) ExpressionStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 6:
		return p.notOpenBraceAndNotFunction()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) IterationStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 7:
		return p.p("of")

	case 8:
		return p.p("of")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) ContinueStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 9:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) BreakStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 10:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) ReturnStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 11:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) YieldStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 12:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) ThrowStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 13:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) SingleExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 14:
		return p.Precpred(p.GetParserRuleContext(), 30)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 29)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 28)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 27)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 26)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 25)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 24:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 26:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 27:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 28:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 29:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 30:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 31:
		return p.Precpred(p.GetParserRuleContext(), 46)

	case 32:
		return p.Precpred(p.GetParserRuleContext(), 45)

	case 33:
		return p.Precpred(p.GetParserRuleContext(), 44)

	case 34:
		return p.Precpred(p.GetParserRuleContext(), 42)

	case 35:
		return p.notLineTerminator()

	case 36:
		return p.Precpred(p.GetParserRuleContext(), 41)

	case 37:
		return p.notLineTerminator()

	case 38:
		return p.Precpred(p.GetParserRuleContext(), 13)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) Getter_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 39:
		return p.p("get")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) Setter_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 40:
		return p.p("set")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TypeScriptParser) Eos_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 41:
		return p.lineTerminatorAhead()

	case 42:
		return p.closeBrace()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
