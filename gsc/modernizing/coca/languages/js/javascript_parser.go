// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package parser // JavaScriptParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type JavaScriptParser struct {
	JavaScriptBaseParser
}

var javascriptparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func javascriptparserParserInit() {
	staticData := &javascriptparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "", "", "'['", "']'", "'('", "')'", "'{'", "'}'", "';'",
		"','", "'='", "'?'", "':'", "'...'", "'.'", "'++'", "'--'", "'+'", "'-'",
		"'~'", "'!'", "'*'", "'/'", "'%'", "'**'", "'??'", "'#'", "'>>'", "'<<'",
		"'>>>'", "'<'", "'>'", "'<='", "'>='", "'=='", "'!='", "'==='", "'!=='",
		"'&'", "'^'", "'|'", "'&&'", "'||'", "'*='", "'/='", "'%='", "'+='",
		"'-='", "'<<='", "'>>='", "'>>>='", "'&='", "'^='", "'|='", "'**='",
		"'=>'", "'null'", "", "", "", "", "", "", "", "", "", "", "'break'",
		"'do'", "'instanceof'", "'typeof'", "'case'", "'else'", "'new'", "'var'",
		"'catch'", "'finally'", "'return'", "'void'", "'continue'", "'for'",
		"'switch'", "'while'", "'debugger'", "'function'", "'this'", "'with'",
		"'default'", "'if'", "'throw'", "'delete'", "'in'", "'try'", "'as'",
		"'from'", "'class'", "'enum'", "'extends'", "'super'", "'const'", "'export'",
		"'import'", "'async'", "'await'", "'implements'", "'let'", "'private'",
		"'public'", "'interface'", "'package'", "'protected'", "'static'", "'yield'",
	}
	staticData.symbolicNames = []string{
		"", "HashBangLine", "MultiLineComment", "SingleLineComment", "RegularExpressionLiteral",
		"OpenBracket", "CloseBracket", "OpenParen", "CloseParen", "OpenBrace",
		"CloseBrace", "SemiColon", "Comma", "Assign", "QuestionMark", "Colon",
		"Ellipsis", "Dot", "PlusPlus", "MinusMinus", "Plus", "Minus", "BitNot",
		"Not", "Multiply", "Divide", "Modulus", "Power", "NullCoalesce", "Hashtag",
		"RightShiftArithmetic", "LeftShiftArithmetic", "RightShiftLogical",
		"LessThan", "MoreThan", "LessThanEquals", "GreaterThanEquals", "Equals_",
		"NotEquals", "IdentityEquals", "IdentityNotEquals", "BitAnd", "BitXOr",
		"BitOr", "And", "Or", "MultiplyAssign", "DivideAssign", "ModulusAssign",
		"PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign", "RightShiftArithmeticAssign",
		"RightShiftLogicalAssign", "BitAndAssign", "BitXorAssign", "BitOrAssign",
		"PowerAssign", "ARROW", "NullLiteral", "BooleanLiteral", "DecimalLiteral",
		"HexIntegerLiteral", "OctalIntegerLiteral", "OctalIntegerLiteral2",
		"BinaryIntegerLiteral", "BigHexIntegerLiteral", "BigOctalIntegerLiteral",
		"BigBinaryIntegerLiteral", "BigDecimalIntegerLiteral", "Break", "Do",
		"Instanceof", "Typeof", "Case", "Else", "New", "Var", "Catch", "Finally",
		"Return", "Void", "Continue", "For", "Switch", "While", "Debugger",
		"Function", "This", "With", "Default", "If", "Throw", "Delete", "In",
		"Try", "As", "From", "Class", "Enum", "Extends", "Super", "Const", "Export",
		"Import", "Async", "Await", "Implements", "Let", "Private", "Public",
		"Interface", "Package", "Protected", "Static", "Yield", "Identifier",
		"StringLiteral", "TemplateStringLiteral", "WhiteSpaces", "LineTerminator",
		"HtmlComment", "CDataComment", "UnexpectedCharacter",
	}
	staticData.ruleNames = []string{
		"program", "sourceElement", "statement", "block", "statementList", "importStatement",
		"importFromBlock", "moduleItems", "importDefault", "importNamespace",
		"importFrom", "aliasName", "exportStatement", "exportFromBlock", "declaration",
		"variableStatement", "variableDeclarationList", "variableDeclaration",
		"emptyStatement_", "expressionStatement", "ifStatement", "iterationStatement",
		"varModifier", "continueStatement", "breakStatement", "returnStatement",
		"yieldStatement", "withStatement", "switchStatement", "caseBlock", "caseClauses",
		"caseClause", "defaultClause", "labelledStatement", "throwStatement",
		"tryStatement", "catchProduction", "finallyProduction", "debuggerStatement",
		"functionDeclaration", "classDeclaration", "classTail", "classElement",
		"methodDefinition", "formalParameterList", "formalParameterArg", "lastFormalParameterArg",
		"functionBody", "sourceElements", "arrayLiteral", "elementList", "arrayElement",
		"objectLiteral", "propertyAssignment", "propertyName", "arguments",
		"argument", "expressionSequence", "singleExpression", "assignable",
		"anoymousFunction", "arrowFunctionParameters", "arrowFunctionBody",
		"assignmentOperator", "literal", "numericLiteral", "bigintLiteral",
		"identifierName", "reservedWord", "keyword", "getter", "setter", "eos",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 123, 958, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 1, 0, 3,
		0, 148, 8, 0, 1, 0, 3, 0, 151, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 177, 8, 2, 1, 3, 1, 3, 3, 3,
		181, 8, 3, 1, 3, 1, 3, 1, 4, 4, 4, 186, 8, 4, 11, 4, 12, 4, 187, 1, 5,
		1, 5, 1, 5, 1, 6, 3, 6, 194, 8, 6, 1, 6, 1, 6, 3, 6, 198, 8, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 3, 6, 205, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 5, 7, 211,
		8, 7, 10, 7, 12, 7, 214, 9, 7, 1, 7, 1, 7, 3, 7, 218, 8, 7, 3, 7, 220,
		8, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 3, 9, 230, 8, 9,
		1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 3, 11, 238, 8, 11, 1, 12, 1,
		12, 1, 12, 3, 12, 243, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 3, 12, 252, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3,
		13, 260, 8, 13, 1, 13, 1, 13, 3, 13, 264, 8, 13, 1, 14, 1, 14, 1, 14, 3,
		14, 269, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 5, 16,
		278, 8, 16, 10, 16, 12, 16, 281, 9, 16, 1, 17, 1, 17, 1, 17, 3, 17, 286,
		8, 17, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 1, 20, 3, 20, 301, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21,
		1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1,
		21, 1, 21, 1, 21, 1, 21, 3, 21, 321, 8, 21, 1, 21, 1, 21, 3, 21, 325, 8,
		21, 1, 21, 1, 21, 3, 21, 329, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21,
		1, 21, 3, 21, 337, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1,
		21, 3, 21, 346, 8, 21, 1, 21, 1, 21, 1, 21, 3, 21, 351, 8, 21, 1, 21, 1,
		21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 359, 8, 21, 1, 22, 1, 22, 1, 23,
		1, 23, 1, 23, 3, 23, 366, 8, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 3,
		24, 373, 8, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 3, 25, 380, 8, 25, 1,
		25, 1, 25, 1, 26, 1, 26, 1, 26, 3, 26, 387, 8, 26, 1, 26, 1, 26, 1, 27,
		1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 1, 29, 1, 29, 3, 29, 405, 8, 29, 1, 29, 1, 29, 3, 29, 409, 8, 29, 3,
		29, 411, 8, 29, 1, 29, 1, 29, 1, 30, 4, 30, 416, 8, 30, 11, 30, 12, 30,
		417, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 424, 8, 31, 1, 32, 1, 32, 1, 32,
		3, 32, 429, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1,
		34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 444, 8, 35, 1, 35, 3, 35,
		447, 8, 35, 1, 36, 1, 36, 1, 36, 3, 36, 452, 8, 36, 1, 36, 3, 36, 455,
		8, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 39, 3,
		39, 466, 8, 39, 1, 39, 1, 39, 3, 39, 470, 8, 39, 1, 39, 1, 39, 1, 39, 3,
		39, 475, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40,
		1, 40, 1, 41, 1, 41, 3, 41, 488, 8, 41, 1, 41, 1, 41, 5, 41, 492, 8, 41,
		10, 41, 12, 41, 495, 9, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 5,
		42, 503, 8, 42, 10, 42, 12, 42, 506, 9, 42, 1, 42, 1, 42, 1, 42, 3, 42,
		511, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 517, 8, 42, 1, 43, 3, 43,
		520, 8, 43, 1, 43, 3, 43, 523, 8, 43, 1, 43, 1, 43, 1, 43, 3, 43, 528,
		8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 536, 8, 43, 1,
		43, 3, 43, 539, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 3, 43, 549, 8, 43, 1, 43, 3, 43, 552, 8, 43, 1, 43, 1, 43, 1, 43,
		3, 43, 557, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 564, 8, 43,
		1, 44, 1, 44, 1, 44, 5, 44, 569, 8, 44, 10, 44, 12, 44, 572, 9, 44, 1,
		44, 1, 44, 3, 44, 576, 8, 44, 1, 44, 3, 44, 579, 8, 44, 1, 45, 1, 45, 1,
		45, 3, 45, 584, 8, 45, 1, 46, 1, 46, 1, 46, 1, 47, 3, 47, 590, 8, 47, 1,
		48, 4, 48, 593, 8, 48, 11, 48, 12, 48, 594, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 50, 5, 50, 602, 8, 50, 10, 50, 12, 50, 605, 9, 50, 1, 50, 3, 50, 608,
		8, 50, 1, 50, 4, 50, 611, 8, 50, 11, 50, 12, 50, 612, 1, 50, 5, 50, 616,
		8, 50, 10, 50, 12, 50, 619, 9, 50, 1, 50, 5, 50, 622, 8, 50, 10, 50, 12,
		50, 625, 9, 50, 1, 51, 3, 51, 628, 8, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1,
		52, 1, 52, 5, 52, 636, 8, 52, 10, 52, 12, 52, 639, 9, 52, 3, 52, 641, 8,
		52, 1, 52, 3, 52, 644, 8, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 659, 8, 53, 1,
		53, 3, 53, 662, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 667, 8, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 690,
		8, 53, 1, 53, 3, 53, 693, 8, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 3, 54, 702, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 5, 55, 708, 8,
		55, 10, 55, 12, 55, 711, 9, 55, 1, 55, 3, 55, 714, 8, 55, 3, 55, 716, 8,
		55, 1, 55, 1, 55, 1, 56, 3, 56, 721, 8, 56, 1, 56, 1, 56, 3, 56, 725, 8,
		56, 1, 57, 1, 57, 1, 57, 5, 57, 730, 8, 57, 10, 57, 12, 57, 733, 9, 57,
		1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 739, 8, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 3, 58, 745, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 3, 58, 786, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 3, 58, 850, 8, 58, 1, 58, 1, 58, 3, 58, 854, 8, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		5, 58, 867, 8, 58, 10, 58, 12, 58, 870, 9, 58, 1, 59, 1, 59, 1, 59, 3,
		59, 875, 8, 59, 1, 60, 1, 60, 3, 60, 879, 8, 60, 1, 60, 1, 60, 3, 60, 883,
		8, 60, 1, 60, 1, 60, 3, 60, 887, 8, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 3, 60, 895, 8, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 901, 8,
		60, 1, 61, 1, 61, 1, 61, 3, 61, 906, 8, 61, 1, 61, 3, 61, 909, 8, 61, 1,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 916, 8, 62, 1, 63, 1, 63, 1, 64,
		1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 927, 8, 64, 1, 65, 1,
		65, 1, 66, 1, 66, 1, 67, 1, 67, 3, 67, 935, 8, 67, 1, 68, 1, 68, 1, 68,
		3, 68, 940, 8, 68, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1,
		71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 956, 8, 72, 1, 72,
		0, 1, 116, 73, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
		68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,
		104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132,
		134, 136, 138, 140, 142, 144, 0, 10, 3, 0, 77, 77, 102, 102, 108, 108,
		1, 0, 24, 26, 1, 0, 20, 21, 1, 0, 30, 32, 1, 0, 33, 36, 1, 0, 37, 40, 1,
		0, 46, 57, 1, 0, 61, 65, 1, 0, 66, 69, 1, 0, 70, 115, 1075, 0, 147, 1,
		0, 0, 0, 2, 154, 1, 0, 0, 0, 4, 176, 1, 0, 0, 0, 6, 178, 1, 0, 0, 0, 8,
		185, 1, 0, 0, 0, 10, 189, 1, 0, 0, 0, 12, 204, 1, 0, 0, 0, 14, 206, 1,
		0, 0, 0, 16, 223, 1, 0, 0, 0, 18, 226, 1, 0, 0, 0, 20, 231, 1, 0, 0, 0,
		22, 234, 1, 0, 0, 0, 24, 251, 1, 0, 0, 0, 26, 263, 1, 0, 0, 0, 28, 268,
		1, 0, 0, 0, 30, 270, 1, 0, 0, 0, 32, 274, 1, 0, 0, 0, 34, 282, 1, 0, 0,
		0, 36, 287, 1, 0, 0, 0, 38, 289, 1, 0, 0, 0, 40, 293, 1, 0, 0, 0, 42, 358,
		1, 0, 0, 0, 44, 360, 1, 0, 0, 0, 46, 362, 1, 0, 0, 0, 48, 369, 1, 0, 0,
		0, 50, 376, 1, 0, 0, 0, 52, 383, 1, 0, 0, 0, 54, 390, 1, 0, 0, 0, 56, 396,
		1, 0, 0, 0, 58, 402, 1, 0, 0, 0, 60, 415, 1, 0, 0, 0, 62, 419, 1, 0, 0,
		0, 64, 425, 1, 0, 0, 0, 66, 430, 1, 0, 0, 0, 68, 434, 1, 0, 0, 0, 70, 439,
		1, 0, 0, 0, 72, 448, 1, 0, 0, 0, 74, 458, 1, 0, 0, 0, 76, 461, 1, 0, 0,
		0, 78, 465, 1, 0, 0, 0, 80, 481, 1, 0, 0, 0, 82, 487, 1, 0, 0, 0, 84, 516,
		1, 0, 0, 0, 86, 563, 1, 0, 0, 0, 88, 578, 1, 0, 0, 0, 90, 580, 1, 0, 0,
		0, 92, 585, 1, 0, 0, 0, 94, 589, 1, 0, 0, 0, 96, 592, 1, 0, 0, 0, 98, 596,
		1, 0, 0, 0, 100, 603, 1, 0, 0, 0, 102, 627, 1, 0, 0, 0, 104, 631, 1, 0,
		0, 0, 106, 692, 1, 0, 0, 0, 108, 701, 1, 0, 0, 0, 110, 703, 1, 0, 0, 0,
		112, 720, 1, 0, 0, 0, 114, 726, 1, 0, 0, 0, 116, 785, 1, 0, 0, 0, 118,
		874, 1, 0, 0, 0, 120, 900, 1, 0, 0, 0, 122, 908, 1, 0, 0, 0, 124, 915,
		1, 0, 0, 0, 126, 917, 1, 0, 0, 0, 128, 926, 1, 0, 0, 0, 130, 928, 1, 0,
		0, 0, 132, 930, 1, 0, 0, 0, 134, 934, 1, 0, 0, 0, 136, 939, 1, 0, 0, 0,
		138, 941, 1, 0, 0, 0, 140, 943, 1, 0, 0, 0, 142, 947, 1, 0, 0, 0, 144,
		955, 1, 0, 0, 0, 146, 148, 5, 1, 0, 0, 147, 146, 1, 0, 0, 0, 147, 148,
		1, 0, 0, 0, 148, 150, 1, 0, 0, 0, 149, 151, 3, 96, 48, 0, 150, 149, 1,
		0, 0, 0, 150, 151, 1, 0, 0, 0, 151, 152, 1, 0, 0, 0, 152, 153, 5, 0, 0,
		1, 153, 1, 1, 0, 0, 0, 154, 155, 3, 4, 2, 0, 155, 3, 1, 0, 0, 0, 156, 177,
		3, 6, 3, 0, 157, 177, 3, 30, 15, 0, 158, 177, 3, 10, 5, 0, 159, 177, 3,
		24, 12, 0, 160, 177, 3, 36, 18, 0, 161, 177, 3, 80, 40, 0, 162, 177, 3,
		38, 19, 0, 163, 177, 3, 40, 20, 0, 164, 177, 3, 42, 21, 0, 165, 177, 3,
		46, 23, 0, 166, 177, 3, 48, 24, 0, 167, 177, 3, 50, 25, 0, 168, 177, 3,
		52, 26, 0, 169, 177, 3, 54, 27, 0, 170, 177, 3, 66, 33, 0, 171, 177, 3,
		56, 28, 0, 172, 177, 3, 68, 34, 0, 173, 177, 3, 70, 35, 0, 174, 177, 3,
		76, 38, 0, 175, 177, 3, 78, 39, 0, 176, 156, 1, 0, 0, 0, 176, 157, 1, 0,
		0, 0, 176, 158, 1, 0, 0, 0, 176, 159, 1, 0, 0, 0, 176, 160, 1, 0, 0, 0,
		176, 161, 1, 0, 0, 0, 176, 162, 1, 0, 0, 0, 176, 163, 1, 0, 0, 0, 176,
		164, 1, 0, 0, 0, 176, 165, 1, 0, 0, 0, 176, 166, 1, 0, 0, 0, 176, 167,
		1, 0, 0, 0, 176, 168, 1, 0, 0, 0, 176, 169, 1, 0, 0, 0, 176, 170, 1, 0,
		0, 0, 176, 171, 1, 0, 0, 0, 176, 172, 1, 0, 0, 0, 176, 173, 1, 0, 0, 0,
		176, 174, 1, 0, 0, 0, 176, 175, 1, 0, 0, 0, 177, 5, 1, 0, 0, 0, 178, 180,
		5, 9, 0, 0, 179, 181, 3, 8, 4, 0, 180, 179, 1, 0, 0, 0, 180, 181, 1, 0,
		0, 0, 181, 182, 1, 0, 0, 0, 182, 183, 5, 10, 0, 0, 183, 7, 1, 0, 0, 0,
		184, 186, 3, 4, 2, 0, 185, 184, 1, 0, 0, 0, 186, 187, 1, 0, 0, 0, 187,
		185, 1, 0, 0, 0, 187, 188, 1, 0, 0, 0, 188, 9, 1, 0, 0, 0, 189, 190, 5,
		104, 0, 0, 190, 191, 3, 12, 6, 0, 191, 11, 1, 0, 0, 0, 192, 194, 3, 16,
		8, 0, 193, 192, 1, 0, 0, 0, 193, 194, 1, 0, 0, 0, 194, 197, 1, 0, 0, 0,
		195, 198, 3, 18, 9, 0, 196, 198, 3, 14, 7, 0, 197, 195, 1, 0, 0, 0, 197,
		196, 1, 0, 0, 0, 198, 199, 1, 0, 0, 0, 199, 200, 3, 20, 10, 0, 200, 201,
		3, 144, 72, 0, 201, 205, 1, 0, 0, 0, 202, 203, 5, 117, 0, 0, 203, 205,
		3, 144, 72, 0, 204, 193, 1, 0, 0, 0, 204, 202, 1, 0, 0, 0, 205, 13, 1,
		0, 0, 0, 206, 212, 5, 9, 0, 0, 207, 208, 3, 22, 11, 0, 208, 209, 5, 12,
		0, 0, 209, 211, 1, 0, 0, 0, 210, 207, 1, 0, 0, 0, 211, 214, 1, 0, 0, 0,
		212, 210, 1, 0, 0, 0, 212, 213, 1, 0, 0, 0, 213, 219, 1, 0, 0, 0, 214,
		212, 1, 0, 0, 0, 215, 217, 3, 22, 11, 0, 216, 218, 5, 12, 0, 0, 217, 216,
		1, 0, 0, 0, 217, 218, 1, 0, 0, 0, 218, 220, 1, 0, 0, 0, 219, 215, 1, 0,
		0, 0, 219, 220, 1, 0, 0, 0, 220, 221, 1, 0, 0, 0, 221, 222, 5, 10, 0, 0,
		222, 15, 1, 0, 0, 0, 223, 224, 3, 22, 11, 0, 224, 225, 5, 12, 0, 0, 225,
		17, 1, 0, 0, 0, 226, 229, 5, 24, 0, 0, 227, 228, 5, 96, 0, 0, 228, 230,
		3, 134, 67, 0, 229, 227, 1, 0, 0, 0, 229, 230, 1, 0, 0, 0, 230, 19, 1,
		0, 0, 0, 231, 232, 5, 97, 0, 0, 232, 233, 5, 117, 0, 0, 233, 21, 1, 0,
		0, 0, 234, 237, 3, 134, 67, 0, 235, 236, 5, 96, 0, 0, 236, 238, 3, 134,
		67, 0, 237, 235, 1, 0, 0, 0, 237, 238, 1, 0, 0, 0, 238, 23, 1, 0, 0, 0,
		239, 242, 5, 103, 0, 0, 240, 243, 3, 26, 13, 0, 241, 243, 3, 28, 14, 0,
		242, 240, 1, 0, 0, 0, 242, 241, 1, 0, 0, 0, 243, 244, 1, 0, 0, 0, 244,
		245, 3, 144, 72, 0, 245, 252, 1, 0, 0, 0, 246, 247, 5, 103, 0, 0, 247,
		248, 5, 90, 0, 0, 248, 249, 3, 116, 58, 0, 249, 250, 3, 144, 72, 0, 250,
		252, 1, 0, 0, 0, 251, 239, 1, 0, 0, 0, 251, 246, 1, 0, 0, 0, 252, 25, 1,
		0, 0, 0, 253, 254, 3, 18, 9, 0, 254, 255, 3, 20, 10, 0, 255, 256, 3, 144,
		72, 0, 256, 264, 1, 0, 0, 0, 257, 259, 3, 14, 7, 0, 258, 260, 3, 20, 10,
		0, 259, 258, 1, 0, 0, 0, 259, 260, 1, 0, 0, 0, 260, 261, 1, 0, 0, 0, 261,
		262, 3, 144, 72, 0, 262, 264, 1, 0, 0, 0, 263, 253, 1, 0, 0, 0, 263, 257,
		1, 0, 0, 0, 264, 27, 1, 0, 0, 0, 265, 269, 3, 30, 15, 0, 266, 269, 3, 80,
		40, 0, 267, 269, 3, 78, 39, 0, 268, 265, 1, 0, 0, 0, 268, 266, 1, 0, 0,
		0, 268, 267, 1, 0, 0, 0, 269, 29, 1, 0, 0, 0, 270, 271, 3, 44, 22, 0, 271,
		272, 3, 32, 16, 0, 272, 273, 3, 144, 72, 0, 273, 31, 1, 0, 0, 0, 274, 279,
		3, 34, 17, 0, 275, 276, 5, 12, 0, 0, 276, 278, 3, 34, 17, 0, 277, 275,
		1, 0, 0, 0, 278, 281, 1, 0, 0, 0, 279, 277, 1, 0, 0, 0, 279, 280, 1, 0,
		0, 0, 280, 33, 1, 0, 0, 0, 281, 279, 1, 0, 0, 0, 282, 285, 3, 118, 59,
		0, 283, 284, 5, 13, 0, 0, 284, 286, 3, 116, 58, 0, 285, 283, 1, 0, 0, 0,
		285, 286, 1, 0, 0, 0, 286, 35, 1, 0, 0, 0, 287, 288, 5, 11, 0, 0, 288,
		37, 1, 0, 0, 0, 289, 290, 4, 19, 0, 0, 290, 291, 3, 114, 57, 0, 291, 292,
		3, 144, 72, 0, 292, 39, 1, 0, 0, 0, 293, 294, 5, 91, 0, 0, 294, 295, 5,
		7, 0, 0, 295, 296, 3, 114, 57, 0, 296, 297, 5, 8, 0, 0, 297, 300, 3, 4,
		2, 0, 298, 299, 5, 75, 0, 0, 299, 301, 3, 4, 2, 0, 300, 298, 1, 0, 0, 0,
		300, 301, 1, 0, 0, 0, 301, 41, 1, 0, 0, 0, 302, 303, 5, 71, 0, 0, 303,
		304, 3, 4, 2, 0, 304, 305, 5, 85, 0, 0, 305, 306, 5, 7, 0, 0, 306, 307,
		3, 114, 57, 0, 307, 308, 5, 8, 0, 0, 308, 309, 3, 144, 72, 0, 309, 359,
		1, 0, 0, 0, 310, 311, 5, 85, 0, 0, 311, 312, 5, 7, 0, 0, 312, 313, 3, 114,
		57, 0, 313, 314, 5, 8, 0, 0, 314, 315, 3, 4, 2, 0, 315, 359, 1, 0, 0, 0,
		316, 317, 5, 83, 0, 0, 317, 320, 5, 7, 0, 0, 318, 321, 3, 114, 57, 0, 319,
		321, 3, 30, 15, 0, 320, 318, 1, 0, 0, 0, 320, 319, 1, 0, 0, 0, 320, 321,
		1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 324, 5, 11, 0, 0, 323, 325, 3, 114,
		57, 0, 324, 323, 1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325, 326, 1, 0, 0, 0,
		326, 328, 5, 11, 0, 0, 327, 329, 3, 114, 57, 0, 328, 327, 1, 0, 0, 0, 328,
		329, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0, 330, 331, 5, 8, 0, 0, 331, 359,
		3, 4, 2, 0, 332, 333, 5, 83, 0, 0, 333, 336, 5, 7, 0, 0, 334, 337, 3, 116,
		58, 0, 335, 337, 3, 30, 15, 0, 336, 334, 1, 0, 0, 0, 336, 335, 1, 0, 0,
		0, 337, 338, 1, 0, 0, 0, 338, 339, 5, 94, 0, 0, 339, 340, 3, 114, 57, 0,
		340, 341, 5, 8, 0, 0, 341, 342, 3, 4, 2, 0, 342, 359, 1, 0, 0, 0, 343,
		345, 5, 83, 0, 0, 344, 346, 5, 106, 0, 0, 345, 344, 1, 0, 0, 0, 345, 346,
		1, 0, 0, 0, 346, 347, 1, 0, 0, 0, 347, 350, 5, 7, 0, 0, 348, 351, 3, 116,
		58, 0, 349, 351, 3, 30, 15, 0, 350, 348, 1, 0, 0, 0, 350, 349, 1, 0, 0,
		0, 351, 352, 1, 0, 0, 0, 352, 353, 5, 116, 0, 0, 353, 354, 4, 21, 1, 0,
		354, 355, 3, 114, 57, 0, 355, 356, 5, 8, 0, 0, 356, 357, 3, 4, 2, 0, 357,
		359, 1, 0, 0, 0, 358, 302, 1, 0, 0, 0, 358, 310, 1, 0, 0, 0, 358, 316,
		1, 0, 0, 0, 358, 332, 1, 0, 0, 0, 358, 343, 1, 0, 0, 0, 359, 43, 1, 0,
		0, 0, 360, 361, 7, 0, 0, 0, 361, 45, 1, 0, 0, 0, 362, 365, 5, 82, 0, 0,
		363, 364, 4, 23, 2, 0, 364, 366, 5, 116, 0, 0, 365, 363, 1, 0, 0, 0, 365,
		366, 1, 0, 0, 0, 366, 367, 1, 0, 0, 0, 367, 368, 3, 144, 72, 0, 368, 47,
		1, 0, 0, 0, 369, 372, 5, 70, 0, 0, 370, 371, 4, 24, 3, 0, 371, 373, 5,
		116, 0, 0, 372, 370, 1, 0, 0, 0, 372, 373, 1, 0, 0, 0, 373, 374, 1, 0,
		0, 0, 374, 375, 3, 144, 72, 0, 375, 49, 1, 0, 0, 0, 376, 379, 5, 80, 0,
		0, 377, 378, 4, 25, 4, 0, 378, 380, 3, 114, 57, 0, 379, 377, 1, 0, 0, 0,
		379, 380, 1, 0, 0, 0, 380, 381, 1, 0, 0, 0, 381, 382, 3, 144, 72, 0, 382,
		51, 1, 0, 0, 0, 383, 386, 5, 115, 0, 0, 384, 385, 4, 26, 5, 0, 385, 387,
		3, 114, 57, 0, 386, 384, 1, 0, 0, 0, 386, 387, 1, 0, 0, 0, 387, 388, 1,
		0, 0, 0, 388, 389, 3, 144, 72, 0, 389, 53, 1, 0, 0, 0, 390, 391, 5, 89,
		0, 0, 391, 392, 5, 7, 0, 0, 392, 393, 3, 114, 57, 0, 393, 394, 5, 8, 0,
		0, 394, 395, 3, 4, 2, 0, 395, 55, 1, 0, 0, 0, 396, 397, 5, 84, 0, 0, 397,
		398, 5, 7, 0, 0, 398, 399, 3, 114, 57, 0, 399, 400, 5, 8, 0, 0, 400, 401,
		3, 58, 29, 0, 401, 57, 1, 0, 0, 0, 402, 404, 5, 9, 0, 0, 403, 405, 3, 60,
		30, 0, 404, 403, 1, 0, 0, 0, 404, 405, 1, 0, 0, 0, 405, 410, 1, 0, 0, 0,
		406, 408, 3, 64, 32, 0, 407, 409, 3, 60, 30, 0, 408, 407, 1, 0, 0, 0, 408,
		409, 1, 0, 0, 0, 409, 411, 1, 0, 0, 0, 410, 406, 1, 0, 0, 0, 410, 411,
		1, 0, 0, 0, 411, 412, 1, 0, 0, 0, 412, 413, 5, 10, 0, 0, 413, 59, 1, 0,
		0, 0, 414, 416, 3, 62, 31, 0, 415, 414, 1, 0, 0, 0, 416, 417, 1, 0, 0,
		0, 417, 415, 1, 0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 61, 1, 0, 0, 0, 419,
		420, 5, 74, 0, 0, 420, 421, 3, 114, 57, 0, 421, 423, 5, 15, 0, 0, 422,
		424, 3, 8, 4, 0, 423, 422, 1, 0, 0, 0, 423, 424, 1, 0, 0, 0, 424, 63, 1,
		0, 0, 0, 425, 426, 5, 90, 0, 0, 426, 428, 5, 15, 0, 0, 427, 429, 3, 8,
		4, 0, 428, 427, 1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 65, 1, 0, 0, 0,
		430, 431, 5, 116, 0, 0, 431, 432, 5, 15, 0, 0, 432, 433, 3, 4, 2, 0, 433,
		67, 1, 0, 0, 0, 434, 435, 5, 92, 0, 0, 435, 436, 4, 34, 6, 0, 436, 437,
		3, 114, 57, 0, 437, 438, 3, 144, 72, 0, 438, 69, 1, 0, 0, 0, 439, 440,
		5, 95, 0, 0, 440, 446, 3, 6, 3, 0, 441, 443, 3, 72, 36, 0, 442, 444, 3,
		74, 37, 0, 443, 442, 1, 0, 0, 0, 443, 444, 1, 0, 0, 0, 444, 447, 1, 0,
		0, 0, 445, 447, 3, 74, 37, 0, 446, 441, 1, 0, 0, 0, 446, 445, 1, 0, 0,
		0, 447, 71, 1, 0, 0, 0, 448, 454, 5, 78, 0, 0, 449, 451, 5, 7, 0, 0, 450,
		452, 3, 118, 59, 0, 451, 450, 1, 0, 0, 0, 451, 452, 1, 0, 0, 0, 452, 453,
		1, 0, 0, 0, 453, 455, 5, 8, 0, 0, 454, 449, 1, 0, 0, 0, 454, 455, 1, 0,
		0, 0, 455, 456, 1, 0, 0, 0, 456, 457, 3, 6, 3, 0, 457, 73, 1, 0, 0, 0,
		458, 459, 5, 79, 0, 0, 459, 460, 3, 6, 3, 0, 460, 75, 1, 0, 0, 0, 461,
		462, 5, 86, 0, 0, 462, 463, 3, 144, 72, 0, 463, 77, 1, 0, 0, 0, 464, 466,
		5, 105, 0, 0, 465, 464, 1, 0, 0, 0, 465, 466, 1, 0, 0, 0, 466, 467, 1,
		0, 0, 0, 467, 469, 5, 87, 0, 0, 468, 470, 5, 24, 0, 0, 469, 468, 1, 0,
		0, 0, 469, 470, 1, 0, 0, 0, 470, 471, 1, 0, 0, 0, 471, 472, 5, 116, 0,
		0, 472, 474, 5, 7, 0, 0, 473, 475, 3, 88, 44, 0, 474, 473, 1, 0, 0, 0,
		474, 475, 1, 0, 0, 0, 475, 476, 1, 0, 0, 0, 476, 477, 5, 8, 0, 0, 477,
		478, 5, 9, 0, 0, 478, 479, 3, 94, 47, 0, 479, 480, 5, 10, 0, 0, 480, 79,
		1, 0, 0, 0, 481, 482, 5, 98, 0, 0, 482, 483, 5, 116, 0, 0, 483, 484, 3,
		82, 41, 0, 484, 81, 1, 0, 0, 0, 485, 486, 5, 100, 0, 0, 486, 488, 3, 116,
		58, 0, 487, 485, 1, 0, 0, 0, 487, 488, 1, 0, 0, 0, 488, 489, 1, 0, 0, 0,
		489, 493, 5, 9, 0, 0, 490, 492, 3, 84, 42, 0, 491, 490, 1, 0, 0, 0, 492,
		495, 1, 0, 0, 0, 493, 491, 1, 0, 0, 0, 493, 494, 1, 0, 0, 0, 494, 496,
		1, 0, 0, 0, 495, 493, 1, 0, 0, 0, 496, 497, 5, 10, 0, 0, 497, 83, 1, 0,
		0, 0, 498, 503, 5, 114, 0, 0, 499, 500, 4, 42, 7, 0, 500, 503, 5, 116,
		0, 0, 501, 503, 5, 105, 0, 0, 502, 498, 1, 0, 0, 0, 502, 499, 1, 0, 0,
		0, 502, 501, 1, 0, 0, 0, 503, 506, 1, 0, 0, 0, 504, 502, 1, 0, 0, 0, 504,
		505, 1, 0, 0, 0, 505, 507, 1, 0, 0, 0, 506, 504, 1, 0, 0, 0, 507, 517,
		3, 86, 43, 0, 508, 517, 3, 36, 18, 0, 509, 511, 5, 29, 0, 0, 510, 509,
		1, 0, 0, 0, 510, 511, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0, 512, 513, 3, 108,
		54, 0, 513, 514, 5, 13, 0, 0, 514, 515, 3, 116, 58, 0, 515, 517, 1, 0,
		0, 0, 516, 504, 1, 0, 0, 0, 516, 508, 1, 0, 0, 0, 516, 510, 1, 0, 0, 0,
		517, 85, 1, 0, 0, 0, 518, 520, 5, 24, 0, 0, 519, 518, 1, 0, 0, 0, 519,
		520, 1, 0, 0, 0, 520, 522, 1, 0, 0, 0, 521, 523, 5, 29, 0, 0, 522, 521,
		1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523, 524, 1, 0, 0, 0, 524, 525, 3, 108,
		54, 0, 525, 527, 5, 7, 0, 0, 526, 528, 3, 88, 44, 0, 527, 526, 1, 0, 0,
		0, 527, 528, 1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529, 530, 5, 8, 0, 0, 530,
		531, 5, 9, 0, 0, 531, 532, 3, 94, 47, 0, 532, 533, 5, 10, 0, 0, 533, 564,
		1, 0, 0, 0, 534, 536, 5, 24, 0, 0, 535, 534, 1, 0, 0, 0, 535, 536, 1, 0,
		0, 0, 536, 538, 1, 0, 0, 0, 537, 539, 5, 29, 0, 0, 538, 537, 1, 0, 0, 0,
		538, 539, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 541, 3, 140, 70, 0, 541,
		542, 5, 7, 0, 0, 542, 543, 5, 8, 0, 0, 543, 544, 5, 9, 0, 0, 544, 545,
		3, 94, 47, 0, 545, 546, 5, 10, 0, 0, 546, 564, 1, 0, 0, 0, 547, 549, 5,
		24, 0, 0, 548, 547, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549, 551, 1, 0, 0,
		0, 550, 552, 5, 29, 0, 0, 551, 550, 1, 0, 0, 0, 551, 552, 1, 0, 0, 0, 552,
		553, 1, 0, 0, 0, 553, 554, 3, 142, 71, 0, 554, 556, 5, 7, 0, 0, 555, 557,
		3, 88, 44, 0, 556, 555, 1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 558, 1,
		0, 0, 0, 558, 559, 5, 8, 0, 0, 559, 560, 5, 9, 0, 0, 560, 561, 3, 94, 47,
		0, 561, 562, 5, 10, 0, 0, 562, 564, 1, 0, 0, 0, 563, 519, 1, 0, 0, 0, 563,
		535, 1, 0, 0, 0, 563, 548, 1, 0, 0, 0, 564, 87, 1, 0, 0, 0, 565, 570, 3,
		90, 45, 0, 566, 567, 5, 12, 0, 0, 567, 569, 3, 90, 45, 0, 568, 566, 1,
		0, 0, 0, 569, 572, 1, 0, 0, 0, 570, 568, 1, 0, 0, 0, 570, 571, 1, 0, 0,
		0, 571, 575, 1, 0, 0, 0, 572, 570, 1, 0, 0, 0, 573, 574, 5, 12, 0, 0, 574,
		576, 3, 92, 46, 0, 575, 573, 1, 0, 0, 0, 575, 576, 1, 0, 0, 0, 576, 579,
		1, 0, 0, 0, 577, 579, 3, 92, 46, 0, 578, 565, 1, 0, 0, 0, 578, 577, 1,
		0, 0, 0, 579, 89, 1, 0, 0, 0, 580, 583, 3, 118, 59, 0, 581, 582, 5, 13,
		0, 0, 582, 584, 3, 116, 58, 0, 583, 581, 1, 0, 0, 0, 583, 584, 1, 0, 0,
		0, 584, 91, 1, 0, 0, 0, 585, 586, 5, 16, 0, 0, 586, 587, 3, 116, 58, 0,
		587, 93, 1, 0, 0, 0, 588, 590, 3, 96, 48, 0, 589, 588, 1, 0, 0, 0, 589,
		590, 1, 0, 0, 0, 590, 95, 1, 0, 0, 0, 591, 593, 3, 2, 1, 0, 592, 591, 1,
		0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 592, 1, 0, 0, 0, 594, 595, 1, 0, 0,
		0, 595, 97, 1, 0, 0, 0, 596, 597, 5, 5, 0, 0, 597, 598, 3, 100, 50, 0,
		598, 599, 5, 6, 0, 0, 599, 99, 1, 0, 0, 0, 600, 602, 5, 12, 0, 0, 601,
		600, 1, 0, 0, 0, 602, 605, 1, 0, 0, 0, 603, 601, 1, 0, 0, 0, 603, 604,
		1, 0, 0, 0, 604, 607, 1, 0, 0, 0, 605, 603, 1, 0, 0, 0, 606, 608, 3, 102,
		51, 0, 607, 606, 1, 0, 0, 0, 607, 608, 1, 0, 0, 0, 608, 617, 1, 0, 0, 0,
		609, 611, 5, 12, 0, 0, 610, 609, 1, 0, 0, 0, 611, 612, 1, 0, 0, 0, 612,
		610, 1, 0, 0, 0, 612, 613, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0, 614, 616,
		3, 102, 51, 0, 615, 610, 1, 0, 0, 0, 616, 619, 1, 0, 0, 0, 617, 615, 1,
		0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 623, 1, 0, 0, 0, 619, 617, 1, 0, 0,
		0, 620, 622, 5, 12, 0, 0, 621, 620, 1, 0, 0, 0, 622, 625, 1, 0, 0, 0, 623,
		621, 1, 0, 0, 0, 623, 624, 1, 0, 0, 0, 624, 101, 1, 0, 0, 0, 625, 623,
		1, 0, 0, 0, 626, 628, 5, 16, 0, 0, 627, 626, 1, 0, 0, 0, 627, 628, 1, 0,
		0, 0, 628, 629, 1, 0, 0, 0, 629, 630, 3, 116, 58, 0, 630, 103, 1, 0, 0,
		0, 631, 640, 5, 9, 0, 0, 632, 637, 3, 106, 53, 0, 633, 634, 5, 12, 0, 0,
		634, 636, 3, 106, 53, 0, 635, 633, 1, 0, 0, 0, 636, 639, 1, 0, 0, 0, 637,
		635, 1, 0, 0, 0, 637, 638, 1, 0, 0, 0, 638, 641, 1, 0, 0, 0, 639, 637,
		1, 0, 0, 0, 640, 632, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 643, 1, 0,
		0, 0, 642, 644, 5, 12, 0, 0, 643, 642, 1, 0, 0, 0, 643, 644, 1, 0, 0, 0,
		644, 645, 1, 0, 0, 0, 645, 646, 5, 10, 0, 0, 646, 105, 1, 0, 0, 0, 647,
		648, 3, 108, 54, 0, 648, 649, 5, 15, 0, 0, 649, 650, 3, 116, 58, 0, 650,
		693, 1, 0, 0, 0, 651, 652, 5, 5, 0, 0, 652, 653, 3, 116, 58, 0, 653, 654,
		5, 6, 0, 0, 654, 655, 5, 15, 0, 0, 655, 656, 3, 116, 58, 0, 656, 693, 1,
		0, 0, 0, 657, 659, 5, 105, 0, 0, 658, 657, 1, 0, 0, 0, 658, 659, 1, 0,
		0, 0, 659, 661, 1, 0, 0, 0, 660, 662, 5, 24, 0, 0, 661, 660, 1, 0, 0, 0,
		661, 662, 1, 0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 664, 3, 108, 54, 0, 664,
		666, 5, 7, 0, 0, 665, 667, 3, 88, 44, 0, 666, 665, 1, 0, 0, 0, 666, 667,
		1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 669, 5, 8, 0, 0, 669, 670, 5, 9,
		0, 0, 670, 671, 3, 94, 47, 0, 671, 672, 5, 10, 0, 0, 672, 693, 1, 0, 0,
		0, 673, 674, 3, 140, 70, 0, 674, 675, 5, 7, 0, 0, 675, 676, 5, 8, 0, 0,
		676, 677, 5, 9, 0, 0, 677, 678, 3, 94, 47, 0, 678, 679, 5, 10, 0, 0, 679,
		693, 1, 0, 0, 0, 680, 681, 3, 142, 71, 0, 681, 682, 5, 7, 0, 0, 682, 683,
		3, 90, 45, 0, 683, 684, 5, 8, 0, 0, 684, 685, 5, 9, 0, 0, 685, 686, 3,
		94, 47, 0, 686, 687, 5, 10, 0, 0, 687, 693, 1, 0, 0, 0, 688, 690, 5, 16,
		0, 0, 689, 688, 1, 0, 0, 0, 689, 690, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0,
		691, 693, 3, 116, 58, 0, 692, 647, 1, 0, 0, 0, 692, 651, 1, 0, 0, 0, 692,
		658, 1, 0, 0, 0, 692, 673, 1, 0, 0, 0, 692, 680, 1, 0, 0, 0, 692, 689,
		1, 0, 0, 0, 693, 107, 1, 0, 0, 0, 694, 702, 3, 134, 67, 0, 695, 702, 5,
		117, 0, 0, 696, 702, 3, 130, 65, 0, 697, 698, 5, 5, 0, 0, 698, 699, 3,
		116, 58, 0, 699, 700, 5, 6, 0, 0, 700, 702, 1, 0, 0, 0, 701, 694, 1, 0,
		0, 0, 701, 695, 1, 0, 0, 0, 701, 696, 1, 0, 0, 0, 701, 697, 1, 0, 0, 0,
		702, 109, 1, 0, 0, 0, 703, 715, 5, 7, 0, 0, 704, 709, 3, 112, 56, 0, 705,
		706, 5, 12, 0, 0, 706, 708, 3, 112, 56, 0, 707, 705, 1, 0, 0, 0, 708, 711,
		1, 0, 0, 0, 709, 707, 1, 0, 0, 0, 709, 710, 1, 0, 0, 0, 710, 713, 1, 0,
		0, 0, 711, 709, 1, 0, 0, 0, 712, 714, 5, 12, 0, 0, 713, 712, 1, 0, 0, 0,
		713, 714, 1, 0, 0, 0, 714, 716, 1, 0, 0, 0, 715, 704, 1, 0, 0, 0, 715,
		716, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717, 718, 5, 8, 0, 0, 718, 111,
		1, 0, 0, 0, 719, 721, 5, 16, 0, 0, 720, 719, 1, 0, 0, 0, 720, 721, 1, 0,
		0, 0, 721, 724, 1, 0, 0, 0, 722, 725, 3, 116, 58, 0, 723, 725, 5, 116,
		0, 0, 724, 722, 1, 0, 0, 0, 724, 723, 1, 0, 0, 0, 725, 113, 1, 0, 0, 0,
		726, 731, 3, 116, 58, 0, 727, 728, 5, 12, 0, 0, 728, 730, 3, 116, 58, 0,
		729, 727, 1, 0, 0, 0, 730, 733, 1, 0, 0, 0, 731, 729, 1, 0, 0, 0, 731,
		732, 1, 0, 0, 0, 732, 115, 1, 0, 0, 0, 733, 731, 1, 0, 0, 0, 734, 735,
		6, 58, -1, 0, 735, 786, 3, 120, 60, 0, 736, 738, 5, 98, 0, 0, 737, 739,
		5, 116, 0, 0, 738, 737, 1, 0, 0, 0, 738, 739, 1, 0, 0, 0, 739, 740, 1,
		0, 0, 0, 740, 786, 3, 82, 41, 0, 741, 742, 5, 76, 0, 0, 742, 744, 3, 116,
		58, 0, 743, 745, 3, 110, 55, 0, 744, 743, 1, 0, 0, 0, 744, 745, 1, 0, 0,
		0, 745, 786, 1, 0, 0, 0, 746, 747, 5, 76, 0, 0, 747, 748, 5, 17, 0, 0,
		748, 786, 5, 116, 0, 0, 749, 750, 5, 93, 0, 0, 750, 786, 3, 116, 58, 37,
		751, 752, 5, 81, 0, 0, 752, 786, 3, 116, 58, 36, 753, 754, 5, 73, 0, 0,
		754, 786, 3, 116, 58, 35, 755, 756, 5, 18, 0, 0, 756, 786, 3, 116, 58,
		34, 757, 758, 5, 19, 0, 0, 758, 786, 3, 116, 58, 33, 759, 760, 5, 20, 0,
		0, 760, 786, 3, 116, 58, 32, 761, 762, 5, 21, 0, 0, 762, 786, 3, 116, 58,
		31, 763, 764, 5, 22, 0, 0, 764, 786, 3, 116, 58, 30, 765, 766, 5, 23, 0,
		0, 766, 786, 3, 116, 58, 29, 767, 768, 5, 106, 0, 0, 768, 786, 3, 116,
		58, 28, 769, 770, 5, 104, 0, 0, 770, 771, 5, 7, 0, 0, 771, 772, 3, 116,
		58, 0, 772, 773, 5, 8, 0, 0, 773, 786, 1, 0, 0, 0, 774, 786, 3, 52, 26,
		0, 775, 786, 5, 88, 0, 0, 776, 786, 5, 116, 0, 0, 777, 786, 5, 101, 0,
		0, 778, 786, 3, 128, 64, 0, 779, 786, 3, 98, 49, 0, 780, 786, 3, 104, 52,
		0, 781, 782, 5, 7, 0, 0, 782, 783, 3, 114, 57, 0, 783, 784, 5, 8, 0, 0,
		784, 786, 1, 0, 0, 0, 785, 734, 1, 0, 0, 0, 785, 736, 1, 0, 0, 0, 785,
		741, 1, 0, 0, 0, 785, 746, 1, 0, 0, 0, 785, 749, 1, 0, 0, 0, 785, 751,
		1, 0, 0, 0, 785, 753, 1, 0, 0, 0, 785, 755, 1, 0, 0, 0, 785, 757, 1, 0,
		0, 0, 785, 759, 1, 0, 0, 0, 785, 761, 1, 0, 0, 0, 785, 763, 1, 0, 0, 0,
		785, 765, 1, 0, 0, 0, 785, 767, 1, 0, 0, 0, 785, 769, 1, 0, 0, 0, 785,
		774, 1, 0, 0, 0, 785, 775, 1, 0, 0, 0, 785, 776, 1, 0, 0, 0, 785, 777,
		1, 0, 0, 0, 785, 778, 1, 0, 0, 0, 785, 779, 1, 0, 0, 0, 785, 780, 1, 0,
		0, 0, 785, 781, 1, 0, 0, 0, 786, 868, 1, 0, 0, 0, 787, 788, 10, 27, 0,
		0, 788, 789, 5, 27, 0, 0, 789, 867, 3, 116, 58, 27, 790, 791, 10, 26, 0,
		0, 791, 792, 7, 1, 0, 0, 792, 867, 3, 116, 58, 27, 793, 794, 10, 25, 0,
		0, 794, 795, 7, 2, 0, 0, 795, 867, 3, 116, 58, 26, 796, 797, 10, 24, 0,
		0, 797, 798, 5, 28, 0, 0, 798, 867, 3, 116, 58, 25, 799, 800, 10, 23, 0,
		0, 800, 801, 7, 3, 0, 0, 801, 867, 3, 116, 58, 24, 802, 803, 10, 22, 0,
		0, 803, 804, 7, 4, 0, 0, 804, 867, 3, 116, 58, 23, 805, 806, 10, 21, 0,
		0, 806, 807, 5, 72, 0, 0, 807, 867, 3, 116, 58, 22, 808, 809, 10, 20, 0,
		0, 809, 810, 5, 94, 0, 0, 810, 867, 3, 116, 58, 21, 811, 812, 10, 19, 0,
		0, 812, 813, 7, 5, 0, 0, 813, 867, 3, 116, 58, 20, 814, 815, 10, 18, 0,
		0, 815, 816, 5, 41, 0, 0, 816, 867, 3, 116, 58, 19, 817, 818, 10, 17, 0,
		0, 818, 819, 5, 42, 0, 0, 819, 867, 3, 116, 58, 18, 820, 821, 10, 16, 0,
		0, 821, 822, 5, 43, 0, 0, 822, 867, 3, 116, 58, 17, 823, 824, 10, 15, 0,
		0, 824, 825, 5, 44, 0, 0, 825, 867, 3, 116, 58, 16, 826, 827, 10, 14, 0,
		0, 827, 828, 5, 45, 0, 0, 828, 867, 3, 116, 58, 15, 829, 830, 10, 13, 0,
		0, 830, 831, 5, 14, 0, 0, 831, 832, 3, 116, 58, 0, 832, 833, 5, 15, 0,
		0, 833, 834, 3, 116, 58, 14, 834, 867, 1, 0, 0, 0, 835, 836, 10, 12, 0,
		0, 836, 837, 5, 13, 0, 0, 837, 867, 3, 116, 58, 12, 838, 839, 10, 11, 0,
		0, 839, 840, 3, 126, 63, 0, 840, 841, 3, 116, 58, 11, 841, 867, 1, 0, 0,
		0, 842, 843, 10, 44, 0, 0, 843, 844, 5, 5, 0, 0, 844, 845, 3, 114, 57,
		0, 845, 846, 5, 6, 0, 0, 846, 867, 1, 0, 0, 0, 847, 849, 10, 43, 0, 0,
		848, 850, 5, 14, 0, 0, 849, 848, 1, 0, 0, 0, 849, 850, 1, 0, 0, 0, 850,
		851, 1, 0, 0, 0, 851, 853, 5, 17, 0, 0, 852, 854, 5, 29, 0, 0, 853, 852,
		1, 0, 0, 0, 853, 854, 1, 0, 0, 0, 854, 855, 1, 0, 0, 0, 855, 867, 3, 134,
		67, 0, 856, 857, 10, 42, 0, 0, 857, 867, 3, 110, 55, 0, 858, 859, 10, 39,
		0, 0, 859, 860, 4, 58, 29, 0, 860, 867, 5, 18, 0, 0, 861, 862, 10, 38,
		0, 0, 862, 863, 4, 58, 31, 0, 863, 867, 5, 19, 0, 0, 864, 865, 10, 9, 0,
		0, 865, 867, 5, 118, 0, 0, 866, 787, 1, 0, 0, 0, 866, 790, 1, 0, 0, 0,
		866, 793, 1, 0, 0, 0, 866, 796, 1, 0, 0, 0, 866, 799, 1, 0, 0, 0, 866,
		802, 1, 0, 0, 0, 866, 805, 1, 0, 0, 0, 866, 808, 1, 0, 0, 0, 866, 811,
		1, 0, 0, 0, 866, 814, 1, 0, 0, 0, 866, 817, 1, 0, 0, 0, 866, 820, 1, 0,
		0, 0, 866, 823, 1, 0, 0, 0, 866, 826, 1, 0, 0, 0, 866, 829, 1, 0, 0, 0,
		866, 835, 1, 0, 0, 0, 866, 838, 1, 0, 0, 0, 866, 842, 1, 0, 0, 0, 866,
		847, 1, 0, 0, 0, 866, 856, 1, 0, 0, 0, 866, 858, 1, 0, 0, 0, 866, 861,
		1, 0, 0, 0, 866, 864, 1, 0, 0, 0, 867, 870, 1, 0, 0, 0, 868, 866, 1, 0,
		0, 0, 868, 869, 1, 0, 0, 0, 869, 117, 1, 0, 0, 0, 870, 868, 1, 0, 0, 0,
		871, 875, 5, 116, 0, 0, 872, 875, 3, 98, 49, 0, 873, 875, 3, 104, 52, 0,
		874, 871, 1, 0, 0, 0, 874, 872, 1, 0, 0, 0, 874, 873, 1, 0, 0, 0, 875,
		119, 1, 0, 0, 0, 876, 901, 3, 78, 39, 0, 877, 879, 5, 105, 0, 0, 878, 877,
		1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879, 880, 1, 0, 0, 0, 880, 882, 5, 87,
		0, 0, 881, 883, 5, 24, 0, 0, 882, 881, 1, 0, 0, 0, 882, 883, 1, 0, 0, 0,
		883, 884, 1, 0, 0, 0, 884, 886, 5, 7, 0, 0, 885, 887, 3, 88, 44, 0, 886,
		885, 1, 0, 0, 0, 886, 887, 1, 0, 0, 0, 887, 888, 1, 0, 0, 0, 888, 889,
		5, 8, 0, 0, 889, 890, 5, 9, 0, 0, 890, 891, 3, 94, 47, 0, 891, 892, 5,
		10, 0, 0, 892, 901, 1, 0, 0, 0, 893, 895, 5, 105, 0, 0, 894, 893, 1, 0,
		0, 0, 894, 895, 1, 0, 0, 0, 895, 896, 1, 0, 0, 0, 896, 897, 3, 122, 61,
		0, 897, 898, 5, 58, 0, 0, 898, 899, 3, 124, 62, 0, 899, 901, 1, 0, 0, 0,
		900, 876, 1, 0, 0, 0, 900, 878, 1, 0, 0, 0, 900, 894, 1, 0, 0, 0, 901,
		121, 1, 0, 0, 0, 902, 909, 5, 116, 0, 0, 903, 905, 5, 7, 0, 0, 904, 906,
		3, 88, 44, 0, 905, 904, 1, 0, 0, 0, 905, 906, 1, 0, 0, 0, 906, 907, 1,
		0, 0, 0, 907, 909, 5, 8, 0, 0, 908, 902, 1, 0, 0, 0, 908, 903, 1, 0, 0,
		0, 909, 123, 1, 0, 0, 0, 910, 916, 3, 116, 58, 0, 911, 912, 5, 9, 0, 0,
		912, 913, 3, 94, 47, 0, 913, 914, 5, 10, 0, 0, 914, 916, 1, 0, 0, 0, 915,
		910, 1, 0, 0, 0, 915, 911, 1, 0, 0, 0, 916, 125, 1, 0, 0, 0, 917, 918,
		7, 6, 0, 0, 918, 127, 1, 0, 0, 0, 919, 927, 5, 59, 0, 0, 920, 927, 5, 60,
		0, 0, 921, 927, 5, 117, 0, 0, 922, 927, 5, 118, 0, 0, 923, 927, 5, 4, 0,
		0, 924, 927, 3, 130, 65, 0, 925, 927, 3, 132, 66, 0, 926, 919, 1, 0, 0,
		0, 926, 920, 1, 0, 0, 0, 926, 921, 1, 0, 0, 0, 926, 922, 1, 0, 0, 0, 926,
		923, 1, 0, 0, 0, 926, 924, 1, 0, 0, 0, 926, 925, 1, 0, 0, 0, 927, 129,
		1, 0, 0, 0, 928, 929, 7, 7, 0, 0, 929, 131, 1, 0, 0, 0, 930, 931, 7, 8,
		0, 0, 931, 133, 1, 0, 0, 0, 932, 935, 5, 116, 0, 0, 933, 935, 3, 136, 68,
		0, 934, 932, 1, 0, 0, 0, 934, 933, 1, 0, 0, 0, 935, 135, 1, 0, 0, 0, 936,
		940, 3, 138, 69, 0, 937, 940, 5, 59, 0, 0, 938, 940, 5, 60, 0, 0, 939,
		936, 1, 0, 0, 0, 939, 937, 1, 0, 0, 0, 939, 938, 1, 0, 0, 0, 940, 137,
		1, 0, 0, 0, 941, 942, 7, 9, 0, 0, 942, 139, 1, 0, 0, 0, 943, 944, 5, 116,
		0, 0, 944, 945, 4, 70, 33, 0, 945, 946, 3, 108, 54, 0, 946, 141, 1, 0,
		0, 0, 947, 948, 5, 116, 0, 0, 948, 949, 4, 71, 34, 0, 949, 950, 3, 108,
		54, 0, 950, 143, 1, 0, 0, 0, 951, 956, 5, 11, 0, 0, 952, 956, 5, 0, 0,
		1, 953, 956, 4, 72, 35, 0, 954, 956, 4, 72, 36, 0, 955, 951, 1, 0, 0, 0,
		955, 952, 1, 0, 0, 0, 955, 953, 1, 0, 0, 0, 955, 954, 1, 0, 0, 0, 956,
		145, 1, 0, 0, 0, 107, 147, 150, 176, 180, 187, 193, 197, 204, 212, 217,
		219, 229, 237, 242, 251, 259, 263, 268, 279, 285, 300, 320, 324, 328, 336,
		345, 350, 358, 365, 372, 379, 386, 404, 408, 410, 417, 423, 428, 443, 446,
		451, 454, 465, 469, 474, 487, 493, 502, 504, 510, 516, 519, 522, 527, 535,
		538, 548, 551, 556, 563, 570, 575, 578, 583, 589, 594, 603, 607, 612, 617,
		623, 627, 637, 640, 643, 658, 661, 666, 689, 692, 701, 709, 713, 715, 720,
		724, 731, 738, 744, 785, 849, 853, 866, 868, 874, 878, 882, 886, 894, 900,
		905, 908, 915, 926, 934, 939, 955,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// JavaScriptParserInit initializes any static state used to implement JavaScriptParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewJavaScriptParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func JavaScriptParserInit() {
	staticData := &javascriptparserParserStaticData
	staticData.once.Do(javascriptparserParserInit)
}

// NewJavaScriptParser produces a new parser instance for the optional input antlr.TokenStream.
func NewJavaScriptParser(input antlr.TokenStream) *JavaScriptParser {
	JavaScriptParserInit()
	this := new(JavaScriptParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &javascriptparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// JavaScriptParser tokens.
const (
	JavaScriptParserEOF                        = antlr.TokenEOF
	JavaScriptParserHashBangLine               = 1
	JavaScriptParserMultiLineComment           = 2
	JavaScriptParserSingleLineComment          = 3
	JavaScriptParserRegularExpressionLiteral   = 4
	JavaScriptParserOpenBracket                = 5
	JavaScriptParserCloseBracket               = 6
	JavaScriptParserOpenParen                  = 7
	JavaScriptParserCloseParen                 = 8
	JavaScriptParserOpenBrace                  = 9
	JavaScriptParserCloseBrace                 = 10
	JavaScriptParserSemiColon                  = 11
	JavaScriptParserComma                      = 12
	JavaScriptParserAssign                     = 13
	JavaScriptParserQuestionMark               = 14
	JavaScriptParserColon                      = 15
	JavaScriptParserEllipsis                   = 16
	JavaScriptParserDot                        = 17
	JavaScriptParserPlusPlus                   = 18
	JavaScriptParserMinusMinus                 = 19
	JavaScriptParserPlus                       = 20
	JavaScriptParserMinus                      = 21
	JavaScriptParserBitNot                     = 22
	JavaScriptParserNot                        = 23
	JavaScriptParserMultiply                   = 24
	JavaScriptParserDivide                     = 25
	JavaScriptParserModulus                    = 26
	JavaScriptParserPower                      = 27
	JavaScriptParserNullCoalesce               = 28
	JavaScriptParserHashtag                    = 29
	JavaScriptParserRightShiftArithmetic       = 30
	JavaScriptParserLeftShiftArithmetic        = 31
	JavaScriptParserRightShiftLogical          = 32
	JavaScriptParserLessThan                   = 33
	JavaScriptParserMoreThan                   = 34
	JavaScriptParserLessThanEquals             = 35
	JavaScriptParserGreaterThanEquals          = 36
	JavaScriptParserEquals_                    = 37
	JavaScriptParserNotEquals                  = 38
	JavaScriptParserIdentityEquals             = 39
	JavaScriptParserIdentityNotEquals          = 40
	JavaScriptParserBitAnd                     = 41
	JavaScriptParserBitXOr                     = 42
	JavaScriptParserBitOr                      = 43
	JavaScriptParserAnd                        = 44
	JavaScriptParserOr                         = 45
	JavaScriptParserMultiplyAssign             = 46
	JavaScriptParserDivideAssign               = 47
	JavaScriptParserModulusAssign              = 48
	JavaScriptParserPlusAssign                 = 49
	JavaScriptParserMinusAssign                = 50
	JavaScriptParserLeftShiftArithmeticAssign  = 51
	JavaScriptParserRightShiftArithmeticAssign = 52
	JavaScriptParserRightShiftLogicalAssign    = 53
	JavaScriptParserBitAndAssign               = 54
	JavaScriptParserBitXorAssign               = 55
	JavaScriptParserBitOrAssign                = 56
	JavaScriptParserPowerAssign                = 57
	JavaScriptParserARROW                      = 58
	JavaScriptParserNullLiteral                = 59
	JavaScriptParserBooleanLiteral             = 60
	JavaScriptParserDecimalLiteral             = 61
	JavaScriptParserHexIntegerLiteral          = 62
	JavaScriptParserOctalIntegerLiteral        = 63
	JavaScriptParserOctalIntegerLiteral2       = 64
	JavaScriptParserBinaryIntegerLiteral       = 65
	JavaScriptParserBigHexIntegerLiteral       = 66
	JavaScriptParserBigOctalIntegerLiteral     = 67
	JavaScriptParserBigBinaryIntegerLiteral    = 68
	JavaScriptParserBigDecimalIntegerLiteral   = 69
	JavaScriptParserBreak                      = 70
	JavaScriptParserDo                         = 71
	JavaScriptParserInstanceof                 = 72
	JavaScriptParserTypeof                     = 73
	JavaScriptParserCase                       = 74
	JavaScriptParserElse                       = 75
	JavaScriptParserNew                        = 76
	JavaScriptParserVar                        = 77
	JavaScriptParserCatch                      = 78
	JavaScriptParserFinally                    = 79
	JavaScriptParserReturn                     = 80
	JavaScriptParserVoid                       = 81
	JavaScriptParserContinue                   = 82
	JavaScriptParserFor                        = 83
	JavaScriptParserSwitch                     = 84
	JavaScriptParserWhile                      = 85
	JavaScriptParserDebugger                   = 86
	JavaScriptParserFunction                   = 87
	JavaScriptParserThis                       = 88
	JavaScriptParserWith                       = 89
	JavaScriptParserDefault                    = 90
	JavaScriptParserIf                         = 91
	JavaScriptParserThrow                      = 92
	JavaScriptParserDelete                     = 93
	JavaScriptParserIn                         = 94
	JavaScriptParserTry                        = 95
	JavaScriptParserAs                         = 96
	JavaScriptParserFrom                       = 97
	JavaScriptParserClass                      = 98
	JavaScriptParserEnum                       = 99
	JavaScriptParserExtends                    = 100
	JavaScriptParserSuper                      = 101
	JavaScriptParserConst                      = 102
	JavaScriptParserExport                     = 103
	JavaScriptParserImport                     = 104
	JavaScriptParserAsync                      = 105
	JavaScriptParserAwait                      = 106
	JavaScriptParserImplements                 = 107
	JavaScriptParserLet                        = 108
	JavaScriptParserPrivate                    = 109
	JavaScriptParserPublic                     = 110
	JavaScriptParserInterface                  = 111
	JavaScriptParserPackage                    = 112
	JavaScriptParserProtected                  = 113
	JavaScriptParserStatic                     = 114
	JavaScriptParserYield                      = 115
	JavaScriptParserIdentifier                 = 116
	JavaScriptParserStringLiteral              = 117
	JavaScriptParserTemplateStringLiteral      = 118
	JavaScriptParserWhiteSpaces                = 119
	JavaScriptParserLineTerminator             = 120
	JavaScriptParserHtmlComment                = 121
	JavaScriptParserCDataComment               = 122
	JavaScriptParserUnexpectedCharacter        = 123
)

// JavaScriptParser rules.
const (
	JavaScriptParserRULE_program                 = 0
	JavaScriptParserRULE_sourceElement           = 1
	JavaScriptParserRULE_statement               = 2
	JavaScriptParserRULE_block                   = 3
	JavaScriptParserRULE_statementList           = 4
	JavaScriptParserRULE_importStatement         = 5
	JavaScriptParserRULE_importFromBlock         = 6
	JavaScriptParserRULE_moduleItems             = 7
	JavaScriptParserRULE_importDefault           = 8
	JavaScriptParserRULE_importNamespace         = 9
	JavaScriptParserRULE_importFrom              = 10
	JavaScriptParserRULE_aliasName               = 11
	JavaScriptParserRULE_exportStatement         = 12
	JavaScriptParserRULE_exportFromBlock         = 13
	JavaScriptParserRULE_declaration             = 14
	JavaScriptParserRULE_variableStatement       = 15
	JavaScriptParserRULE_variableDeclarationList = 16
	JavaScriptParserRULE_variableDeclaration     = 17
	JavaScriptParserRULE_emptyStatement_         = 18
	JavaScriptParserRULE_expressionStatement     = 19
	JavaScriptParserRULE_ifStatement             = 20
	JavaScriptParserRULE_iterationStatement      = 21
	JavaScriptParserRULE_varModifier             = 22
	JavaScriptParserRULE_continueStatement       = 23
	JavaScriptParserRULE_breakStatement          = 24
	JavaScriptParserRULE_returnStatement         = 25
	JavaScriptParserRULE_yieldStatement          = 26
	JavaScriptParserRULE_withStatement           = 27
	JavaScriptParserRULE_switchStatement         = 28
	JavaScriptParserRULE_caseBlock               = 29
	JavaScriptParserRULE_caseClauses             = 30
	JavaScriptParserRULE_caseClause              = 31
	JavaScriptParserRULE_defaultClause           = 32
	JavaScriptParserRULE_labelledStatement       = 33
	JavaScriptParserRULE_throwStatement          = 34
	JavaScriptParserRULE_tryStatement            = 35
	JavaScriptParserRULE_catchProduction         = 36
	JavaScriptParserRULE_finallyProduction       = 37
	JavaScriptParserRULE_debuggerStatement       = 38
	JavaScriptParserRULE_functionDeclaration     = 39
	JavaScriptParserRULE_classDeclaration        = 40
	JavaScriptParserRULE_classTail               = 41
	JavaScriptParserRULE_classElement            = 42
	JavaScriptParserRULE_methodDefinition        = 43
	JavaScriptParserRULE_formalParameterList     = 44
	JavaScriptParserRULE_formalParameterArg      = 45
	JavaScriptParserRULE_lastFormalParameterArg  = 46
	JavaScriptParserRULE_functionBody            = 47
	JavaScriptParserRULE_sourceElements          = 48
	JavaScriptParserRULE_arrayLiteral            = 49
	JavaScriptParserRULE_elementList             = 50
	JavaScriptParserRULE_arrayElement            = 51
	JavaScriptParserRULE_objectLiteral           = 52
	JavaScriptParserRULE_propertyAssignment      = 53
	JavaScriptParserRULE_propertyName            = 54
	JavaScriptParserRULE_arguments               = 55
	JavaScriptParserRULE_argument                = 56
	JavaScriptParserRULE_expressionSequence      = 57
	JavaScriptParserRULE_singleExpression        = 58
	JavaScriptParserRULE_assignable              = 59
	JavaScriptParserRULE_anoymousFunction        = 60
	JavaScriptParserRULE_arrowFunctionParameters = 61
	JavaScriptParserRULE_arrowFunctionBody       = 62
	JavaScriptParserRULE_assignmentOperator      = 63
	JavaScriptParserRULE_literal                 = 64
	JavaScriptParserRULE_numericLiteral          = 65
	JavaScriptParserRULE_bigintLiteral           = 66
	JavaScriptParserRULE_identifierName          = 67
	JavaScriptParserRULE_reservedWord            = 68
	JavaScriptParserRULE_keyword                 = 69
	JavaScriptParserRULE_getter                  = 70
	JavaScriptParserRULE_setter                  = 71
	JavaScriptParserRULE_eos                     = 72
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_program
	return p
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEOF, 0)
}

func (s *ProgramContext) HashBangLine() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserHashBangLine, 0)
}

func (s *ProgramContext) SourceElements() ISourceElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (p *JavaScriptParser) Program() (localctx IProgramContext) {
	this := p
	_ = this

	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, JavaScriptParserRULE_program)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(147)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(146)
			p.Match(JavaScriptParserHashBangLine)
		}

	}
	p.SetState(150)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(149)
			p.SourceElements()
		}

	}
	{
		p.SetState(152)
		p.Match(JavaScriptParserEOF)
	}

	return localctx
}

// ISourceElementContext is an interface to support dynamic dispatch.
type ISourceElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceElementContext differentiates from other interfaces.
	IsSourceElementContext()
}

type SourceElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementContext() *SourceElementContext {
	var p = new(SourceElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_sourceElement
	return p
}

func (*SourceElementContext) IsSourceElementContext() {}

func NewSourceElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementContext {
	var p = new(SourceElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_sourceElement

	return p
}

func (s *SourceElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SourceElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterSourceElement(s)
	}
}

func (s *SourceElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitSourceElement(s)
	}
}

func (p *JavaScriptParser) SourceElement() (localctx ISourceElementContext) {
	this := p
	_ = this

	localctx = NewSourceElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, JavaScriptParserRULE_sourceElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(154)
		p.Statement()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *StatementContext) ImportStatement() IImportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *StatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *StatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *StatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) IterationStatement() IIterationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterationStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) YieldStatement() IYieldStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *StatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StatementContext) LabelledStatement() ILabelledStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelledStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelledStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) DebuggerStatement() IDebuggerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDebuggerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDebuggerStatementContext)
}

func (s *StatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *JavaScriptParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, JavaScriptParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(176)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(156)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(157)
			p.VariableStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(158)
			p.ImportStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(159)
			p.ExportStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(160)
			p.EmptyStatement_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(161)
			p.ClassDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(162)
			p.ExpressionStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(163)
			p.IfStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(164)
			p.IterationStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(165)
			p.ContinueStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(166)
			p.BreakStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(167)
			p.ReturnStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(168)
			p.YieldStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(169)
			p.WithStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(170)
			p.LabelledStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(171)
			p.SwitchStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(172)
			p.ThrowStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(173)
			p.TryStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(174)
			p.DebuggerStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(175)
			p.FunctionDeclaration()
		}

	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *BlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *BlockContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *JavaScriptParser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, JavaScriptParserRULE_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(178)
		p.Match(JavaScriptParserOpenBrace)
	}
	p.SetState(180)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(179)
			p.StatementList()
		}

	}
	{
		p.SetState(182)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// IStatementListContext is an interface to support dynamic dispatch.
type IStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementListContext differentiates from other interfaces.
	IsStatementListContext()
}

type StatementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementListContext() *StatementListContext {
	var p = new(StatementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_statementList
	return p
}

func (*StatementListContext) IsStatementListContext() {}

func NewStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementListContext {
	var p = new(StatementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_statementList

	return p
}

func (s *StatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementListContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementListContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterStatementList(s)
	}
}

func (s *StatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitStatementList(s)
	}
}

func (p *JavaScriptParser) StatementList() (localctx IStatementListContext) {
	this := p
	_ = this

	localctx = NewStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, JavaScriptParserRULE_statementList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(185)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(184)
				p.Statement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(187)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
	}

	return localctx
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importStatement
	return p
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) Import() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserImport, 0)
}

func (s *ImportStatementContext) ImportFromBlock() IImportFromBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromBlockContext)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterImportStatement(s)
	}
}

func (s *ImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitImportStatement(s)
	}
}

func (p *JavaScriptParser) ImportStatement() (localctx IImportStatementContext) {
	this := p
	_ = this

	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, JavaScriptParserRULE_importStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(189)
		p.Match(JavaScriptParserImport)
	}
	{
		p.SetState(190)
		p.ImportFromBlock()
	}

	return localctx
}

// IImportFromBlockContext is an interface to support dynamic dispatch.
type IImportFromBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportFromBlockContext differentiates from other interfaces.
	IsImportFromBlockContext()
}

type ImportFromBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportFromBlockContext() *ImportFromBlockContext {
	var p = new(ImportFromBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importFromBlock
	return p
}

func (*ImportFromBlockContext) IsImportFromBlockContext() {}

func NewImportFromBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportFromBlockContext {
	var p = new(ImportFromBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importFromBlock

	return p
}

func (s *ImportFromBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportFromBlockContext) ImportFrom() IImportFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromContext)
}

func (s *ImportFromBlockContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ImportFromBlockContext) ImportNamespace() IImportNamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportNamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportNamespaceContext)
}

func (s *ImportFromBlockContext) ModuleItems() IModuleItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleItemsContext)
}

func (s *ImportFromBlockContext) ImportDefault() IImportDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDefaultContext)
}

func (s *ImportFromBlockContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStringLiteral, 0)
}

func (s *ImportFromBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportFromBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterImportFromBlock(s)
	}
}

func (s *ImportFromBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitImportFromBlock(s)
	}
}

func (p *JavaScriptParser) ImportFromBlock() (localctx IImportFromBlockContext) {
	this := p
	_ = this

	localctx = NewImportFromBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, JavaScriptParserRULE_importFromBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(204)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserOpenBrace, JavaScriptParserMultiply, JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserImplements, JavaScriptParserLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserYield, JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(193)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-59)) & ^0x3f) == 0 && ((int64(1)<<(_la-59))&288230376151709699) != 0 {
			{
				p.SetState(192)
				p.ImportDefault()
			}

		}
		p.SetState(197)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaScriptParserMultiply:
			{
				p.SetState(195)
				p.ImportNamespace()
			}

		case JavaScriptParserOpenBrace:
			{
				p.SetState(196)
				p.ModuleItems()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(199)
			p.ImportFrom()
		}
		{
			p.SetState(200)
			p.Eos()
		}

	case JavaScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(202)
			p.Match(JavaScriptParserStringLiteral)
		}
		{
			p.SetState(203)
			p.Eos()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModuleItemsContext is an interface to support dynamic dispatch.
type IModuleItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleItemsContext differentiates from other interfaces.
	IsModuleItemsContext()
}

type ModuleItemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleItemsContext() *ModuleItemsContext {
	var p = new(ModuleItemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_moduleItems
	return p
}

func (*ModuleItemsContext) IsModuleItemsContext() {}

func NewModuleItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleItemsContext {
	var p = new(ModuleItemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_moduleItems

	return p
}

func (s *ModuleItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleItemsContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *ModuleItemsContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *ModuleItemsContext) AllAliasName() []IAliasNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAliasNameContext); ok {
			len++
		}
	}

	tst := make([]IAliasNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAliasNameContext); ok {
			tst[i] = t.(IAliasNameContext)
			i++
		}
	}

	return tst
}

func (s *ModuleItemsContext) AliasName(i int) IAliasNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasNameContext)
}

func (s *ModuleItemsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ModuleItemsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ModuleItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterModuleItems(s)
	}
}

func (s *ModuleItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitModuleItems(s)
	}
}

func (p *JavaScriptParser) ModuleItems() (localctx IModuleItemsContext) {
	this := p
	_ = this

	localctx = NewModuleItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, JavaScriptParserRULE_moduleItems)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(206)
		p.Match(JavaScriptParserOpenBrace)
	}
	p.SetState(212)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(207)
				p.AliasName()
			}
			{
				p.SetState(208)
				p.Match(JavaScriptParserComma)
			}

		}
		p.SetState(214)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}
	p.SetState(219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-59)) & ^0x3f) == 0 && ((int64(1)<<(_la-59))&288230376151709699) != 0 {
		{
			p.SetState(215)
			p.AliasName()
		}
		p.SetState(217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserComma {
			{
				p.SetState(216)
				p.Match(JavaScriptParserComma)
			}

		}

	}
	{
		p.SetState(221)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// IImportDefaultContext is an interface to support dynamic dispatch.
type IImportDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportDefaultContext differentiates from other interfaces.
	IsImportDefaultContext()
}

type ImportDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDefaultContext() *ImportDefaultContext {
	var p = new(ImportDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importDefault
	return p
}

func (*ImportDefaultContext) IsImportDefaultContext() {}

func NewImportDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDefaultContext {
	var p = new(ImportDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importDefault

	return p
}

func (s *ImportDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDefaultContext) AliasName() IAliasNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasNameContext)
}

func (s *ImportDefaultContext) Comma() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, 0)
}

func (s *ImportDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterImportDefault(s)
	}
}

func (s *ImportDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitImportDefault(s)
	}
}

func (p *JavaScriptParser) ImportDefault() (localctx IImportDefaultContext) {
	this := p
	_ = this

	localctx = NewImportDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, JavaScriptParserRULE_importDefault)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(223)
		p.AliasName()
	}
	{
		p.SetState(224)
		p.Match(JavaScriptParserComma)
	}

	return localctx
}

// IImportNamespaceContext is an interface to support dynamic dispatch.
type IImportNamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportNamespaceContext differentiates from other interfaces.
	IsImportNamespaceContext()
}

type ImportNamespaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportNamespaceContext() *ImportNamespaceContext {
	var p = new(ImportNamespaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importNamespace
	return p
}

func (*ImportNamespaceContext) IsImportNamespaceContext() {}

func NewImportNamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportNamespaceContext {
	var p = new(ImportNamespaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importNamespace

	return p
}

func (s *ImportNamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportNamespaceContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *ImportNamespaceContext) As() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAs, 0)
}

func (s *ImportNamespaceContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *ImportNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportNamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterImportNamespace(s)
	}
}

func (s *ImportNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitImportNamespace(s)
	}
}

func (p *JavaScriptParser) ImportNamespace() (localctx IImportNamespaceContext) {
	this := p
	_ = this

	localctx = NewImportNamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, JavaScriptParserRULE_importNamespace)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(226)
		p.Match(JavaScriptParserMultiply)
	}
	p.SetState(229)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserAs {
		{
			p.SetState(227)
			p.Match(JavaScriptParserAs)
		}
		{
			p.SetState(228)
			p.IdentifierName()
		}

	}

	return localctx
}

// IImportFromContext is an interface to support dynamic dispatch.
type IImportFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportFromContext differentiates from other interfaces.
	IsImportFromContext()
}

type ImportFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportFromContext() *ImportFromContext {
	var p = new(ImportFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importFrom
	return p
}

func (*ImportFromContext) IsImportFromContext() {}

func NewImportFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportFromContext {
	var p = new(ImportFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importFrom

	return p
}

func (s *ImportFromContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportFromContext) From() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFrom, 0)
}

func (s *ImportFromContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStringLiteral, 0)
}

func (s *ImportFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterImportFrom(s)
	}
}

func (s *ImportFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitImportFrom(s)
	}
}

func (p *JavaScriptParser) ImportFrom() (localctx IImportFromContext) {
	this := p
	_ = this

	localctx = NewImportFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, JavaScriptParserRULE_importFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(231)
		p.Match(JavaScriptParserFrom)
	}
	{
		p.SetState(232)
		p.Match(JavaScriptParserStringLiteral)
	}

	return localctx
}

// IAliasNameContext is an interface to support dynamic dispatch.
type IAliasNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasNameContext differentiates from other interfaces.
	IsAliasNameContext()
}

type AliasNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasNameContext() *AliasNameContext {
	var p = new(AliasNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_aliasName
	return p
}

func (*AliasNameContext) IsAliasNameContext() {}

func NewAliasNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasNameContext {
	var p = new(AliasNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_aliasName

	return p
}

func (s *AliasNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasNameContext) AllIdentifierName() []IIdentifierNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierNameContext); ok {
			tst[i] = t.(IIdentifierNameContext)
			i++
		}
	}

	return tst
}

func (s *AliasNameContext) IdentifierName(i int) IIdentifierNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *AliasNameContext) As() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAs, 0)
}

func (s *AliasNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAliasName(s)
	}
}

func (s *AliasNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAliasName(s)
	}
}

func (p *JavaScriptParser) AliasName() (localctx IAliasNameContext) {
	this := p
	_ = this

	localctx = NewAliasNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, JavaScriptParserRULE_aliasName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(234)
		p.IdentifierName()
	}
	p.SetState(237)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserAs {
		{
			p.SetState(235)
			p.Match(JavaScriptParserAs)
		}
		{
			p.SetState(236)
			p.IdentifierName()
		}

	}

	return localctx
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_exportStatement
	return p
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) CopyFrom(ctx *ExportStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExportDefaultDeclarationContext struct {
	*ExportStatementContext
}

func NewExportDefaultDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportDefaultDeclarationContext {
	var p = new(ExportDefaultDeclarationContext)

	p.ExportStatementContext = NewEmptyExportStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExportStatementContext))

	return p
}

func (s *ExportDefaultDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDefaultDeclarationContext) Export() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExport, 0)
}

func (s *ExportDefaultDeclarationContext) Default() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDefault, 0)
}

func (s *ExportDefaultDeclarationContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ExportDefaultDeclarationContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportDefaultDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterExportDefaultDeclaration(s)
	}
}

func (s *ExportDefaultDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitExportDefaultDeclaration(s)
	}
}

type ExportDeclarationContext struct {
	*ExportStatementContext
}

func NewExportDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportDeclarationContext {
	var p = new(ExportDeclarationContext)

	p.ExportStatementContext = NewEmptyExportStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExportStatementContext))

	return p
}

func (s *ExportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDeclarationContext) Export() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExport, 0)
}

func (s *ExportDeclarationContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportDeclarationContext) ExportFromBlock() IExportFromBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportFromBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportFromBlockContext)
}

func (s *ExportDeclarationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ExportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterExportDeclaration(s)
	}
}

func (s *ExportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitExportDeclaration(s)
	}
}

func (p *JavaScriptParser) ExportStatement() (localctx IExportStatementContext) {
	this := p
	_ = this

	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, JavaScriptParserRULE_exportStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(251)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExportDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(239)
			p.Match(JavaScriptParserExport)
		}
		p.SetState(242)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaScriptParserOpenBrace, JavaScriptParserMultiply:
			{
				p.SetState(240)
				p.ExportFromBlock()
			}

		case JavaScriptParserVar, JavaScriptParserFunction, JavaScriptParserClass, JavaScriptParserConst, JavaScriptParserAsync, JavaScriptParserLet:
			{
				p.SetState(241)
				p.Declaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(244)
			p.Eos()
		}

	case 2:
		localctx = NewExportDefaultDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(246)
			p.Match(JavaScriptParserExport)
		}
		{
			p.SetState(247)
			p.Match(JavaScriptParserDefault)
		}
		{
			p.SetState(248)
			p.singleExpression(0)
		}
		{
			p.SetState(249)
			p.Eos()
		}

	}

	return localctx
}

// IExportFromBlockContext is an interface to support dynamic dispatch.
type IExportFromBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExportFromBlockContext differentiates from other interfaces.
	IsExportFromBlockContext()
}

type ExportFromBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportFromBlockContext() *ExportFromBlockContext {
	var p = new(ExportFromBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_exportFromBlock
	return p
}

func (*ExportFromBlockContext) IsExportFromBlockContext() {}

func NewExportFromBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportFromBlockContext {
	var p = new(ExportFromBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_exportFromBlock

	return p
}

func (s *ExportFromBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportFromBlockContext) ImportNamespace() IImportNamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportNamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportNamespaceContext)
}

func (s *ExportFromBlockContext) ImportFrom() IImportFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromContext)
}

func (s *ExportFromBlockContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportFromBlockContext) ModuleItems() IModuleItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleItemsContext)
}

func (s *ExportFromBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportFromBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportFromBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterExportFromBlock(s)
	}
}

func (s *ExportFromBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitExportFromBlock(s)
	}
}

func (p *JavaScriptParser) ExportFromBlock() (localctx IExportFromBlockContext) {
	this := p
	_ = this

	localctx = NewExportFromBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, JavaScriptParserRULE_exportFromBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(263)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserMultiply:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(253)
			p.ImportNamespace()
		}
		{
			p.SetState(254)
			p.ImportFrom()
		}
		{
			p.SetState(255)
			p.Eos()
		}

	case JavaScriptParserOpenBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(257)
			p.ModuleItems()
		}
		p.SetState(259)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(258)
				p.ImportFrom()
			}

		}
		{
			p.SetState(261)
			p.Eos()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *DeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *DeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (p *JavaScriptParser) Declaration() (localctx IDeclarationContext) {
	this := p
	_ = this

	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, JavaScriptParserRULE_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(268)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserVar, JavaScriptParserConst, JavaScriptParserLet:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(265)
			p.VariableStatement()
		}

	case JavaScriptParserClass:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(266)
			p.ClassDeclaration()
		}

	case JavaScriptParserFunction, JavaScriptParserAsync:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(267)
			p.FunctionDeclaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableStatementContext is an interface to support dynamic dispatch.
type IVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableStatementContext differentiates from other interfaces.
	IsVariableStatementContext()
}

type VariableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableStatementContext() *VariableStatementContext {
	var p = new(VariableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableStatement
	return p
}

func (*VariableStatementContext) IsVariableStatementContext() {}

func NewVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableStatementContext {
	var p = new(VariableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_variableStatement

	return p
}

func (s *VariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableStatementContext) VarModifier() IVarModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *VariableStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *VariableStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *VariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterVariableStatement(s)
	}
}

func (s *VariableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitVariableStatement(s)
	}
}

func (p *JavaScriptParser) VariableStatement() (localctx IVariableStatementContext) {
	this := p
	_ = this

	localctx = NewVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, JavaScriptParserRULE_variableStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(270)
		p.VarModifier()
	}
	{
		p.SetState(271)
		p.VariableDeclarationList()
	}
	{
		p.SetState(272)
		p.Eos()
	}

	return localctx
}

// IVariableDeclarationListContext is an interface to support dynamic dispatch.
type IVariableDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationListContext differentiates from other interfaces.
	IsVariableDeclarationListContext()
}

type VariableDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationListContext() *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableDeclarationList
	return p
}

func (*VariableDeclarationListContext) IsVariableDeclarationListContext() {}

func NewVariableDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_variableDeclarationList

	return p
}

func (s *VariableDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationListContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationListContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *VariableDeclarationListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *VariableDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitVariableDeclarationList(s)
	}
}

func (p *JavaScriptParser) VariableDeclarationList() (localctx IVariableDeclarationListContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, JavaScriptParserRULE_variableDeclarationList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(274)
		p.VariableDeclaration()
	}
	p.SetState(279)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(275)
				p.Match(JavaScriptParserComma)
			}
			{
				p.SetState(276)
				p.VariableDeclaration()
			}

		}
		p.SetState(281)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *VariableDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *VariableDeclarationContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *JavaScriptParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, JavaScriptParserRULE_variableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(282)
		p.Assignable()
	}
	p.SetState(285)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(283)
			p.Match(JavaScriptParserAssign)
		}
		{
			p.SetState(284)
			p.singleExpression(0)
		}

	}

	return localctx
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_emptyStatement_
	return p
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SemiColon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSemiColon, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (p *JavaScriptParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	this := p
	_ = this

	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, JavaScriptParserRULE_emptyStatement_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(287)
		p.Match(JavaScriptParserSemiColon)
	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ExpressionStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (p *JavaScriptParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	this := p
	_ = this

	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, JavaScriptParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(289)

	if !(p.notOpenBraceAndNotFunction()) {
		panic(antlr.NewFailedPredicateException(p, "p.notOpenBraceAndNotFunction()", ""))
	}
	{
		p.SetState(290)
		p.ExpressionSequence()
	}
	{
		p.SetState(291)
		p.Eos()
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) If() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIf, 0)
}

func (s *IfStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *IfStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *IfStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserElse, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *JavaScriptParser) IfStatement() (localctx IIfStatementContext) {
	this := p
	_ = this

	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, JavaScriptParserRULE_ifStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(293)
		p.Match(JavaScriptParserIf)
	}
	{
		p.SetState(294)
		p.Match(JavaScriptParserOpenParen)
	}
	{
		p.SetState(295)
		p.ExpressionSequence()
	}
	{
		p.SetState(296)
		p.Match(JavaScriptParserCloseParen)
	}
	{
		p.SetState(297)
		p.Statement()
	}
	p.SetState(300)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(298)
			p.Match(JavaScriptParserElse)
		}
		{
			p.SetState(299)
			p.Statement()
		}

	}

	return localctx
}

// IIterationStatementContext is an interface to support dynamic dispatch.
type IIterationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIterationStatementContext differentiates from other interfaces.
	IsIterationStatementContext()
}

type IterationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterationStatementContext() *IterationStatementContext {
	var p = new(IterationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_iterationStatement
	return p
}

func (*IterationStatementContext) IsIterationStatementContext() {}

func NewIterationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterationStatementContext {
	var p = new(IterationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_iterationStatement

	return p
}

func (s *IterationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterationStatementContext) CopyFrom(ctx *IterationStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IterationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DoStatementContext struct {
	*IterationStatementContext
}

func NewDoStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoStatementContext {
	var p = new(DoStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDo, 0)
}

func (s *DoStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoStatementContext) While() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWhile, 0)
}

func (s *DoStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *DoStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *DoStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *DoStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

type WhileStatementContext struct {
	*IterationStatementContext
}

func NewWhileStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWhile, 0)
}

func (s *WhileStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *WhileStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WhileStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

type ForStatementContext struct {
	*IterationStatementContext
}

func NewForStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForStatementContext {
	var p = new(ForStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *ForStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ForStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserSemiColon)
}

func (s *ForStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSemiColon, i)
}

func (s *ForStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) AllExpressionSequence() []IExpressionSequenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			len++
		}
	}

	tst := make([]IExpressionSequenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionSequenceContext); ok {
			tst[i] = t.(IExpressionSequenceContext)
			i++
		}
	}

	return tst
}

func (s *ForStatementContext) ExpressionSequence(i int) IExpressionSequenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForStatementContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

type ForInStatementContext struct {
	*IterationStatementContext
}

func NewForInStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForInStatementContext {
	var p = new(ForInStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInStatementContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *ForInStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ForInStatementContext) In() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIn, 0)
}

func (s *ForInStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForInStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ForInStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForInStatementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForInStatementContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *ForInStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterForInStatement(s)
	}
}

func (s *ForInStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitForInStatement(s)
	}
}

type ForOfStatementContext struct {
	*IterationStatementContext
}

func NewForOfStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForOfStatementContext {
	var p = new(ForOfStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForOfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForOfStatementContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *ForOfStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ForOfStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ForOfStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForOfStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ForOfStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForOfStatementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForOfStatementContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *ForOfStatementContext) Await() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAwait, 0)
}

func (s *ForOfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterForOfStatement(s)
	}
}

func (s *ForOfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitForOfStatement(s)
	}
}

func (p *JavaScriptParser) IterationStatement() (localctx IIterationStatementContext) {
	this := p
	_ = this

	localctx = NewIterationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, JavaScriptParserRULE_iterationStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(358)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDoStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(302)
			p.Match(JavaScriptParserDo)
		}
		{
			p.SetState(303)
			p.Statement()
		}
		{
			p.SetState(304)
			p.Match(JavaScriptParserWhile)
		}
		{
			p.SetState(305)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(306)
			p.ExpressionSequence()
		}
		{
			p.SetState(307)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(308)
			p.Eos()
		}

	case 2:
		localctx = NewWhileStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(310)
			p.Match(JavaScriptParserWhile)
		}
		{
			p.SetState(311)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(312)
			p.ExpressionSequence()
		}
		{
			p.SetState(313)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(314)
			p.Statement()
		}

	case 3:
		localctx = NewForStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(316)
			p.Match(JavaScriptParserFor)
		}
		{
			p.SetState(317)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(320)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaScriptParserRegularExpressionLiteral, JavaScriptParserOpenBracket, JavaScriptParserOpenParen, JavaScriptParserOpenBrace, JavaScriptParserPlusPlus, JavaScriptParserMinusMinus, JavaScriptParserPlus, JavaScriptParserMinus, JavaScriptParserBitNot, JavaScriptParserNot, JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral, JavaScriptParserBigHexIntegerLiteral, JavaScriptParserBigOctalIntegerLiteral, JavaScriptParserBigBinaryIntegerLiteral, JavaScriptParserBigDecimalIntegerLiteral, JavaScriptParserTypeof, JavaScriptParserNew, JavaScriptParserVoid, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserDelete, JavaScriptParserClass, JavaScriptParserSuper, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserYield, JavaScriptParserIdentifier, JavaScriptParserStringLiteral, JavaScriptParserTemplateStringLiteral:
			{
				p.SetState(318)
				p.ExpressionSequence()
			}

		case JavaScriptParserVar, JavaScriptParserConst, JavaScriptParserLet:
			{
				p.SetState(319)
				p.VariableStatement()
			}

		case JavaScriptParserSemiColon:

		default:
		}
		{
			p.SetState(322)
			p.Match(JavaScriptParserSemiColon)
		}
		p.SetState(324)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576460752286907728) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33784848967668287) != 0 {
			{
				p.SetState(323)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(326)
			p.Match(JavaScriptParserSemiColon)
		}
		p.SetState(328)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576460752286907728) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33784848967668287) != 0 {
			{
				p.SetState(327)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(330)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(331)
			p.Statement()
		}

	case 4:
		localctx = NewForInStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(332)
			p.Match(JavaScriptParserFor)
		}
		{
			p.SetState(333)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(336)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaScriptParserRegularExpressionLiteral, JavaScriptParserOpenBracket, JavaScriptParserOpenParen, JavaScriptParserOpenBrace, JavaScriptParserPlusPlus, JavaScriptParserMinusMinus, JavaScriptParserPlus, JavaScriptParserMinus, JavaScriptParserBitNot, JavaScriptParserNot, JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral, JavaScriptParserBigHexIntegerLiteral, JavaScriptParserBigOctalIntegerLiteral, JavaScriptParserBigBinaryIntegerLiteral, JavaScriptParserBigDecimalIntegerLiteral, JavaScriptParserTypeof, JavaScriptParserNew, JavaScriptParserVoid, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserDelete, JavaScriptParserClass, JavaScriptParserSuper, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserYield, JavaScriptParserIdentifier, JavaScriptParserStringLiteral, JavaScriptParserTemplateStringLiteral:
			{
				p.SetState(334)
				p.singleExpression(0)
			}

		case JavaScriptParserVar, JavaScriptParserConst, JavaScriptParserLet:
			{
				p.SetState(335)
				p.VariableStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(338)
			p.Match(JavaScriptParserIn)
		}
		{
			p.SetState(339)
			p.ExpressionSequence()
		}
		{
			p.SetState(340)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(341)
			p.Statement()
		}

	case 5:
		localctx = NewForOfStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(343)
			p.Match(JavaScriptParserFor)
		}
		p.SetState(345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserAwait {
			{
				p.SetState(344)
				p.Match(JavaScriptParserAwait)
			}

		}
		{
			p.SetState(347)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(350)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaScriptParserRegularExpressionLiteral, JavaScriptParserOpenBracket, JavaScriptParserOpenParen, JavaScriptParserOpenBrace, JavaScriptParserPlusPlus, JavaScriptParserMinusMinus, JavaScriptParserPlus, JavaScriptParserMinus, JavaScriptParserBitNot, JavaScriptParserNot, JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral, JavaScriptParserBigHexIntegerLiteral, JavaScriptParserBigOctalIntegerLiteral, JavaScriptParserBigBinaryIntegerLiteral, JavaScriptParserBigDecimalIntegerLiteral, JavaScriptParserTypeof, JavaScriptParserNew, JavaScriptParserVoid, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserDelete, JavaScriptParserClass, JavaScriptParserSuper, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserYield, JavaScriptParserIdentifier, JavaScriptParserStringLiteral, JavaScriptParserTemplateStringLiteral:
			{
				p.SetState(348)
				p.singleExpression(0)
			}

		case JavaScriptParserVar, JavaScriptParserConst, JavaScriptParserLet:
			{
				p.SetState(349)
				p.VariableStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(352)
			p.Match(JavaScriptParserIdentifier)
		}
		p.SetState(353)

		if !(p.p("of")) {
			panic(antlr.NewFailedPredicateException(p, "p.p(\"of\")", ""))
		}
		{
			p.SetState(354)
			p.ExpressionSequence()
		}
		{
			p.SetState(355)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(356)
			p.Statement()
		}

	}

	return localctx
}

// IVarModifierContext is an interface to support dynamic dispatch.
type IVarModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarModifierContext differentiates from other interfaces.
	IsVarModifierContext()
}

type VarModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarModifierContext() *VarModifierContext {
	var p = new(VarModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_varModifier
	return p
}

func (*VarModifierContext) IsVarModifierContext() {}

func NewVarModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarModifierContext {
	var p = new(VarModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_varModifier

	return p
}

func (s *VarModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VarModifierContext) Var() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVar, 0)
}

func (s *VarModifierContext) Let() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLet, 0)
}

func (s *VarModifierContext) Const() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserConst, 0)
}

func (s *VarModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterVarModifier(s)
	}
}

func (s *VarModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitVarModifier(s)
	}
}

func (p *JavaScriptParser) VarModifier() (localctx IVarModifierContext) {
	this := p
	_ = this

	localctx = NewVarModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, JavaScriptParserRULE_varModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(360)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&2181038081) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserContinue, 0)
}

func (s *ContinueStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ContinueStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *JavaScriptParser) ContinueStatement() (localctx IContinueStatementContext) {
	this := p
	_ = this

	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, JavaScriptParserRULE_continueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(362)
		p.Match(JavaScriptParserContinue)
	}
	p.SetState(365)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
		p.SetState(363)

		if !(p.notLineTerminator()) {
			panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		}
		{
			p.SetState(364)
			p.Match(JavaScriptParserIdentifier)
		}

	}
	{
		p.SetState(367)
		p.Eos()
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBreak, 0)
}

func (s *BreakStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *BreakStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *JavaScriptParser) BreakStatement() (localctx IBreakStatementContext) {
	this := p
	_ = this

	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, JavaScriptParserRULE_breakStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(369)
		p.Match(JavaScriptParserBreak)
	}
	p.SetState(372)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
		p.SetState(370)

		if !(p.notLineTerminator()) {
			panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		}
		{
			p.SetState(371)
			p.Match(JavaScriptParserIdentifier)
		}

	}
	{
		p.SetState(374)
		p.Eos()
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserReturn, 0)
}

func (s *ReturnStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ReturnStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *JavaScriptParser) ReturnStatement() (localctx IReturnStatementContext) {
	this := p
	_ = this

	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, JavaScriptParserRULE_returnStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(376)
		p.Match(JavaScriptParserReturn)
	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
		p.SetState(377)

		if !(p.notLineTerminator()) {
			panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		}
		{
			p.SetState(378)
			p.ExpressionSequence()
		}

	}
	{
		p.SetState(381)
		p.Eos()
	}

	return localctx
}

// IYieldStatementContext is an interface to support dynamic dispatch.
type IYieldStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldStatementContext differentiates from other interfaces.
	IsYieldStatementContext()
}

type YieldStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStatementContext() *YieldStatementContext {
	var p = new(YieldStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_yieldStatement
	return p
}

func (*YieldStatementContext) IsYieldStatementContext() {}

func NewYieldStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStatementContext {
	var p = new(YieldStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_yieldStatement

	return p
}

func (s *YieldStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStatementContext) Yield() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserYield, 0)
}

func (s *YieldStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *YieldStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *YieldStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterYieldStatement(s)
	}
}

func (s *YieldStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitYieldStatement(s)
	}
}

func (p *JavaScriptParser) YieldStatement() (localctx IYieldStatementContext) {
	this := p
	_ = this

	localctx = NewYieldStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, JavaScriptParserRULE_yieldStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(383)
		p.Match(JavaScriptParserYield)
	}
	p.SetState(386)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
		p.SetState(384)

		if !(p.notLineTerminator()) {
			panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		}
		{
			p.SetState(385)
			p.ExpressionSequence()
		}

	}
	{
		p.SetState(388)
		p.Eos()
	}

	return localctx
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_withStatement
	return p
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) With() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWith, 0)
}

func (s *WithStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *WithStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WithStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (p *JavaScriptParser) WithStatement() (localctx IWithStatementContext) {
	this := p
	_ = this

	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, JavaScriptParserRULE_withStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(390)
		p.Match(JavaScriptParserWith)
	}
	{
		p.SetState(391)
		p.Match(JavaScriptParserOpenParen)
	}
	{
		p.SetState(392)
		p.ExpressionSequence()
	}
	{
		p.SetState(393)
		p.Match(JavaScriptParserCloseParen)
	}
	{
		p.SetState(394)
		p.Statement()
	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSwitch, 0)
}

func (s *SwitchStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *SwitchStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *SwitchStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *SwitchStatementContext) CaseBlock() ICaseBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (p *JavaScriptParser) SwitchStatement() (localctx ISwitchStatementContext) {
	this := p
	_ = this

	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, JavaScriptParserRULE_switchStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.Match(JavaScriptParserSwitch)
	}
	{
		p.SetState(397)
		p.Match(JavaScriptParserOpenParen)
	}
	{
		p.SetState(398)
		p.ExpressionSequence()
	}
	{
		p.SetState(399)
		p.Match(JavaScriptParserCloseParen)
	}
	{
		p.SetState(400)
		p.CaseBlock()
	}

	return localctx
}

// ICaseBlockContext is an interface to support dynamic dispatch.
type ICaseBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseBlockContext differentiates from other interfaces.
	IsCaseBlockContext()
}

type CaseBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseBlockContext() *CaseBlockContext {
	var p = new(CaseBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseBlock
	return p
}

func (*CaseBlockContext) IsCaseBlockContext() {}

func NewCaseBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseBlockContext {
	var p = new(CaseBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_caseBlock

	return p
}

func (s *CaseBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseBlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *CaseBlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *CaseBlockContext) AllCaseClauses() []ICaseClausesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClausesContext); ok {
			len++
		}
	}

	tst := make([]ICaseClausesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClausesContext); ok {
			tst[i] = t.(ICaseClausesContext)
			i++
		}
	}

	return tst
}

func (s *CaseBlockContext) CaseClauses(i int) ICaseClausesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClausesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClausesContext)
}

func (s *CaseBlockContext) DefaultClause() IDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *CaseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterCaseBlock(s)
	}
}

func (s *CaseBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitCaseBlock(s)
	}
}

func (p *JavaScriptParser) CaseBlock() (localctx ICaseBlockContext) {
	this := p
	_ = this

	localctx = NewCaseBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, JavaScriptParserRULE_caseBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Match(JavaScriptParserOpenBrace)
	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserCase {
		{
			p.SetState(403)
			p.CaseClauses()
		}

	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserDefault {
		{
			p.SetState(406)
			p.DefaultClause()
		}
		p.SetState(408)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserCase {
			{
				p.SetState(407)
				p.CaseClauses()
			}

		}

	}
	{
		p.SetState(412)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// ICaseClausesContext is an interface to support dynamic dispatch.
type ICaseClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseClausesContext differentiates from other interfaces.
	IsCaseClausesContext()
}

type CaseClausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClausesContext() *CaseClausesContext {
	var p = new(CaseClausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseClauses
	return p
}

func (*CaseClausesContext) IsCaseClausesContext() {}

func NewCaseClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClausesContext {
	var p = new(CaseClausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_caseClauses

	return p
}

func (s *CaseClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClausesContext) AllCaseClause() []ICaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClauseContext); ok {
			tst[i] = t.(ICaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *CaseClausesContext) CaseClause(i int) ICaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *CaseClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterCaseClauses(s)
	}
}

func (s *CaseClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitCaseClauses(s)
	}
}

func (p *JavaScriptParser) CaseClauses() (localctx ICaseClausesContext) {
	this := p
	_ = this

	localctx = NewCaseClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, JavaScriptParserRULE_caseClauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == JavaScriptParserCase {
		{
			p.SetState(414)
			p.CaseClause()
		}

		p.SetState(417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseClause
	return p
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) Case() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCase, 0)
}

func (s *CaseClauseContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *CaseClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *CaseClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (p *JavaScriptParser) CaseClause() (localctx ICaseClauseContext) {
	this := p
	_ = this

	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, JavaScriptParserRULE_caseClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(419)
		p.Match(JavaScriptParserCase)
	}
	{
		p.SetState(420)
		p.ExpressionSequence()
	}
	{
		p.SetState(421)
		p.Match(JavaScriptParserColon)
	}
	p.SetState(423)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(422)
			p.StatementList()
		}

	}

	return localctx
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_defaultClause
	return p
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) Default() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDefault, 0)
}

func (s *DefaultClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *DefaultClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterDefaultClause(s)
	}
}

func (s *DefaultClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitDefaultClause(s)
	}
}

func (p *JavaScriptParser) DefaultClause() (localctx IDefaultClauseContext) {
	this := p
	_ = this

	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, JavaScriptParserRULE_defaultClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(425)
		p.Match(JavaScriptParserDefault)
	}
	{
		p.SetState(426)
		p.Match(JavaScriptParserColon)
	}
	p.SetState(428)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(427)
			p.StatementList()
		}

	}

	return localctx
}

// ILabelledStatementContext is an interface to support dynamic dispatch.
type ILabelledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelledStatementContext differentiates from other interfaces.
	IsLabelledStatementContext()
}

type LabelledStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelledStatementContext() *LabelledStatementContext {
	var p = new(LabelledStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_labelledStatement
	return p
}

func (*LabelledStatementContext) IsLabelledStatementContext() {}

func NewLabelledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelledStatementContext {
	var p = new(LabelledStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_labelledStatement

	return p
}

func (s *LabelledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelledStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *LabelledStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *LabelledStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabelledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLabelledStatement(s)
	}
}

func (s *LabelledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLabelledStatement(s)
	}
}

func (p *JavaScriptParser) LabelledStatement() (localctx ILabelledStatementContext) {
	this := p
	_ = this

	localctx = NewLabelledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, JavaScriptParserRULE_labelledStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(430)
		p.Match(JavaScriptParserIdentifier)
	}
	{
		p.SetState(431)
		p.Match(JavaScriptParserColon)
	}
	{
		p.SetState(432)
		p.Statement()
	}

	return localctx
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_throwStatement
	return p
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) Throw() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThrow, 0)
}

func (s *ThrowStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ThrowStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (p *JavaScriptParser) ThrowStatement() (localctx IThrowStatementContext) {
	this := p
	_ = this

	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, JavaScriptParserRULE_throwStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(434)
		p.Match(JavaScriptParserThrow)
	}
	p.SetState(435)

	if !(p.notLineTerminator()) {
		panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
	}
	{
		p.SetState(436)
		p.ExpressionSequence()
	}
	{
		p.SetState(437)
		p.Eos()
	}

	return localctx
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_tryStatement
	return p
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) Try() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTry, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) CatchProduction() ICatchProductionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchProductionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchProductionContext)
}

func (s *TryStatementContext) FinallyProduction() IFinallyProductionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyProductionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyProductionContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (p *JavaScriptParser) TryStatement() (localctx ITryStatementContext) {
	this := p
	_ = this

	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, JavaScriptParserRULE_tryStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(439)
		p.Match(JavaScriptParserTry)
	}
	{
		p.SetState(440)
		p.Block()
	}
	p.SetState(446)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserCatch:
		{
			p.SetState(441)
			p.CatchProduction()
		}
		p.SetState(443)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(442)
				p.FinallyProduction()
			}

		}

	case JavaScriptParserFinally:
		{
			p.SetState(445)
			p.FinallyProduction()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICatchProductionContext is an interface to support dynamic dispatch.
type ICatchProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchProductionContext differentiates from other interfaces.
	IsCatchProductionContext()
}

type CatchProductionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchProductionContext() *CatchProductionContext {
	var p = new(CatchProductionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_catchProduction
	return p
}

func (*CatchProductionContext) IsCatchProductionContext() {}

func NewCatchProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchProductionContext {
	var p = new(CatchProductionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_catchProduction

	return p
}

func (s *CatchProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchProductionContext) Catch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCatch, 0)
}

func (s *CatchProductionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchProductionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *CatchProductionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *CatchProductionContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *CatchProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterCatchProduction(s)
	}
}

func (s *CatchProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitCatchProduction(s)
	}
}

func (p *JavaScriptParser) CatchProduction() (localctx ICatchProductionContext) {
	this := p
	_ = this

	localctx = NewCatchProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, JavaScriptParserRULE_catchProduction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(448)
		p.Match(JavaScriptParserCatch)
	}
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserOpenParen {
		{
			p.SetState(449)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(451)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserOpenBracket || _la == JavaScriptParserOpenBrace || _la == JavaScriptParserIdentifier {
			{
				p.SetState(450)
				p.Assignable()
			}

		}
		{
			p.SetState(453)
			p.Match(JavaScriptParserCloseParen)
		}

	}
	{
		p.SetState(456)
		p.Block()
	}

	return localctx
}

// IFinallyProductionContext is an interface to support dynamic dispatch.
type IFinallyProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyProductionContext differentiates from other interfaces.
	IsFinallyProductionContext()
}

type FinallyProductionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyProductionContext() *FinallyProductionContext {
	var p = new(FinallyProductionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_finallyProduction
	return p
}

func (*FinallyProductionContext) IsFinallyProductionContext() {}

func NewFinallyProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyProductionContext {
	var p = new(FinallyProductionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_finallyProduction

	return p
}

func (s *FinallyProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyProductionContext) Finally() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFinally, 0)
}

func (s *FinallyProductionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFinallyProduction(s)
	}
}

func (s *FinallyProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFinallyProduction(s)
	}
}

func (p *JavaScriptParser) FinallyProduction() (localctx IFinallyProductionContext) {
	this := p
	_ = this

	localctx = NewFinallyProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, JavaScriptParserRULE_finallyProduction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Match(JavaScriptParserFinally)
	}
	{
		p.SetState(459)
		p.Block()
	}

	return localctx
}

// IDebuggerStatementContext is an interface to support dynamic dispatch.
type IDebuggerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDebuggerStatementContext differentiates from other interfaces.
	IsDebuggerStatementContext()
}

type DebuggerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDebuggerStatementContext() *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_debuggerStatement
	return p
}

func (*DebuggerStatementContext) IsDebuggerStatementContext() {}

func NewDebuggerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_debuggerStatement

	return p
}

func (s *DebuggerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DebuggerStatementContext) Debugger() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDebugger, 0)
}

func (s *DebuggerStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DebuggerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DebuggerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DebuggerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterDebuggerStatement(s)
	}
}

func (s *DebuggerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitDebuggerStatement(s)
	}
}

func (p *JavaScriptParser) DebuggerStatement() (localctx IDebuggerStatementContext) {
	this := p
	_ = this

	localctx = NewDebuggerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, JavaScriptParserRULE_debuggerStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(461)
		p.Match(JavaScriptParserDebugger)
	}
	{
		p.SetState(462)
		p.Eos()
	}

	return localctx
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_functionDeclaration
	return p
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) Function() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFunction, 0)
}

func (s *FunctionDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *FunctionDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *FunctionDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *FunctionDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *FunctionDeclarationContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *FunctionDeclarationContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *FunctionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (p *JavaScriptParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	this := p
	_ = this

	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, JavaScriptParserRULE_functionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserAsync {
		{
			p.SetState(464)
			p.Match(JavaScriptParserAsync)
		}

	}
	{
		p.SetState(467)
		p.Match(JavaScriptParserFunction)
	}
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserMultiply {
		{
			p.SetState(468)
			p.Match(JavaScriptParserMultiply)
		}

	}
	{
		p.SetState(471)
		p.Match(JavaScriptParserIdentifier)
	}
	{
		p.SetState(472)
		p.Match(JavaScriptParserOpenParen)
	}
	p.SetState(474)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || _la == JavaScriptParserIdentifier {
		{
			p.SetState(473)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(476)
		p.Match(JavaScriptParserCloseParen)
	}
	{
		p.SetState(477)
		p.Match(JavaScriptParserOpenBrace)
	}
	{
		p.SetState(478)
		p.FunctionBody()
	}
	{
		p.SetState(479)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) Class() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserClass, 0)
}

func (s *ClassDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ClassDeclarationContext) ClassTail() IClassTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTailContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *JavaScriptParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	this := p
	_ = this

	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, JavaScriptParserRULE_classDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(481)
		p.Match(JavaScriptParserClass)
	}
	{
		p.SetState(482)
		p.Match(JavaScriptParserIdentifier)
	}
	{
		p.SetState(483)
		p.ClassTail()
	}

	return localctx
}

// IClassTailContext is an interface to support dynamic dispatch.
type IClassTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassTailContext differentiates from other interfaces.
	IsClassTailContext()
}

type ClassTailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTailContext() *ClassTailContext {
	var p = new(ClassTailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classTail
	return p
}

func (*ClassTailContext) IsClassTailContext() {}

func NewClassTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTailContext {
	var p = new(ClassTailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_classTail

	return p
}

func (s *ClassTailContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTailContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *ClassTailContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *ClassTailContext) Extends() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExtends, 0)
}

func (s *ClassTailContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ClassTailContext) AllClassElement() []IClassElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassElementContext); ok {
			len++
		}
	}

	tst := make([]IClassElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassElementContext); ok {
			tst[i] = t.(IClassElementContext)
			i++
		}
	}

	return tst
}

func (s *ClassTailContext) ClassElement(i int) IClassElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassElementContext)
}

func (s *ClassTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterClassTail(s)
	}
}

func (s *ClassTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitClassTail(s)
	}
}

func (p *JavaScriptParser) ClassTail() (localctx IClassTailContext) {
	this := p
	_ = this

	localctx = NewClassTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, JavaScriptParserRULE_classTail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserExtends {
		{
			p.SetState(485)
			p.Match(JavaScriptParserExtends)
		}
		{
			p.SetState(486)
			p.singleExpression(0)
		}

	}
	{
		p.SetState(489)
		p.Match(JavaScriptParserOpenBrace)
	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(490)
				p.ClassElement()
			}

		}
		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
	}
	{
		p.SetState(496)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// IClassElementContext is an interface to support dynamic dispatch.
type IClassElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassElementContext differentiates from other interfaces.
	IsClassElementContext()
}

type ClassElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassElementContext() *ClassElementContext {
	var p = new(ClassElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classElement
	return p
}

func (*ClassElementContext) IsClassElementContext() {}

func NewClassElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassElementContext {
	var p = new(ClassElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_classElement

	return p
}

func (s *ClassElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassElementContext) MethodDefinition() IMethodDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDefinitionContext)
}

func (s *ClassElementContext) AllStatic() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserStatic)
}

func (s *ClassElementContext) Static(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStatic, i)
}

func (s *ClassElementContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserIdentifier)
}

func (s *ClassElementContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, i)
}

func (s *ClassElementContext) AllAsync() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserAsync)
}

func (s *ClassElementContext) Async(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, i)
}

func (s *ClassElementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *ClassElementContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *ClassElementContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *ClassElementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ClassElementContext) Hashtag() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserHashtag, 0)
}

func (s *ClassElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterClassElement(s)
	}
}

func (s *ClassElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitClassElement(s)
	}
}

func (p *JavaScriptParser) ClassElement() (localctx IClassElementContext) {
	this := p
	_ = this

	localctx = NewClassElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, JavaScriptParserRULE_classElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(516)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(504)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(502)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(498)
						p.Match(JavaScriptParserStatic)
					}

				case 2:
					p.SetState(499)

					if !(p.n("static")) {
						panic(antlr.NewFailedPredicateException(p, "p.n(\"static\")", ""))
					}
					{
						p.SetState(500)
						p.Match(JavaScriptParserIdentifier)
					}

				case 3:
					{
						p.SetState(501)
						p.Match(JavaScriptParserAsync)
					}

				}

			}
			p.SetState(506)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
		}
		{
			p.SetState(507)
			p.MethodDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(508)
			p.EmptyStatement_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserHashtag {
			{
				p.SetState(509)
				p.Match(JavaScriptParserHashtag)
			}

		}
		{
			p.SetState(512)
			p.PropertyName()
		}
		{
			p.SetState(513)
			p.Match(JavaScriptParserAssign)
		}
		{
			p.SetState(514)
			p.singleExpression(0)
		}

	}

	return localctx
}

// IMethodDefinitionContext is an interface to support dynamic dispatch.
type IMethodDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodDefinitionContext differentiates from other interfaces.
	IsMethodDefinitionContext()
}

type MethodDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDefinitionContext() *MethodDefinitionContext {
	var p = new(MethodDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_methodDefinition
	return p
}

func (*MethodDefinitionContext) IsMethodDefinitionContext() {}

func NewMethodDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDefinitionContext {
	var p = new(MethodDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_methodDefinition

	return p
}

func (s *MethodDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDefinitionContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *MethodDefinitionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *MethodDefinitionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *MethodDefinitionContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *MethodDefinitionContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *MethodDefinitionContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *MethodDefinitionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *MethodDefinitionContext) Hashtag() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserHashtag, 0)
}

func (s *MethodDefinitionContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *MethodDefinitionContext) Getter() IGetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *MethodDefinitionContext) Setter() ISetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *MethodDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterMethodDefinition(s)
	}
}

func (s *MethodDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitMethodDefinition(s)
	}
}

func (p *JavaScriptParser) MethodDefinition() (localctx IMethodDefinitionContext) {
	this := p
	_ = this

	localctx = NewMethodDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, JavaScriptParserRULE_methodDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(519)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserMultiply {
			{
				p.SetState(518)
				p.Match(JavaScriptParserMultiply)
			}

		}
		p.SetState(522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserHashtag {
			{
				p.SetState(521)
				p.Match(JavaScriptParserHashtag)
			}

		}
		{
			p.SetState(524)
			p.PropertyName()
		}
		{
			p.SetState(525)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(527)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || _la == JavaScriptParserIdentifier {
			{
				p.SetState(526)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(529)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(530)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(531)
			p.FunctionBody()
		}
		{
			p.SetState(532)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(535)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserMultiply {
			{
				p.SetState(534)
				p.Match(JavaScriptParserMultiply)
			}

		}
		p.SetState(538)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserHashtag {
			{
				p.SetState(537)
				p.Match(JavaScriptParserHashtag)
			}

		}
		{
			p.SetState(540)
			p.Getter()
		}
		{
			p.SetState(541)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(542)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(543)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(544)
			p.FunctionBody()
		}
		{
			p.SetState(545)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserMultiply {
			{
				p.SetState(547)
				p.Match(JavaScriptParserMultiply)
			}

		}
		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserHashtag {
			{
				p.SetState(550)
				p.Match(JavaScriptParserHashtag)
			}

		}
		{
			p.SetState(553)
			p.Setter()
		}
		{
			p.SetState(554)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || _la == JavaScriptParserIdentifier {
			{
				p.SetState(555)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(558)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(559)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(560)
			p.FunctionBody()
		}
		{
			p.SetState(561)
			p.Match(JavaScriptParserCloseBrace)
		}

	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameterArg() []IFormalParameterArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterArgContext); ok {
			tst[i] = t.(IFormalParameterArgContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterArg(i int) IFormalParameterArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterArgContext)
}

func (s *FormalParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *FormalParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *FormalParameterListContext) LastFormalParameterArg() ILastFormalParameterArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastFormalParameterArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastFormalParameterArgContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (p *JavaScriptParser) FormalParameterList() (localctx IFormalParameterListContext) {
	this := p
	_ = this

	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, JavaScriptParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(578)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserOpenBracket, JavaScriptParserOpenBrace, JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(565)
			p.FormalParameterArg()
		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(566)
					p.Match(JavaScriptParserComma)
				}
				{
					p.SetState(567)
					p.FormalParameterArg()
				}

			}
			p.SetState(572)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())
		}
		p.SetState(575)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserComma {
			{
				p.SetState(573)
				p.Match(JavaScriptParserComma)
			}
			{
				p.SetState(574)
				p.LastFormalParameterArg()
			}

		}

	case JavaScriptParserEllipsis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(577)
			p.LastFormalParameterArg()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFormalParameterArgContext is an interface to support dynamic dispatch.
type IFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterArgContext differentiates from other interfaces.
	IsFormalParameterArgContext()
}

type FormalParameterArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterArgContext() *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_formalParameterArg
	return p
}

func (*FormalParameterArgContext) IsFormalParameterArgContext() {}

func NewFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_formalParameterArg

	return p
}

func (s *FormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterArgContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *FormalParameterArgContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *FormalParameterArgContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *FormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFormalParameterArg(s)
	}
}

func (s *FormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFormalParameterArg(s)
	}
}

func (p *JavaScriptParser) FormalParameterArg() (localctx IFormalParameterArgContext) {
	this := p
	_ = this

	localctx = NewFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, JavaScriptParserRULE_formalParameterArg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		p.Assignable()
	}
	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserAssign {
		{
			p.SetState(581)
			p.Match(JavaScriptParserAssign)
		}
		{
			p.SetState(582)
			p.singleExpression(0)
		}

	}

	return localctx
}

// ILastFormalParameterArgContext is an interface to support dynamic dispatch.
type ILastFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLastFormalParameterArgContext differentiates from other interfaces.
	IsLastFormalParameterArgContext()
}

type LastFormalParameterArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFormalParameterArgContext() *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_lastFormalParameterArg
	return p
}

func (*LastFormalParameterArgContext) IsLastFormalParameterArgContext() {}

func NewLastFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_lastFormalParameterArg

	return p
}

func (s *LastFormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFormalParameterArgContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEllipsis, 0)
}

func (s *LastFormalParameterArgContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LastFormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLastFormalParameterArg(s)
	}
}

func (s *LastFormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLastFormalParameterArg(s)
	}
}

func (p *JavaScriptParser) LastFormalParameterArg() (localctx ILastFormalParameterArgContext) {
	this := p
	_ = this

	localctx = NewLastFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, JavaScriptParserRULE_lastFormalParameterArg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(585)
		p.Match(JavaScriptParserEllipsis)
	}
	{
		p.SetState(586)
		p.singleExpression(0)
	}

	return localctx
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_functionBody
	return p
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) SourceElements() ISourceElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (p *JavaScriptParser) FunctionBody() (localctx IFunctionBodyContext) {
	this := p
	_ = this

	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, JavaScriptParserRULE_functionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(589)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(588)
			p.SourceElements()
		}

	}

	return localctx
}

// ISourceElementsContext is an interface to support dynamic dispatch.
type ISourceElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceElementsContext differentiates from other interfaces.
	IsSourceElementsContext()
}

type SourceElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementsContext() *SourceElementsContext {
	var p = new(SourceElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_sourceElements
	return p
}

func (*SourceElementsContext) IsSourceElementsContext() {}

func NewSourceElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementsContext {
	var p = new(SourceElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_sourceElements

	return p
}

func (s *SourceElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementsContext) AllSourceElement() []ISourceElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISourceElementContext); ok {
			len++
		}
	}

	tst := make([]ISourceElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISourceElementContext); ok {
			tst[i] = t.(ISourceElementContext)
			i++
		}
	}

	return tst
}

func (s *SourceElementsContext) SourceElement(i int) ISourceElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementContext)
}

func (s *SourceElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterSourceElements(s)
	}
}

func (s *SourceElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitSourceElements(s)
	}
}

func (p *JavaScriptParser) SourceElements() (localctx ISourceElementsContext) {
	this := p
	_ = this

	localctx = NewSourceElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, JavaScriptParserRULE_sourceElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(591)
				p.SourceElement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
	}

	return localctx
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrayLiteral
	return p
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBracket, 0)
}

func (s *ArrayLiteralContext) ElementList() IElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *ArrayLiteralContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBracket, 0)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (p *JavaScriptParser) ArrayLiteral() (localctx IArrayLiteralContext) {
	this := p
	_ = this

	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, JavaScriptParserRULE_arrayLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.Match(JavaScriptParserOpenBracket)
	}
	{
		p.SetState(597)
		p.ElementList()
	}
	{
		p.SetState(598)
		p.Match(JavaScriptParserCloseBracket)
	}

	return localctx
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_elementList
	return p
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ElementListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ElementListContext) AllArrayElement() []IArrayElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElementContext); ok {
			len++
		}
	}

	tst := make([]IArrayElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElementContext); ok {
			tst[i] = t.(IArrayElementContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) ArrayElement(i int) IArrayElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElementContext)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (p *JavaScriptParser) ElementList() (localctx IElementListContext) {
	this := p
	_ = this

	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, JavaScriptParserRULE_elementList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(600)
				p.Match(JavaScriptParserComma)
			}

		}
		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576460752286842192) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33784848967668287) != 0 {
		{
			p.SetState(606)
			p.ArrayElement()
		}

	}
	p.SetState(617)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(610)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == JavaScriptParserComma {
				{
					p.SetState(609)
					p.Match(JavaScriptParserComma)
				}

				p.SetState(612)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(614)
				p.ArrayElement()
			}

		}
		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
	}
	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaScriptParserComma {
		{
			p.SetState(620)
			p.Match(JavaScriptParserComma)
		}

		p.SetState(625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArrayElementContext is an interface to support dynamic dispatch.
type IArrayElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayElementContext differentiates from other interfaces.
	IsArrayElementContext()
}

type ArrayElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElementContext() *ArrayElementContext {
	var p = new(ArrayElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrayElement
	return p
}

func (*ArrayElementContext) IsArrayElementContext() {}

func NewArrayElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElementContext {
	var p = new(ArrayElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arrayElement

	return p
}

func (s *ArrayElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrayElementContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEllipsis, 0)
}

func (s *ArrayElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArrayElement(s)
	}
}

func (s *ArrayElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArrayElement(s)
	}
}

func (p *JavaScriptParser) ArrayElement() (localctx IArrayElementContext) {
	this := p
	_ = this

	localctx = NewArrayElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, JavaScriptParserRULE_arrayElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserEllipsis {
		{
			p.SetState(626)
			p.Match(JavaScriptParserEllipsis)
		}

	}
	{
		p.SetState(629)
		p.singleExpression(0)
	}

	return localctx
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_objectLiteral
	return p
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *ObjectLiteralContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *ObjectLiteralContext) AllPropertyAssignment() []IPropertyAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IPropertyAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyAssignmentContext); ok {
			tst[i] = t.(IPropertyAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *ObjectLiteralContext) PropertyAssignment(i int) IPropertyAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentContext)
}

func (s *ObjectLiteralContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ObjectLiteralContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (p *JavaScriptParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	this := p
	_ = this

	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, JavaScriptParserRULE_objectLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.Match(JavaScriptParserOpenBrace)
	}
	p.SetState(640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576460752270064976) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&36028797018963967) != 0 {
		{
			p.SetState(632)
			p.PropertyAssignment()
		}
		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(633)
					p.Match(JavaScriptParserComma)
				}
				{
					p.SetState(634)
					p.PropertyAssignment()
				}

			}
			p.SetState(639)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())
		}

	}
	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserComma {
		{
			p.SetState(642)
			p.Match(JavaScriptParserComma)
		}

	}
	{
		p.SetState(645)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// IPropertyAssignmentContext is an interface to support dynamic dispatch.
type IPropertyAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyAssignmentContext differentiates from other interfaces.
	IsPropertyAssignmentContext()
}

type PropertyAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyAssignmentContext() *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_propertyAssignment
	return p
}

func (*PropertyAssignmentContext) IsPropertyAssignmentContext() {}

func NewPropertyAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_propertyAssignment

	return p
}

func (s *PropertyAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyAssignmentContext) CopyFrom(ctx *PropertyAssignmentContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PropertyAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PropertyExpressionAssignmentContext struct {
	*PropertyAssignmentContext
}

func NewPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyExpressionAssignmentContext {
	var p = new(PropertyExpressionAssignmentContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExpressionAssignmentContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *PropertyExpressionAssignmentContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPropertyExpressionAssignment(s)
	}
}

func (s *PropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPropertyExpressionAssignment(s)
	}
}

type ComputedPropertyExpressionAssignmentContext struct {
	*PropertyAssignmentContext
}

func NewComputedPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComputedPropertyExpressionAssignmentContext {
	var p = new(ComputedPropertyExpressionAssignmentContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *ComputedPropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedPropertyExpressionAssignmentContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComputedPropertyExpressionAssignmentContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ComputedPropertyExpressionAssignmentContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterComputedPropertyExpressionAssignment(s)
	}
}

func (s *ComputedPropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitComputedPropertyExpressionAssignment(s)
	}
}

type PropertyShorthandContext struct {
	*PropertyAssignmentContext
}

func NewPropertyShorthandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyShorthandContext {
	var p = new(PropertyShorthandContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyShorthandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyShorthandContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyShorthandContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEllipsis, 0)
}

func (s *PropertyShorthandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPropertyShorthand(s)
	}
}

func (s *PropertyShorthandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPropertyShorthand(s)
	}
}

type PropertySetterContext struct {
	*PropertyAssignmentContext
}

func NewPropertySetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertySetterContext {
	var p = new(PropertySetterContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertySetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySetterContext) Setter() ISetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *PropertySetterContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *PropertySetterContext) FormalParameterArg() IFormalParameterArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterArgContext)
}

func (s *PropertySetterContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *PropertySetterContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *PropertySetterContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *PropertySetterContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *PropertySetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPropertySetter(s)
	}
}

func (s *PropertySetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPropertySetter(s)
	}
}

type PropertyGetterContext struct {
	*PropertyAssignmentContext
}

func NewPropertyGetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyGetterContext {
	var p = new(PropertyGetterContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyGetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyGetterContext) Getter() IGetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *PropertyGetterContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *PropertyGetterContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *PropertyGetterContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *PropertyGetterContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *PropertyGetterContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *PropertyGetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPropertyGetter(s)
	}
}

func (s *PropertyGetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPropertyGetter(s)
	}
}

type FunctionPropertyContext struct {
	*PropertyAssignmentContext
}

func NewFunctionPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionPropertyContext {
	var p = new(FunctionPropertyContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *FunctionPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionPropertyContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *FunctionPropertyContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *FunctionPropertyContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *FunctionPropertyContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *FunctionPropertyContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionPropertyContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *FunctionPropertyContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *FunctionPropertyContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *FunctionPropertyContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFunctionProperty(s)
	}
}

func (s *FunctionPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFunctionProperty(s)
	}
}

func (p *JavaScriptParser) PropertyAssignment() (localctx IPropertyAssignmentContext) {
	this := p
	_ = this

	localctx = NewPropertyAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, JavaScriptParserRULE_propertyAssignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(647)
			p.PropertyName()
		}
		{
			p.SetState(648)
			p.Match(JavaScriptParserColon)
		}
		{
			p.SetState(649)
			p.singleExpression(0)
		}

	case 2:
		localctx = NewComputedPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(651)
			p.Match(JavaScriptParserOpenBracket)
		}
		{
			p.SetState(652)
			p.singleExpression(0)
		}
		{
			p.SetState(653)
			p.Match(JavaScriptParserCloseBracket)
		}
		{
			p.SetState(654)
			p.Match(JavaScriptParserColon)
		}
		{
			p.SetState(655)
			p.singleExpression(0)
		}

	case 3:
		localctx = NewFunctionPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(658)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(657)
				p.Match(JavaScriptParserAsync)
			}

		}
		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserMultiply {
			{
				p.SetState(660)
				p.Match(JavaScriptParserMultiply)
			}

		}
		{
			p.SetState(663)
			p.PropertyName()
		}
		{
			p.SetState(664)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || _la == JavaScriptParserIdentifier {
			{
				p.SetState(665)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(668)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(669)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(670)
			p.FunctionBody()
		}
		{
			p.SetState(671)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 4:
		localctx = NewPropertyGetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(673)
			p.Getter()
		}
		{
			p.SetState(674)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(675)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(676)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(677)
			p.FunctionBody()
		}
		{
			p.SetState(678)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 5:
		localctx = NewPropertySetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(680)
			p.Setter()
		}
		{
			p.SetState(681)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(682)
			p.FormalParameterArg()
		}
		{
			p.SetState(683)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(684)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(685)
			p.FunctionBody()
		}
		{
			p.SetState(686)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 6:
		localctx = NewPropertyShorthandContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(689)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserEllipsis {
			{
				p.SetState(688)
				p.Match(JavaScriptParserEllipsis)
			}

		}
		{
			p.SetState(691)
			p.singleExpression(0)
		}

	}

	return localctx
}

// IPropertyNameContext is an interface to support dynamic dispatch.
type IPropertyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyNameContext differentiates from other interfaces.
	IsPropertyNameContext()
}

type PropertyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyNameContext() *PropertyNameContext {
	var p = new(PropertyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_propertyName
	return p
}

func (*PropertyNameContext) IsPropertyNameContext() {}

func NewPropertyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyNameContext {
	var p = new(PropertyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_propertyName

	return p
}

func (s *PropertyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyNameContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *PropertyNameContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStringLiteral, 0)
}

func (s *PropertyNameContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *PropertyNameContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBracket, 0)
}

func (s *PropertyNameContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyNameContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBracket, 0)
}

func (s *PropertyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPropertyName(s)
	}
}

func (s *PropertyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPropertyName(s)
	}
}

func (p *JavaScriptParser) PropertyName() (localctx IPropertyNameContext) {
	this := p
	_ = this

	localctx = NewPropertyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, JavaScriptParserRULE_propertyName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(701)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserImplements, JavaScriptParserLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserYield, JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(694)
			p.IdentifierName()
		}

	case JavaScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(695)
			p.Match(JavaScriptParserStringLiteral)
		}

	case JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(696)
			p.NumericLiteral()
		}

	case JavaScriptParserOpenBracket:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(697)
			p.Match(JavaScriptParserOpenBracket)
		}
		{
			p.SetState(698)
			p.singleExpression(0)
		}
		{
			p.SetState(699)
			p.Match(JavaScriptParserCloseBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ArgumentsContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ArgumentsContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentsContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ArgumentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *JavaScriptParser) Arguments() (localctx IArgumentsContext) {
	this := p
	_ = this

	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, JavaScriptParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(703)
		p.Match(JavaScriptParserOpenParen)
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576460752286842192) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33784848967668287) != 0 {
		{
			p.SetState(704)
			p.Argument()
		}
		p.SetState(709)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(705)
					p.Match(JavaScriptParserComma)
				}
				{
					p.SetState(706)
					p.Argument()
				}

			}
			p.SetState(711)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())
		}
		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserComma {
			{
				p.SetState(712)
				p.Match(JavaScriptParserComma)
			}

		}

	}
	{
		p.SetState(717)
		p.Match(JavaScriptParserCloseParen)
	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ArgumentContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEllipsis, 0)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *JavaScriptParser) Argument() (localctx IArgumentContext) {
	this := p
	_ = this

	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, JavaScriptParserRULE_argument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserEllipsis {
		{
			p.SetState(719)
			p.Match(JavaScriptParserEllipsis)
		}

	}
	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(722)
			p.singleExpression(0)
		}

	case 2:
		{
			p.SetState(723)
			p.Match(JavaScriptParserIdentifier)
		}

	}

	return localctx
}

// IExpressionSequenceContext is an interface to support dynamic dispatch.
type IExpressionSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionSequenceContext differentiates from other interfaces.
	IsExpressionSequenceContext()
}

type ExpressionSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSequenceContext() *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_expressionSequence
	return p
}

func (*ExpressionSequenceContext) IsExpressionSequenceContext() {}

func NewExpressionSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_expressionSequence

	return p
}

func (s *ExpressionSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSequenceContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionSequenceContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ExpressionSequenceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ExpressionSequenceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ExpressionSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterExpressionSequence(s)
	}
}

func (s *ExpressionSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitExpressionSequence(s)
	}
}

func (p *JavaScriptParser) ExpressionSequence() (localctx IExpressionSequenceContext) {
	this := p
	_ = this

	localctx = NewExpressionSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, JavaScriptParserRULE_expressionSequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.singleExpression(0)
	}
	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(727)
				p.Match(JavaScriptParserComma)
			}
			{
				p.SetState(728)
				p.singleExpression(0)
			}

		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext())
	}

	return localctx
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_singleExpression
	return p
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) CopyFrom(ctx *SingleExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TemplateStringExpressionContext struct {
	*SingleExpressionContext
}

func NewTemplateStringExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TemplateStringExpressionContext {
	var p = new(TemplateStringExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TemplateStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TemplateStringExpressionContext) TemplateStringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTemplateStringLiteral, 0)
}

func (s *TemplateStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterTemplateStringExpression(s)
	}
}

func (s *TemplateStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitTemplateStringExpression(s)
	}
}

type TernaryExpressionContext struct {
	*SingleExpressionContext
}

func NewTernaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TernaryExpressionContext {
	var p = new(TernaryExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TernaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TernaryExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TernaryExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserQuestionMark, 0)
}

func (s *TernaryExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *TernaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitTernaryExpression(s)
	}
}

type LogicalAndExpressionContext struct {
	*SingleExpressionContext
}

func NewLogicalAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalAndExpressionContext) And() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAnd, 0)
}

func (s *LogicalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLogicalAndExpression(s)
	}
}

type PowerExpressionContext struct {
	*SingleExpressionContext
}

func NewPowerExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExpressionContext {
	var p = new(PowerExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PowerExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PowerExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PowerExpressionContext) Power() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPower, 0)
}

func (s *PowerExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPowerExpression(s)
	}
}

func (s *PowerExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPowerExpression(s)
	}
}

type PreIncrementExpressionContext struct {
	*SingleExpressionContext
}

func NewPreIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreIncrementExpressionContext {
	var p = new(PreIncrementExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlusPlus, 0)
}

func (s *PreIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPreIncrementExpression(s)
	}
}

type ObjectLiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewObjectLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectLiteralExpressionContext {
	var p = new(ObjectLiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ObjectLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *ObjectLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterObjectLiteralExpression(s)
	}
}

func (s *ObjectLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitObjectLiteralExpression(s)
	}
}

type MetaExpressionContext struct {
	*SingleExpressionContext
}

func NewMetaExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MetaExpressionContext {
	var p = new(MetaExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MetaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetaExpressionContext) New() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNew, 0)
}

func (s *MetaExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDot, 0)
}

func (s *MetaExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *MetaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterMetaExpression(s)
	}
}

func (s *MetaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitMetaExpression(s)
	}
}

type InExpressionContext struct {
	*SingleExpressionContext
}

func NewInExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InExpressionContext {
	var p = new(InExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *InExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InExpressionContext) In() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIn, 0)
}

func (s *InExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterInExpression(s)
	}
}

func (s *InExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitInExpression(s)
	}
}

type LogicalOrExpressionContext struct {
	*SingleExpressionContext
}

func NewLogicalOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalOrExpressionContext) Or() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOr, 0)
}

func (s *LogicalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLogicalOrExpression(s)
	}
}

type NotExpressionContext struct {
	*SingleExpressionContext
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Not() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNot, 0)
}

func (s *NotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

type PreDecreaseExpressionContext struct {
	*SingleExpressionContext
}

func NewPreDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreDecreaseExpressionContext {
	var p = new(PreDecreaseExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinusMinus, 0)
}

func (s *PreDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPreDecreaseExpression(s)
	}
}

func (s *PreDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPreDecreaseExpression(s)
	}
}

type ArgumentsExpressionContext struct {
	*SingleExpressionContext
}

func NewArgumentsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArgumentsExpressionContext {
	var p = new(ArgumentsExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArgumentsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentsExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArgumentsExpression(s)
	}
}

func (s *ArgumentsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArgumentsExpression(s)
	}
}

type AwaitExpressionContext struct {
	*SingleExpressionContext
}

func NewAwaitExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AwaitExpressionContext {
	var p = new(AwaitExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AwaitExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AwaitExpressionContext) Await() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAwait, 0)
}

func (s *AwaitExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AwaitExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAwaitExpression(s)
	}
}

func (s *AwaitExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAwaitExpression(s)
	}
}

type ThisExpressionContext struct {
	*SingleExpressionContext
}

func NewThisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) This() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThis, 0)
}

func (s *ThisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterThisExpression(s)
	}
}

func (s *ThisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitThisExpression(s)
	}
}

type FunctionExpressionContext struct {
	*SingleExpressionContext
}

func NewFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *FunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionContext) AnoymousFunction() IAnoymousFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnoymousFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnoymousFunctionContext)
}

func (s *FunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFunctionExpression(s)
	}
}

type UnaryMinusExpressionContext struct {
	*SingleExpressionContext
}

func NewUnaryMinusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryMinusExpressionContext {
	var p = new(UnaryMinusExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryMinusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryMinusExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinus, 0)
}

func (s *UnaryMinusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryMinusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterUnaryMinusExpression(s)
	}
}

func (s *UnaryMinusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitUnaryMinusExpression(s)
	}
}

type AssignmentExpressionContext struct {
	*SingleExpressionContext
}

func NewAssignmentExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentExpressionContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *AssignmentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAssignmentExpression(s)
	}
}

type PostDecreaseExpressionContext struct {
	*SingleExpressionContext
}

func NewPostDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostDecreaseExpressionContext {
	var p = new(PostDecreaseExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinusMinus, 0)
}

func (s *PostDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPostDecreaseExpression(s)
	}
}

func (s *PostDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPostDecreaseExpression(s)
	}
}

type TypeofExpressionContext struct {
	*SingleExpressionContext
}

func NewTypeofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeofExpressionContext {
	var p = new(TypeofExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TypeofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeofExpressionContext) Typeof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTypeof, 0)
}

func (s *TypeofExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TypeofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterTypeofExpression(s)
	}
}

func (s *TypeofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitTypeofExpression(s)
	}
}

type InstanceofExpressionContext struct {
	*SingleExpressionContext
}

func NewInstanceofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceofExpressionContext {
	var p = new(InstanceofExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *InstanceofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceofExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InstanceofExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InstanceofExpressionContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserInstanceof, 0)
}

func (s *InstanceofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterInstanceofExpression(s)
	}
}

func (s *InstanceofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitInstanceofExpression(s)
	}
}

type UnaryPlusExpressionContext struct {
	*SingleExpressionContext
}

func NewUnaryPlusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryPlusExpressionContext {
	var p = new(UnaryPlusExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryPlusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPlusExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlus, 0)
}

func (s *UnaryPlusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryPlusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterUnaryPlusExpression(s)
	}
}

func (s *UnaryPlusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitUnaryPlusExpression(s)
	}
}

type DeleteExpressionContext struct {
	*SingleExpressionContext
}

func NewDeleteExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteExpressionContext {
	var p = new(DeleteExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *DeleteExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteExpressionContext) Delete() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDelete, 0)
}

func (s *DeleteExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *DeleteExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitDeleteExpression(s)
	}
}

type ImportExpressionContext struct {
	*SingleExpressionContext
}

func NewImportExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportExpressionContext {
	var p = new(ImportExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ImportExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportExpressionContext) Import() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserImport, 0)
}

func (s *ImportExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ImportExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ImportExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ImportExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterImportExpression(s)
	}
}

func (s *ImportExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitImportExpression(s)
	}
}

type EqualityExpressionContext struct {
	*SingleExpressionContext
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *EqualityExpressionContext) Equals_() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEquals_, 0)
}

func (s *EqualityExpressionContext) NotEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNotEquals, 0)
}

func (s *EqualityExpressionContext) IdentityEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentityEquals, 0)
}

func (s *EqualityExpressionContext) IdentityNotEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentityNotEquals, 0)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

type BitXOrExpressionContext struct {
	*SingleExpressionContext
}

func NewBitXOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitXOrExpressionContext {
	var p = new(BitXOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitXOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitXOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitXOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitXOrExpressionContext) BitXOr() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitXOr, 0)
}

func (s *BitXOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBitXOrExpression(s)
	}
}

func (s *BitXOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBitXOrExpression(s)
	}
}

type SuperExpressionContext struct {
	*SingleExpressionContext
}

func NewSuperExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuperExpressionContext {
	var p = new(SuperExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *SuperExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperExpressionContext) Super() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSuper, 0)
}

func (s *SuperExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterSuperExpression(s)
	}
}

func (s *SuperExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitSuperExpression(s)
	}
}

type MultiplicativeExpressionContext struct {
	*SingleExpressionContext
}

func NewMultiplicativeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MultiplicativeExpressionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *MultiplicativeExpressionContext) Divide() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDivide, 0)
}

func (s *MultiplicativeExpressionContext) Modulus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserModulus, 0)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

type BitShiftExpressionContext struct {
	*SingleExpressionContext
}

func NewBitShiftExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitShiftExpressionContext {
	var p = new(BitShiftExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitShiftExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitShiftExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitShiftExpressionContext) LeftShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLeftShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftLogical() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftLogical, 0)
}

func (s *BitShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBitShiftExpression(s)
	}
}

func (s *BitShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBitShiftExpression(s)
	}
}

type ParenthesizedExpressionContext struct {
	*SingleExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ParenthesizedExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ParenthesizedExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type AdditiveExpressionContext struct {
	*SingleExpressionContext
}

func NewAdditiveExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AdditiveExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlus, 0)
}

func (s *AdditiveExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinus, 0)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

type RelationalExpressionContext struct {
	*SingleExpressionContext
}

func NewRelationalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *RelationalExpressionContext) LessThan() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLessThan, 0)
}

func (s *RelationalExpressionContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMoreThan, 0)
}

func (s *RelationalExpressionContext) LessThanEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLessThanEquals, 0)
}

func (s *RelationalExpressionContext) GreaterThanEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserGreaterThanEquals, 0)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

type PostIncrementExpressionContext struct {
	*SingleExpressionContext
}

func NewPostIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostIncrementExpressionContext {
	var p = new(PostIncrementExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlusPlus, 0)
}

func (s *PostIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPostIncrementExpression(s)
	}
}

type YieldExpressionContext struct {
	*SingleExpressionContext
}

func NewYieldExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *YieldExpressionContext {
	var p = new(YieldExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *YieldExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldExpressionContext) YieldStatement() IYieldStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *YieldExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterYieldExpression(s)
	}
}

func (s *YieldExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitYieldExpression(s)
	}
}

type BitNotExpressionContext struct {
	*SingleExpressionContext
}

func NewBitNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitNotExpressionContext {
	var p = new(BitNotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitNotExpressionContext) BitNot() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitNot, 0)
}

func (s *BitNotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitNotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBitNotExpression(s)
	}
}

func (s *BitNotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBitNotExpression(s)
	}
}

type NewExpressionContext struct {
	*SingleExpressionContext
}

func NewNewExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewExpressionContext {
	var p = new(NewExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *NewExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExpressionContext) New() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNew, 0)
}

func (s *NewExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NewExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *NewExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterNewExpression(s)
	}
}

func (s *NewExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitNewExpression(s)
	}
}

type LiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

type ArrayLiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewArrayLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayLiteralExpressionContext {
	var p = new(ArrayLiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArrayLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *ArrayLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArrayLiteralExpression(s)
	}
}

func (s *ArrayLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArrayLiteralExpression(s)
	}
}

type MemberDotExpressionContext struct {
	*SingleExpressionContext
}

func NewMemberDotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberDotExpressionContext {
	var p = new(MemberDotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberDotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberDotExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDot, 0)
}

func (s *MemberDotExpressionContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *MemberDotExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserQuestionMark, 0)
}

func (s *MemberDotExpressionContext) Hashtag() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserHashtag, 0)
}

func (s *MemberDotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterMemberDotExpression(s)
	}
}

func (s *MemberDotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitMemberDotExpression(s)
	}
}

type ClassExpressionContext struct {
	*SingleExpressionContext
}

func NewClassExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClassExpressionContext {
	var p = new(ClassExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ClassExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassExpressionContext) Class() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserClass, 0)
}

func (s *ClassExpressionContext) ClassTail() IClassTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTailContext)
}

func (s *ClassExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ClassExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterClassExpression(s)
	}
}

func (s *ClassExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitClassExpression(s)
	}
}

type MemberIndexExpressionContext struct {
	*SingleExpressionContext
}

func NewMemberIndexExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberIndexExpressionContext {
	var p = new(MemberIndexExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberIndexExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberIndexExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberIndexExpressionContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBracket, 0)
}

func (s *MemberIndexExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *MemberIndexExpressionContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBracket, 0)
}

func (s *MemberIndexExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterMemberIndexExpression(s)
	}
}

func (s *MemberIndexExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitMemberIndexExpression(s)
	}
}

type IdentifierExpressionContext struct {
	*SingleExpressionContext
}

func NewIdentifierExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierExpressionContext {
	var p = new(IdentifierExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *IdentifierExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *IdentifierExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterIdentifierExpression(s)
	}
}

func (s *IdentifierExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitIdentifierExpression(s)
	}
}

type BitAndExpressionContext struct {
	*SingleExpressionContext
}

func NewBitAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitAndExpressionContext {
	var p = new(BitAndExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitAndExpressionContext) BitAnd() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitAnd, 0)
}

func (s *BitAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBitAndExpression(s)
	}
}

func (s *BitAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBitAndExpression(s)
	}
}

type BitOrExpressionContext struct {
	*SingleExpressionContext
}

func NewBitOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitOrExpressionContext {
	var p = new(BitOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitOrExpressionContext) BitOr() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitOr, 0)
}

func (s *BitOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBitOrExpression(s)
	}
}

func (s *BitOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBitOrExpression(s)
	}
}

type AssignmentOperatorExpressionContext struct {
	*SingleExpressionContext
}

func NewAssignmentOperatorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentOperatorExpressionContext {
	var p = new(AssignmentOperatorExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentOperatorExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentOperatorExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAssignmentOperatorExpression(s)
	}
}

func (s *AssignmentOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAssignmentOperatorExpression(s)
	}
}

type VoidExpressionContext struct {
	*SingleExpressionContext
}

func NewVoidExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VoidExpressionContext {
	var p = new(VoidExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *VoidExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VoidExpressionContext) Void() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVoid, 0)
}

func (s *VoidExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VoidExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterVoidExpression(s)
	}
}

func (s *VoidExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitVoidExpression(s)
	}
}

type CoalesceExpressionContext struct {
	*SingleExpressionContext
}

func NewCoalesceExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CoalesceExpressionContext {
	var p = new(CoalesceExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *CoalesceExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CoalesceExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CoalesceExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *CoalesceExpressionContext) NullCoalesce() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNullCoalesce, 0)
}

func (s *CoalesceExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterCoalesceExpression(s)
	}
}

func (s *CoalesceExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitCoalesceExpression(s)
	}
}

func (p *JavaScriptParser) SingleExpression() (localctx ISingleExpressionContext) {
	return p.singleExpression(0)
}

func (p *JavaScriptParser) singleExpression(_p int) (localctx ISingleExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISingleExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 116
	p.EnterRecursionRule(localctx, 116, JavaScriptParserRULE_singleExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(735)
			p.AnoymousFunction()
		}

	case 2:
		localctx = NewClassExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(736)
			p.Match(JavaScriptParserClass)
		}
		p.SetState(738)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserIdentifier {
			{
				p.SetState(737)
				p.Match(JavaScriptParserIdentifier)
			}

		}
		{
			p.SetState(740)
			p.ClassTail()
		}

	case 3:
		localctx = NewNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(741)
			p.Match(JavaScriptParserNew)
		}
		{
			p.SetState(742)
			p.singleExpression(0)
		}
		p.SetState(744)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(743)
				p.Arguments()
			}

		}

	case 4:
		localctx = NewMetaExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(746)
			p.Match(JavaScriptParserNew)
		}
		{
			p.SetState(747)
			p.Match(JavaScriptParserDot)
		}
		{
			p.SetState(748)
			p.Match(JavaScriptParserIdentifier)
		}

	case 5:
		localctx = NewDeleteExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(749)
			p.Match(JavaScriptParserDelete)
		}
		{
			p.SetState(750)
			p.singleExpression(37)
		}

	case 6:
		localctx = NewVoidExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(751)
			p.Match(JavaScriptParserVoid)
		}
		{
			p.SetState(752)
			p.singleExpression(36)
		}

	case 7:
		localctx = NewTypeofExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(753)
			p.Match(JavaScriptParserTypeof)
		}
		{
			p.SetState(754)
			p.singleExpression(35)
		}

	case 8:
		localctx = NewPreIncrementExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(755)
			p.Match(JavaScriptParserPlusPlus)
		}
		{
			p.SetState(756)
			p.singleExpression(34)
		}

	case 9:
		localctx = NewPreDecreaseExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(757)
			p.Match(JavaScriptParserMinusMinus)
		}
		{
			p.SetState(758)
			p.singleExpression(33)
		}

	case 10:
		localctx = NewUnaryPlusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(759)
			p.Match(JavaScriptParserPlus)
		}
		{
			p.SetState(760)
			p.singleExpression(32)
		}

	case 11:
		localctx = NewUnaryMinusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(761)
			p.Match(JavaScriptParserMinus)
		}
		{
			p.SetState(762)
			p.singleExpression(31)
		}

	case 12:
		localctx = NewBitNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(763)
			p.Match(JavaScriptParserBitNot)
		}
		{
			p.SetState(764)
			p.singleExpression(30)
		}

	case 13:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(765)
			p.Match(JavaScriptParserNot)
		}
		{
			p.SetState(766)
			p.singleExpression(29)
		}

	case 14:
		localctx = NewAwaitExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(767)
			p.Match(JavaScriptParserAwait)
		}
		{
			p.SetState(768)
			p.singleExpression(28)
		}

	case 15:
		localctx = NewImportExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(769)
			p.Match(JavaScriptParserImport)
		}
		{
			p.SetState(770)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(771)
			p.singleExpression(0)
		}
		{
			p.SetState(772)
			p.Match(JavaScriptParserCloseParen)
		}

	case 16:
		localctx = NewYieldExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(774)
			p.YieldStatement()
		}

	case 17:
		localctx = NewThisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(775)
			p.Match(JavaScriptParserThis)
		}

	case 18:
		localctx = NewIdentifierExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(776)
			p.Match(JavaScriptParserIdentifier)
		}

	case 19:
		localctx = NewSuperExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(777)
			p.Match(JavaScriptParserSuper)
		}

	case 20:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(778)
			p.Literal()
		}

	case 21:
		localctx = NewArrayLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(779)
			p.ArrayLiteral()
		}

	case 22:
		localctx = NewObjectLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(780)
			p.ObjectLiteral()
		}

	case 23:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(781)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(782)
			p.ExpressionSequence()
		}
		{
			p.SetState(783)
			p.Match(JavaScriptParserCloseParen)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(866)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPowerExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(787)

				if !(p.Precpred(p.GetParserRuleContext(), 27)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 27)", ""))
				}
				{
					p.SetState(788)
					p.Match(JavaScriptParserPower)
				}
				{
					p.SetState(789)
					p.singleExpression(27)
				}

			case 2:
				localctx = NewMultiplicativeExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(790)

				if !(p.Precpred(p.GetParserRuleContext(), 26)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 26)", ""))
				}
				{
					p.SetState(791)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&117440512) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(792)
					p.singleExpression(27)
				}

			case 3:
				localctx = NewAdditiveExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(793)

				if !(p.Precpred(p.GetParserRuleContext(), 25)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 25)", ""))
				}
				{
					p.SetState(794)
					_la = p.GetTokenStream().LA(1)

					if !(_la == JavaScriptParserPlus || _la == JavaScriptParserMinus) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(795)
					p.singleExpression(26)
				}

			case 4:
				localctx = NewCoalesceExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(796)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
				}
				{
					p.SetState(797)
					p.Match(JavaScriptParserNullCoalesce)
				}
				{
					p.SetState(798)
					p.singleExpression(25)
				}

			case 5:
				localctx = NewBitShiftExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(799)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
				}
				{
					p.SetState(800)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7516192768) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(801)
					p.singleExpression(24)
				}

			case 6:
				localctx = NewRelationalExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(802)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
				}
				{
					p.SetState(803)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&128849018880) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(804)
					p.singleExpression(23)
				}

			case 7:
				localctx = NewInstanceofExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(805)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(806)
					p.Match(JavaScriptParserInstanceof)
				}
				{
					p.SetState(807)
					p.singleExpression(22)
				}

			case 8:
				localctx = NewInExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(808)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				{
					p.SetState(809)
					p.Match(JavaScriptParserIn)
				}
				{
					p.SetState(810)
					p.singleExpression(21)
				}

			case 9:
				localctx = NewEqualityExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(811)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				{
					p.SetState(812)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2061584302080) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(813)
					p.singleExpression(20)
				}

			case 10:
				localctx = NewBitAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(814)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(815)
					p.Match(JavaScriptParserBitAnd)
				}
				{
					p.SetState(816)
					p.singleExpression(19)
				}

			case 11:
				localctx = NewBitXOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(817)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(818)
					p.Match(JavaScriptParserBitXOr)
				}
				{
					p.SetState(819)
					p.singleExpression(18)
				}

			case 12:
				localctx = NewBitOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(820)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(821)
					p.Match(JavaScriptParserBitOr)
				}
				{
					p.SetState(822)
					p.singleExpression(17)
				}

			case 13:
				localctx = NewLogicalAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(823)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(824)
					p.Match(JavaScriptParserAnd)
				}
				{
					p.SetState(825)
					p.singleExpression(16)
				}

			case 14:
				localctx = NewLogicalOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(826)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(827)
					p.Match(JavaScriptParserOr)
				}
				{
					p.SetState(828)
					p.singleExpression(15)
				}

			case 15:
				localctx = NewTernaryExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(829)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(830)
					p.Match(JavaScriptParserQuestionMark)
				}
				{
					p.SetState(831)
					p.singleExpression(0)
				}
				{
					p.SetState(832)
					p.Match(JavaScriptParserColon)
				}
				{
					p.SetState(833)
					p.singleExpression(14)
				}

			case 16:
				localctx = NewAssignmentExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(835)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(836)
					p.Match(JavaScriptParserAssign)
				}
				{
					p.SetState(837)
					p.singleExpression(12)
				}

			case 17:
				localctx = NewAssignmentOperatorExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(838)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(839)
					p.AssignmentOperator()
				}
				{
					p.SetState(840)
					p.singleExpression(11)
				}

			case 18:
				localctx = NewMemberIndexExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(842)

				if !(p.Precpred(p.GetParserRuleContext(), 44)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 44)", ""))
				}
				{
					p.SetState(843)
					p.Match(JavaScriptParserOpenBracket)
				}
				{
					p.SetState(844)
					p.ExpressionSequence()
				}
				{
					p.SetState(845)
					p.Match(JavaScriptParserCloseBracket)
				}

			case 19:
				localctx = NewMemberDotExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(847)

				if !(p.Precpred(p.GetParserRuleContext(), 43)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 43)", ""))
				}
				p.SetState(849)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == JavaScriptParserQuestionMark {
					{
						p.SetState(848)
						p.Match(JavaScriptParserQuestionMark)
					}

				}
				{
					p.SetState(851)
					p.Match(JavaScriptParserDot)
				}
				p.SetState(853)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == JavaScriptParserHashtag {
					{
						p.SetState(852)
						p.Match(JavaScriptParserHashtag)
					}

				}
				{
					p.SetState(855)
					p.IdentifierName()
				}

			case 20:
				localctx = NewArgumentsExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(856)

				if !(p.Precpred(p.GetParserRuleContext(), 42)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 42)", ""))
				}
				{
					p.SetState(857)
					p.Arguments()
				}

			case 21:
				localctx = NewPostIncrementExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(858)

				if !(p.Precpred(p.GetParserRuleContext(), 39)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 39)", ""))
				}
				p.SetState(859)

				if !(p.notLineTerminator()) {
					panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
				}
				{
					p.SetState(860)
					p.Match(JavaScriptParserPlusPlus)
				}

			case 22:
				localctx = NewPostDecreaseExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(861)

				if !(p.Precpred(p.GetParserRuleContext(), 38)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 38)", ""))
				}
				p.SetState(862)

				if !(p.notLineTerminator()) {
					panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
				}
				{
					p.SetState(863)
					p.Match(JavaScriptParserMinusMinus)
				}

			case 23:
				localctx = NewTemplateStringExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(864)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(865)
					p.Match(JavaScriptParserTemplateStringLiteral)
				}

			}

		}
		p.SetState(870)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())
	}

	return localctx
}

// IAssignableContext is an interface to support dynamic dispatch.
type IAssignableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignableContext differentiates from other interfaces.
	IsAssignableContext()
}

type AssignableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableContext() *AssignableContext {
	var p = new(AssignableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_assignable
	return p
}

func (*AssignableContext) IsAssignableContext() {}

func NewAssignableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableContext {
	var p = new(AssignableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_assignable

	return p
}

func (s *AssignableContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *AssignableContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *AssignableContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *AssignableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAssignable(s)
	}
}

func (s *AssignableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAssignable(s)
	}
}

func (p *JavaScriptParser) Assignable() (localctx IAssignableContext) {
	this := p
	_ = this

	localctx = NewAssignableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, JavaScriptParserRULE_assignable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(874)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(871)
			p.Match(JavaScriptParserIdentifier)
		}

	case JavaScriptParserOpenBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(872)
			p.ArrayLiteral()
		}

	case JavaScriptParserOpenBrace:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(873)
			p.ObjectLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnoymousFunctionContext is an interface to support dynamic dispatch.
type IAnoymousFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnoymousFunctionContext differentiates from other interfaces.
	IsAnoymousFunctionContext()
}

type AnoymousFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnoymousFunctionContext() *AnoymousFunctionContext {
	var p = new(AnoymousFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_anoymousFunction
	return p
}

func (*AnoymousFunctionContext) IsAnoymousFunctionContext() {}

func NewAnoymousFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnoymousFunctionContext {
	var p = new(AnoymousFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_anoymousFunction

	return p
}

func (s *AnoymousFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AnoymousFunctionContext) CopyFrom(ctx *AnoymousFunctionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AnoymousFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnoymousFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AnoymousFunctionDeclContext struct {
	*AnoymousFunctionContext
}

func NewAnoymousFunctionDeclContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnoymousFunctionDeclContext {
	var p = new(AnoymousFunctionDeclContext)

	p.AnoymousFunctionContext = NewEmptyAnoymousFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AnoymousFunctionContext))

	return p
}

func (s *AnoymousFunctionDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnoymousFunctionDeclContext) Function() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFunction, 0)
}

func (s *AnoymousFunctionDeclContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *AnoymousFunctionDeclContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *AnoymousFunctionDeclContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *AnoymousFunctionDeclContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *AnoymousFunctionDeclContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *AnoymousFunctionDeclContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *AnoymousFunctionDeclContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *AnoymousFunctionDeclContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *AnoymousFunctionDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAnoymousFunctionDecl(s)
	}
}

func (s *AnoymousFunctionDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAnoymousFunctionDecl(s)
	}
}

type ArrowFunctionContext struct {
	*AnoymousFunctionContext
}

func NewArrowFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowFunctionContext {
	var p = new(ArrowFunctionContext)

	p.AnoymousFunctionContext = NewEmptyAnoymousFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AnoymousFunctionContext))

	return p
}

func (s *ArrowFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionContext) ArrowFunctionParameters() IArrowFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionParametersContext)
}

func (s *ArrowFunctionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserARROW, 0)
}

func (s *ArrowFunctionContext) ArrowFunctionBody() IArrowFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionBodyContext)
}

func (s *ArrowFunctionContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *ArrowFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArrowFunction(s)
	}
}

func (s *ArrowFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArrowFunction(s)
	}
}

type FunctionDeclContext struct {
	*AnoymousFunctionContext
}

func NewFunctionDeclContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionDeclContext {
	var p = new(FunctionDeclContext)

	p.AnoymousFunctionContext = NewEmptyAnoymousFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AnoymousFunctionContext))

	return p
}

func (s *FunctionDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *FunctionDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFunctionDecl(s)
	}
}

func (s *FunctionDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFunctionDecl(s)
	}
}

func (p *JavaScriptParser) AnoymousFunction() (localctx IAnoymousFunctionContext) {
	this := p
	_ = this

	localctx = NewAnoymousFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, JavaScriptParserRULE_anoymousFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFunctionDeclContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(876)
			p.FunctionDeclaration()
		}

	case 2:
		localctx = NewAnoymousFunctionDeclContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(878)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserAsync {
			{
				p.SetState(877)
				p.Match(JavaScriptParserAsync)
			}

		}
		{
			p.SetState(880)
			p.Match(JavaScriptParserFunction)
		}
		p.SetState(882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserMultiply {
			{
				p.SetState(881)
				p.Match(JavaScriptParserMultiply)
			}

		}
		{
			p.SetState(884)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || _la == JavaScriptParserIdentifier {
			{
				p.SetState(885)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(888)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(889)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(890)
			p.FunctionBody()
		}
		{
			p.SetState(891)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 3:
		localctx = NewArrowFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserAsync {
			{
				p.SetState(893)
				p.Match(JavaScriptParserAsync)
			}

		}
		{
			p.SetState(896)
			p.ArrowFunctionParameters()
		}
		{
			p.SetState(897)
			p.Match(JavaScriptParserARROW)
		}
		{
			p.SetState(898)
			p.ArrowFunctionBody()
		}

	}

	return localctx
}

// IArrowFunctionParametersContext is an interface to support dynamic dispatch.
type IArrowFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowFunctionParametersContext differentiates from other interfaces.
	IsArrowFunctionParametersContext()
}

type ArrowFunctionParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionParametersContext() *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionParameters
	return p
}

func (*ArrowFunctionParametersContext) IsArrowFunctionParametersContext() {}

func NewArrowFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionParameters

	return p
}

func (s *ArrowFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionParametersContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ArrowFunctionParametersContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ArrowFunctionParametersContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ArrowFunctionParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ArrowFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArrowFunctionParameters(s)
	}
}

func (s *ArrowFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArrowFunctionParameters(s)
	}
}

func (p *JavaScriptParser) ArrowFunctionParameters() (localctx IArrowFunctionParametersContext) {
	this := p
	_ = this

	localctx = NewArrowFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, JavaScriptParserRULE_arrowFunctionParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(908)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(902)
			p.Match(JavaScriptParserIdentifier)
		}

	case JavaScriptParserOpenParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(903)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(905)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&66080) != 0 || _la == JavaScriptParserIdentifier {
			{
				p.SetState(904)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(907)
			p.Match(JavaScriptParserCloseParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrowFunctionBodyContext is an interface to support dynamic dispatch.
type IArrowFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowFunctionBodyContext differentiates from other interfaces.
	IsArrowFunctionBodyContext()
}

type ArrowFunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionBodyContext() *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionBody
	return p
}

func (*ArrowFunctionBodyContext) IsArrowFunctionBodyContext() {}

func NewArrowFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionBody

	return p
}

func (s *ArrowFunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionBodyContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrowFunctionBodyContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *ArrowFunctionBodyContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *ArrowFunctionBodyContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *ArrowFunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArrowFunctionBody(s)
	}
}

func (s *ArrowFunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArrowFunctionBody(s)
	}
}

func (p *JavaScriptParser) ArrowFunctionBody() (localctx IArrowFunctionBodyContext) {
	this := p
	_ = this

	localctx = NewArrowFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, JavaScriptParserRULE_arrowFunctionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(910)
			p.singleExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(911)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(912)
			p.FunctionBody()
		}
		{
			p.SetState(913)
			p.Match(JavaScriptParserCloseBrace)
		}

	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) MultiplyAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiplyAssign, 0)
}

func (s *AssignmentOperatorContext) DivideAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDivideAssign, 0)
}

func (s *AssignmentOperatorContext) ModulusAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserModulusAssign, 0)
}

func (s *AssignmentOperatorContext) PlusAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlusAssign, 0)
}

func (s *AssignmentOperatorContext) MinusAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinusAssign, 0)
}

func (s *AssignmentOperatorContext) LeftShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLeftShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftLogicalAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftLogicalAssign, 0)
}

func (s *AssignmentOperatorContext) BitAndAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitAndAssign, 0)
}

func (s *AssignmentOperatorContext) BitXorAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitXorAssign, 0)
}

func (s *AssignmentOperatorContext) BitOrAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitOrAssign, 0)
}

func (s *AssignmentOperatorContext) PowerAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPowerAssign, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (p *JavaScriptParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	this := p
	_ = this

	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, JavaScriptParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(917)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&288160007407534080) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNullLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBooleanLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStringLiteral, 0)
}

func (s *LiteralContext) TemplateStringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTemplateStringLiteral, 0)
}

func (s *LiteralContext) RegularExpressionLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRegularExpressionLiteral, 0)
}

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) BigintLiteral() IBigintLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBigintLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBigintLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *JavaScriptParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, JavaScriptParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(926)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(919)
			p.Match(JavaScriptParserNullLiteral)
		}

	case JavaScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(920)
			p.Match(JavaScriptParserBooleanLiteral)
		}

	case JavaScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(921)
			p.Match(JavaScriptParserStringLiteral)
		}

	case JavaScriptParserTemplateStringLiteral:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(922)
			p.Match(JavaScriptParserTemplateStringLiteral)
		}

	case JavaScriptParserRegularExpressionLiteral:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(923)
			p.Match(JavaScriptParserRegularExpressionLiteral)
		}

	case JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(924)
			p.NumericLiteral()
		}

	case JavaScriptParserBigHexIntegerLiteral, JavaScriptParserBigOctalIntegerLiteral, JavaScriptParserBigBinaryIntegerLiteral, JavaScriptParserBigDecimalIntegerLiteral:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(925)
			p.BigintLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_numericLiteral
	return p
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) DecimalLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDecimalLiteral, 0)
}

func (s *NumericLiteralContext) HexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserHexIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOctalIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral2() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOctalIntegerLiteral2, 0)
}

func (s *NumericLiteralContext) BinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBinaryIntegerLiteral, 0)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (p *JavaScriptParser) NumericLiteral() (localctx INumericLiteralContext) {
	this := p
	_ = this

	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, JavaScriptParserRULE_numericLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-61)) & ^0x3f) == 0 && ((int64(1)<<(_la-61))&31) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBigintLiteralContext is an interface to support dynamic dispatch.
type IBigintLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBigintLiteralContext differentiates from other interfaces.
	IsBigintLiteralContext()
}

type BigintLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBigintLiteralContext() *BigintLiteralContext {
	var p = new(BigintLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_bigintLiteral
	return p
}

func (*BigintLiteralContext) IsBigintLiteralContext() {}

func NewBigintLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BigintLiteralContext {
	var p = new(BigintLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_bigintLiteral

	return p
}

func (s *BigintLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BigintLiteralContext) BigDecimalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBigDecimalIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigHexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBigHexIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigOctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBigOctalIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigBinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBigBinaryIntegerLiteral, 0)
}

func (s *BigintLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BigintLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BigintLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBigintLiteral(s)
	}
}

func (s *BigintLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBigintLiteral(s)
	}
}

func (p *JavaScriptParser) BigintLiteral() (localctx IBigintLiteralContext) {
	this := p
	_ = this

	localctx = NewBigintLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, JavaScriptParserRULE_bigintLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifierNameContext is an interface to support dynamic dispatch.
type IIdentifierNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierNameContext differentiates from other interfaces.
	IsIdentifierNameContext()
}

type IdentifierNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierNameContext() *IdentifierNameContext {
	var p = new(IdentifierNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_identifierName
	return p
}

func (*IdentifierNameContext) IsIdentifierNameContext() {}

func NewIdentifierNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierNameContext {
	var p = new(IdentifierNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_identifierName

	return p
}

func (s *IdentifierNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *IdentifierNameContext) ReservedWord() IReservedWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedWordContext)
}

func (s *IdentifierNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterIdentifierName(s)
	}
}

func (s *IdentifierNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitIdentifierName(s)
	}
}

func (p *JavaScriptParser) IdentifierName() (localctx IIdentifierNameContext) {
	this := p
	_ = this

	localctx = NewIdentifierNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, JavaScriptParserRULE_identifierName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(934)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(932)
			p.Match(JavaScriptParserIdentifier)
		}

	case JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserImplements, JavaScriptParserLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserYield:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(933)
			p.ReservedWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_reservedWord
	return p
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedWordContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *ReservedWordContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNullLiteral, 0)
}

func (s *ReservedWordContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBooleanLiteral, 0)
}

func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterReservedWord(s)
	}
}

func (s *ReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitReservedWord(s)
	}
}

func (p *JavaScriptParser) ReservedWord() (localctx IReservedWordContext) {
	this := p
	_ = this

	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, JavaScriptParserRULE_reservedWord)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(939)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserImplements, JavaScriptParserLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserYield:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(936)
			p.Keyword()
		}

	case JavaScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(937)
			p.Match(JavaScriptParserNullLiteral)
		}

	case JavaScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(938)
			p.Match(JavaScriptParserBooleanLiteral)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_keyword
	return p
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) Break() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBreak, 0)
}

func (s *KeywordContext) Do() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDo, 0)
}

func (s *KeywordContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserInstanceof, 0)
}

func (s *KeywordContext) Typeof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTypeof, 0)
}

func (s *KeywordContext) Case() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCase, 0)
}

func (s *KeywordContext) Else() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserElse, 0)
}

func (s *KeywordContext) New() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNew, 0)
}

func (s *KeywordContext) Var() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVar, 0)
}

func (s *KeywordContext) Catch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCatch, 0)
}

func (s *KeywordContext) Finally() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFinally, 0)
}

func (s *KeywordContext) Return() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserReturn, 0)
}

func (s *KeywordContext) Void() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVoid, 0)
}

func (s *KeywordContext) Continue() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserContinue, 0)
}

func (s *KeywordContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *KeywordContext) Switch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSwitch, 0)
}

func (s *KeywordContext) While() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWhile, 0)
}

func (s *KeywordContext) Debugger() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDebugger, 0)
}

func (s *KeywordContext) Function() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFunction, 0)
}

func (s *KeywordContext) This() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThis, 0)
}

func (s *KeywordContext) With() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWith, 0)
}

func (s *KeywordContext) Default() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDefault, 0)
}

func (s *KeywordContext) If() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIf, 0)
}

func (s *KeywordContext) Throw() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThrow, 0)
}

func (s *KeywordContext) Delete() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDelete, 0)
}

func (s *KeywordContext) In() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIn, 0)
}

func (s *KeywordContext) Try() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTry, 0)
}

func (s *KeywordContext) Class() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserClass, 0)
}

func (s *KeywordContext) Enum() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEnum, 0)
}

func (s *KeywordContext) Extends() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExtends, 0)
}

func (s *KeywordContext) Super() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSuper, 0)
}

func (s *KeywordContext) Const() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserConst, 0)
}

func (s *KeywordContext) Export() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExport, 0)
}

func (s *KeywordContext) Import() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserImport, 0)
}

func (s *KeywordContext) Implements() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserImplements, 0)
}

func (s *KeywordContext) Let() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLet, 0)
}

func (s *KeywordContext) Private() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPrivate, 0)
}

func (s *KeywordContext) Public() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPublic, 0)
}

func (s *KeywordContext) Interface() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserInterface, 0)
}

func (s *KeywordContext) Package() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPackage, 0)
}

func (s *KeywordContext) Protected() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserProtected, 0)
}

func (s *KeywordContext) Static() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStatic, 0)
}

func (s *KeywordContext) Yield() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserYield, 0)
}

func (s *KeywordContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *KeywordContext) Await() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAwait, 0)
}

func (s *KeywordContext) From() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFrom, 0)
}

func (s *KeywordContext) As() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAs, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (p *JavaScriptParser) Keyword() (localctx IKeywordContext) {
	this := p
	_ = this

	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, JavaScriptParserRULE_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(941)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&70368744177663) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_getter
	return p
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *GetterContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterGetter(s)
	}
}

func (s *GetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitGetter(s)
	}
}

func (p *JavaScriptParser) Getter() (localctx IGetterContext) {
	this := p
	_ = this

	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, JavaScriptParserRULE_getter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(943)
		p.Match(JavaScriptParserIdentifier)
	}
	p.SetState(944)

	if !(p.p("get")) {
		panic(antlr.NewFailedPredicateException(p, "p.p(\"get\")", ""))
	}
	{
		p.SetState(945)
		p.PropertyName()
	}

	return localctx
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_setter
	return p
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *SetterContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterSetter(s)
	}
}

func (s *SetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitSetter(s)
	}
}

func (p *JavaScriptParser) Setter() (localctx ISetterContext) {
	this := p
	_ = this

	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, JavaScriptParserRULE_setter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(947)
		p.Match(JavaScriptParserIdentifier)
	}
	p.SetState(948)

	if !(p.p("set")) {
		panic(antlr.NewFailedPredicateException(p, "p.p(\"set\")", ""))
	}
	{
		p.SetState(949)
		p.PropertyName()
	}

	return localctx
}

// IEosContext is an interface to support dynamic dispatch.
type IEosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEosContext differentiates from other interfaces.
	IsEosContext()
}

type EosContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosContext() *EosContext {
	var p = new(EosContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_eos
	return p
}

func (*EosContext) IsEosContext() {}

func NewEosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosContext {
	var p = new(EosContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_eos

	return p
}

func (s *EosContext) GetParser() antlr.Parser { return s.parser }

func (s *EosContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSemiColon, 0)
}

func (s *EosContext) EOF() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEOF, 0)
}

func (s *EosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterEos(s)
	}
}

func (s *EosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitEos(s)
	}
}

func (p *JavaScriptParser) Eos() (localctx IEosContext) {
	this := p
	_ = this

	localctx = NewEosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, JavaScriptParserRULE_eos)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(951)
			p.Match(JavaScriptParserSemiColon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(952)
			p.Match(JavaScriptParserEOF)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(953)

		if !(p.lineTerminatorAhead()) {
			panic(antlr.NewFailedPredicateException(p, "p.lineTerminatorAhead()", ""))
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(954)

		if !(p.closeBrace()) {
			panic(antlr.NewFailedPredicateException(p, "p.closeBrace()", ""))
		}

	}

	return localctx
}

func (p *JavaScriptParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 19:
		var t *ExpressionStatementContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionStatementContext)
		}
		return p.ExpressionStatement_Sempred(t, predIndex)

	case 21:
		var t *IterationStatementContext = nil
		if localctx != nil {
			t = localctx.(*IterationStatementContext)
		}
		return p.IterationStatement_Sempred(t, predIndex)

	case 23:
		var t *ContinueStatementContext = nil
		if localctx != nil {
			t = localctx.(*ContinueStatementContext)
		}
		return p.ContinueStatement_Sempred(t, predIndex)

	case 24:
		var t *BreakStatementContext = nil
		if localctx != nil {
			t = localctx.(*BreakStatementContext)
		}
		return p.BreakStatement_Sempred(t, predIndex)

	case 25:
		var t *ReturnStatementContext = nil
		if localctx != nil {
			t = localctx.(*ReturnStatementContext)
		}
		return p.ReturnStatement_Sempred(t, predIndex)

	case 26:
		var t *YieldStatementContext = nil
		if localctx != nil {
			t = localctx.(*YieldStatementContext)
		}
		return p.YieldStatement_Sempred(t, predIndex)

	case 34:
		var t *ThrowStatementContext = nil
		if localctx != nil {
			t = localctx.(*ThrowStatementContext)
		}
		return p.ThrowStatement_Sempred(t, predIndex)

	case 42:
		var t *ClassElementContext = nil
		if localctx != nil {
			t = localctx.(*ClassElementContext)
		}
		return p.ClassElement_Sempred(t, predIndex)

	case 58:
		var t *SingleExpressionContext = nil
		if localctx != nil {
			t = localctx.(*SingleExpressionContext)
		}
		return p.SingleExpression_Sempred(t, predIndex)

	case 70:
		var t *GetterContext = nil
		if localctx != nil {
			t = localctx.(*GetterContext)
		}
		return p.Getter_Sempred(t, predIndex)

	case 71:
		var t *SetterContext = nil
		if localctx != nil {
			t = localctx.(*SetterContext)
		}
		return p.Setter_Sempred(t, predIndex)

	case 72:
		var t *EosContext = nil
		if localctx != nil {
			t = localctx.(*EosContext)
		}
		return p.Eos_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *JavaScriptParser) ExpressionStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.notOpenBraceAndNotFunction()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) IterationStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.p("of")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ContinueStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) BreakStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 3:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ReturnStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 4:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) YieldStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 5:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ThrowStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 6:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ClassElement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 7:
		return p.n("static")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) SingleExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 27)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 26)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 25)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 24:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 44)

	case 26:
		return p.Precpred(p.GetParserRuleContext(), 43)

	case 27:
		return p.Precpred(p.GetParserRuleContext(), 42)

	case 28:
		return p.Precpred(p.GetParserRuleContext(), 39)

	case 29:
		return p.notLineTerminator()

	case 30:
		return p.Precpred(p.GetParserRuleContext(), 38)

	case 31:
		return p.notLineTerminator()

	case 32:
		return p.Precpred(p.GetParserRuleContext(), 9)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) Getter_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 33:
		return p.p("get")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) Setter_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 34:
		return p.p("set")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) Eos_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 35:
		return p.lineTerminatorAhead()

	case 36:
		return p.closeBrace()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
